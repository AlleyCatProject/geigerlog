#! /usr/bin/python3
# -*- coding: utf-8 -*-

"""
GeigerLog - A program with a Graphical User Interface to handle Geiger counters
as well as environmental sensors for Temperature, Pressure, Humidity, and else

Start as 'geigerlog -h' for help on available options and commands
Use GeigerLog-Manual-v<version number>.pdf for further details
"""

###############################################################################
#    This file is part of GeigerLog.
#
#    GeigerLog is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    GeigerLog is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with GeigerLog.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################

__author__          = "ullix"
__copyright__       = "Copyright 2016, 2017, 2018, 2019"
__credits__         = [""]
__license__         = "GPL3"

import sys                      # system functions
# Testing for proper Python version; Python v3 is required.
# Check must be done up here, as some imports are not possible on Py2!
if sys.version_info[0] < 3:
    msg = """
        This version of GeigerLog requires Python 3!
        Your Python version is: {}

        The preferred way is to upgrade to Python 3. If you can't do that, you can
        download a copy of GeigerLog, which runs on Python 2 from:

        https://sourceforge.net/projects/geigerlog/

        The last version of GeigerLog for Python 2 is GeigerLog 0.9.06.
        Future versions will all be for Python 3.
        """.format(sys.version[:7])
    print("\7")
    print (msg)
    sys.exit(1)

from   gutils            import *

import getopt                   # parse command line for options and commands
import signal                   # handling signals like CTRL-C and other
import subprocess               # to allow terminal commands tput rmam / tput smam
import scipy.signal             # a subpackage of scipy; needs separate import
import scipy.stats              # a subpackage of scipy; needs separate import

import gcommands
import ghist
import gplot
import gradmon
import gambiomon
import gsql
import gtools
import gsynth
import gaudio
import gi2c


def     addMenuTip(var, text):
    """add menu tip and status tip; works only on PyQt5, not PyQt4"""

    # e.g.:   PlotLogAction.setStatusTip('Plot the Log file')
    #         PlotLogAction.setToolTip('Plot the Log file')
    #     --> addMenuTip(PlotLogAction, 'Plot the Log file')

    #print("addMenuTip:", var, text)
    var.setStatusTip(text)
    var.setToolTip(text)


class ggeiger(QMainWindow):

    def __init__(self):
        super(ggeiger, self).__init__()

        gglobs.ex = self

        # hold the updated variable values in self.updateDisplayVariableValue()
        self.vlabels = [None] * len(gglobs.varnames)

        #self.setStyleSheet("color: black;") # all colors; black is too black

# font standard
        self.fontstd = QFont()
        gglobs.fontstd = self.fontstd
        self.fontstd.setFamily('Monospace')
        #self.fontstd.setFamily('Lucida')
        #self.fontstd.StyleHint(QFont.TypeWriter)
        #self.fontstd.StyleHint(QFont.Monospace)
        #self.fontstd.StyleHint(QFont.Courier)
        self.fontstd.setFixedPitch(True)
        self.fontstd.setPointSize(10)
        self.fontstd.setBold(False)
        #self.fontstd.setWeight(50)
        #self.fontstd.setStyleStrategy(QFont.PreferMatch)
        #self.fontstd.Weight(QFont.Normal)
        #self.fontstd.Weight(QFont.DemiBold)
        #self.fontstd.Weight(QFont.Bold)
        self.fontstd.Weight(QFont.Black)

# window
        self.iconGeigerLog    = QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png')))
        gglobs.iconGeigerLog    = QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png')))

        screen_available = QDesktopWidget().availableGeometry()
        #print "screen Geometry:", QDesktopWidget().screenGeometry() # total hardware screen
        #print "screen_available", screen_available, screen_available.x(), screen_available.y(), "width:", screen_available.width(), "height:", screen_available.height()

        sw = min(gglobs.window_width  -  2, screen_available.width() ) # Frame of 1 pixel left and right
        sh = min(gglobs.window_height - 29, screen_available.height()) # Frame top + bottom + Window bar of 29 pixel
        x  = max(screen_available.width() - sw, 0)                     # should be >0 anyway
        y  = screen_available.y()
        if "WINDOWS" in platform.platform().upper(): y += 33           # some correction needed at least on Virtual Win8.1
        self.setGeometry(x, y, sw, sh) # position window in upper right corner of screen
        if gglobs.devel:
            self.setWindowTitle("GeigerLog v{} PyQt{}".format(gglobs.__version__, gglobs.my_active_qt_version))
        else:
            self.setWindowTitle("GeigerLog v{} ".format(gglobs.__version__, gglobs.my_active_qt_version))
        self.setWindowIcon(self.iconGeigerLog)

#figure and its toolbar
        # a figure instance to plot on
        #self.figure = plt.figure(facecolor = "#F9F4C9", edgecolor='lightgray', linewidth = 0.0) # light yellow face
        self.figure, self.ax1 = plt.subplots(facecolor='#DFDEDD') # lighter gray
        plt.clf()  # must be done - clear figure or it will show an empty figure !!

        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        self.canvas = FigureCanvas(self.figure)
        self.canvas.mpl_connect('motion_notify_event', self.updatecursorposition) # where the cursor is
        self.canvas.mpl_connect('button_press_event' , self.onclick)              # send a mouse click

        # this is the figure Navigation widget; it takes the Canvas widget and a parent
        self.navtoolbar = NavigationToolbar(self.canvas, self)
        self.navtoolbar.setToolTip("Graph Toolbar")
        self.navtoolbar.setIconSize(QSize(32,32))

#menubar and statusbar and toolbar
        menubar = self.menuBar()
        menubar.setFocus()

        self.statusBar = QStatusBar()
        self.setStatusBar(self.statusBar)
        self.statusBar.setFont(QFont("Helvetica", 12))

        toolbar = self.addToolBar('Main')
        toolbar.setToolTip("Main Toolbar")
        toolbar.setOrientation(Qt.Horizontal) # is default; alt: Qt.Vertical
        toolbar.setIconSize(QSize(32,32))  # standard size is too small
        #print "toolbar.iconSize()", toolbar.iconSize()

#file menu
        PlotLogAction = QAction('Plot Log', self)
        addMenuTip(PlotLogAction, 'Plot the Log file')
        PlotLogAction.triggered.connect(lambda: self.plotGraph('Log'))

        PlotHisAction = QAction('Plot History', self)
        addMenuTip(PlotHisAction, 'Plot the History file')
        PlotHisAction.triggered.connect(lambda: self.plotGraph('His'))

        PlotScatterAction = QAction('Plot Scatter', self)
        addMenuTip(PlotScatterAction, 'Plot a Scatter plot from 2 variables')
        PlotScatterAction.triggered.connect(lambda: gtools.selectPlotVars())

        PrintPlotDataAction = QAction('Print Data as Shown in Plot', self)
        addMenuTip(PrintPlotDataAction, 'Print the DateTime and values of all variables as currently shown in Plot')
        PrintPlotDataAction.triggered.connect(lambda: gtools.printPlotData())

        PrintSuStAction =  QAction('Show Summary Statistics (SuSt)', self)
        addMenuTip(PrintSuStAction, "Shows Summary Statistics of all variables and data in the plot")
        PrintSuStAction.triggered.connect(lambda: gtools.printSuSt())

        PrintStatsAction =  QAction('Show Statistics', self)
        addMenuTip(PrintStatsAction, "Shows the Statistics of the selected variable plot")
        PrintStatsAction.triggered.connect(lambda: gtools.printStats())

        PlotPoissonAction =  QAction("Show Poisson Test", self)
        addMenuTip(PlotPoissonAction, "Shows a Poisson curve on a histogram of the data of the selected variable")
        PlotPoissonAction.triggered.connect(lambda: self.plotPoisson())

        PlotFFTAction =  QAction("Show FFT && Autocorrelation", self)
        addMenuTip(PlotFFTAction, "Shows the FFT Spectra & an Autocorrelation of the data of the selected variable")
        PlotFFTAction.triggered.connect(lambda: self.plotFFT())

        SaveNPAction = QAction("Save NotePad to File", self)
        addMenuTip(SaveNPAction, "Save Content of NotePad as text file <current filename>.notes")
        SaveNPAction.triggered.connect(self.saveNotepad)

        exitAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_exit.png'))), 'Exit', self)
        exitAction.setShortcut('Ctrl+Q')
        addMenuTip(exitAction, 'Exit the GeigerLog program')
        exitAction.triggered.connect(self.close)

        fileMenu = menubar.addMenu('&File')
        try: # ONLY for Qt5, ignore on qt4
            fileMenu.setToolTipsVisible(True)
        except:
            pass

        fileMenu.addAction(PlotLogAction)
        fileMenu.addAction(PlotHisAction)
        fileMenu.addAction(PlotScatterAction)
        fileMenu.addAction(PrintPlotDataAction)
        fileMenu.addAction(PrintSuStAction)
        fileMenu.addAction(PrintStatsAction)
        fileMenu.addAction(PlotPoissonAction)
        fileMenu.addAction(PlotFFTAction)
        fileMenu.addAction(SaveNPAction)
        fileMenu.addAction(exitAction)
        #fileMenu.triggered[QAction].connect(self.processtrigger)

        toolbar.addAction(exitAction)

# Device menu
        self.toggleDeviceConnectionAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_open.png'))), 'Connect / Disconnect Devices', self)
        addMenuTip(self.toggleDeviceConnectionAction, 'Toggle connection of GeigerLog with the devices')
        self.toggleDeviceConnectionAction.triggered.connect(self.toggleDeviceConnection)

        self.DeviceConnectAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_open.png'))), 'Connect Devices', self)
        self.DeviceConnectAction.setShortcut('Ctrl+C')
        addMenuTip(self.DeviceConnectAction, 'Connect the computer to the devices')
        self.DeviceConnectAction.triggered.connect(lambda : self.switchConnections("ON"))

        self.DeviceDisconnectAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_closed.png'))), 'Disconnect Devices', self, enabled = False)
        self.DeviceDisconnectAction.setShortcut('Ctrl+D')
        addMenuTip(self.DeviceDisconnectAction, 'Disconnect the computer from the devices')
        self.DeviceDisconnectAction.triggered.connect(lambda : self.switchConnections("OFF"))

        self.DeviceCalibAction = QAction('Set Calibrations for Geiger Tubes', self, enabled = True)
        addMenuTip(self.DeviceCalibAction, 'Set calibrations for all Geiger tubes temporarily')
        self.DeviceCalibAction.triggered.connect(self.setCalibrationFactors)

        self.DeviceUtilAction = QAction('Show Device Mappings', self, enabled = True)
        addMenuTip(self.DeviceUtilAction, 'Show the mapping of variables to the activated devices')
        self.DeviceUtilAction.triggered.connect(self.showDeviceMappings)

    # submenu GMC
        self.GMCInfoAction = QAction('Show Info', self, enabled=True)
        addMenuTip(self.GMCInfoAction, 'Show basic info on GMC device')
        self.GMCInfoAction.triggered.connect(lambda: self.printGMCDevInfo(extended = False))

        self.DeviceInfoAction = QAction('Show Extended Info', self, enabled=False)
        addMenuTip(self.DeviceInfoAction, 'Show extended info on GMC device')
        self.DeviceInfoAction.triggered.connect(lambda: self.printGMCDevInfo(extended = True))

        self.DeviceConfigAction = QAction('Show Configuration Memory', self, enabled=False)
        addMenuTip(self.DeviceConfigAction, 'Show the GMC device configuration memory as binary in human readable format')
        self.DeviceConfigAction.triggered.connect(self.printGMCDevConfig)

        self.DeviceONAction = QAction('Switch Power ON', self, enabled=False)
        addMenuTip(self.DeviceONAction, 'Switch the GMC device power to ON')
        self.DeviceONAction.triggered.connect(lambda: self.switchGMCPower("ON"))

        self.DeviceOFFAction = QAction('Switch Power OFF', self, enabled=False)
        addMenuTip(self.DeviceOFFAction, 'Switch the GMC device power to OFF')
        self.DeviceOFFAction.triggered.connect(lambda: self.switchGMCPower("OFF"))

        self.DeviceAlarmONAction = QAction('Switch Alarm ON', self, enabled=False)
        addMenuTip(self.DeviceAlarmONAction, 'Switch the GMC device alarm ON')
        self.DeviceAlarmONAction.triggered.connect(lambda: self.switchGMCDeviceAlarm("ON"))

        self.DeviceAlarmOFFAction = QAction('Switch Alarm OFF', self, enabled=False)
        addMenuTip(self.DeviceAlarmOFFAction, 'Switch the GMC device alarm OFF')
        self.DeviceAlarmOFFAction.triggered.connect(lambda: self.switchGMCDeviceAlarm("OFF"))

        self.DeviceSpeakerONAction = QAction('Switch Speaker ON', self, enabled=False)
        addMenuTip(self.DeviceSpeakerONAction, 'Switch the GMC device speaker ON')
        self.DeviceSpeakerONAction.triggered.connect(lambda: self.switchGMCDeviceSpeaker("ON"))

        self.DeviceSpeakerOFFAction = QAction('Switch Speaker OFF', self, enabled=False)
        addMenuTip(self.DeviceSpeakerOFFAction, 'Switch the GMC device speaker OFF')
        self.DeviceSpeakerOFFAction.triggered.connect(lambda: self.switchGMCDeviceSpeaker("OFF"))

        self.DeviceSavingStateAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, ''))), 'Set History Saving Mode', self, enabled=False)
        addMenuTip(self.DeviceSavingStateAction, 'Set History Saving Mode of GMC device to OFF, CPS, CPM, and CPM hourly average')
        self.DeviceSavingStateAction.triggered.connect(self.setGMCDeviceHistSaveMode)

        self.DeviceSetTimeAction = QAction('Set Date+Time', self, enabled=False)
        addMenuTip(self.DeviceSetTimeAction, 'Set the Date + Time of the GMC device to the computer time')
        self.DeviceSetTimeAction.triggered.connect(self.setGMCDeviceDateTime)

        self.DeviceREBOOTAction = QAction('Reboot', self, enabled=False)
        addMenuTip(self.DeviceREBOOTAction, 'Send REBOOT command to the GMC device')
        self.DeviceREBOOTAction.triggered.connect(self.doREBOOT)

        self.DeviceFACTORYRESETAction = QAction('FACTORYRESET', self, enabled=False)
        addMenuTip(self.DeviceFACTORYRESETAction, 'Send FACTORYRESET command to the GMC device')
        self.DeviceFACTORYRESETAction.triggered.connect(self.doFACTORYRESET)

    # submenu RadMon
        self.RMInfoAction = QAction('Show Info', self, enabled=True)
        addMenuTip(self.RMInfoAction, 'Show basic info on RadMon device')
        self.RMInfoAction.triggered.connect(lambda: self.printRMDevInfo(extended=False))

        self.RMInfoActionExt = QAction('Show Extended Info', self, enabled=False)
        addMenuTip(self.RMInfoActionExt, 'Show extended info on RadMon device')
        self.RMInfoActionExt.triggered.connect(lambda: self.printRMDevInfo(extended = True))

    # submenu AmbioMon
        self.AmbioInfoAction = QAction('Show Info', self, enabled=True)
        addMenuTip(self.AmbioInfoAction, 'Show basic info on AmbioMon device')
        self.AmbioInfoAction.triggered.connect(lambda: self.printAmbioDevInfo(extended=False))

        self.AmbioInfoActionExt = QAction('Show Extended Info', self, enabled=False)
        addMenuTip(self.AmbioInfoActionExt, 'Show extended info on AmbioMon device')
        self.AmbioInfoActionExt.triggered.connect(lambda: self.printAmbioDevInfo(extended = True))

        self.AmbioConfigAction = QAction('Configure', self, enabled=True)
        addMenuTip(self.AmbioConfigAction, 'Configure settings of the AmbioMon device')
        self.AmbioConfigAction.triggered.connect(gambiomon.configureAmbioMon)


    # submenu LabJack
        self.LJInfoAction = QAction('Show Info', self, enabled=True)
        addMenuTip(self.LJInfoAction, 'Show basic info on LabJack device')
        self.LJInfoAction.triggered.connect(lambda: self.printLJDevInfo(extended = False))

        self.LJInfoActionExt = QAction('Show Extended Info', self, enabled=False)
        addMenuTip(self.LJInfoActionExt, 'Show extended info on LabJack device')
        self.LJInfoActionExt.triggered.connect(lambda: self.printLJDevInfo(extended = True))

    # submenu AudioCounter
        self.AudioInfoAction = QAction('Show Info', self, enabled=True)
        addMenuTip(self.AudioInfoAction, 'Show basic info on AudioCounter device')
        self.AudioInfoAction.triggered.connect(lambda: self.printAudioDevInfo(extended = False))

        self.AudioInfoActionExt = QAction('Show Extended Info', self, enabled=False)
        addMenuTip(self.AudioInfoActionExt, 'Show extended info on AudioCounter device')
        self.AudioInfoActionExt.triggered.connect(lambda: self.printAudioDevInfo(extended = True))

        self.AudioSwitchAction = QAction("Toggle Pulse Sound", self, enabled=False)
        addMenuTip(self.AudioSwitchAction, 'Toggle the AudioCounter Device sound output ON or OFF')
        self.AudioSwitchAction.triggered.connect(gaudio.toggleAudioSound)

        self.AudioPlotAction = QAction("Plot Pulse", self, enabled=False)
        addMenuTip(self.AudioPlotAction, 'Plot the audio pulse recordings of the AudioCounter Device')
        self.AudioPlotAction.triggered.connect(lambda: gtools.reloaddata("Recording"))

    # submenu I2CSensors
        self.I2CInfoAction = QAction('Show Info', self, enabled=True)
        addMenuTip(self.I2CInfoAction, 'Show basic info on I2C device')
        self.I2CInfoAction.triggered.connect(lambda: self.printI2CDevInfo(extended = False))

        self.I2CInfoActionExt = QAction('Show Extended Info', self, enabled=False)
        addMenuTip(self.I2CInfoActionExt, 'Show extended info on I2C device')
        self.I2CInfoActionExt.triggered.connect(lambda: self.printI2CDevInfo(extended = True))

        self.I2CResetAction = QAction('Reset System', self, enabled=False)
        addMenuTip(self.I2CResetAction, 'Reset the I2C ELV dongle and sensors')
        self.I2CResetAction.triggered.connect(self.doI2CReset)

    # build the Device menu
        deviceMenu = menubar.addMenu('&Device')
        try: # ONLY for Qt5, ignore on qt4
            deviceMenu.setToolTipsVisible(True)
        except:
            pass

    # valid for all devices
        deviceMenu.addAction(self.DeviceConnectAction)
        deviceMenu.addAction(self.DeviceDisconnectAction)
        deviceMenu.addAction(self.DeviceCalibAction)
        deviceMenu.addAction(self.DeviceUtilAction)

    # valid for GMC only
        if gglobs.GMCActivation  :
            deviceSubMenuGMC = deviceMenu.addMenu("GMC Series")
            try: # ONLY for Qt5, ignore on qt4
                deviceSubMenuGMC.setToolTipsVisible(True)
            except:
                pass
            deviceSubMenuGMC.addAction(self.GMCInfoAction)
            deviceSubMenuGMC.addAction(self.DeviceInfoAction)
            deviceSubMenuGMC.addAction(self.DeviceConfigAction)
            deviceSubMenuGMC.addAction(self.DeviceONAction)
            deviceSubMenuGMC.addAction(self.DeviceOFFAction)
            deviceSubMenuGMC.addAction(self.DeviceAlarmONAction)
            deviceSubMenuGMC.addAction(self.DeviceAlarmOFFAction)
            deviceSubMenuGMC.addAction(self.DeviceSpeakerONAction)
            deviceSubMenuGMC.addAction(self.DeviceSpeakerOFFAction)
            deviceSubMenuGMC.addAction(self.DeviceSavingStateAction)
            deviceSubMenuGMC.addAction(self.DeviceSetTimeAction)
            deviceSubMenuGMC.addAction(self.DeviceREBOOTAction)
            deviceSubMenuGMC.addAction(self.DeviceFACTORYRESETAction)
            #deviceMenu.triggered[QAction].connect(self.processtrigger)

    # valid for AudioCounter only
        if gglobs.AudioActivation :
            deviceSubMenuAudio  = deviceMenu.addMenu("AudioCounter Series")
            try: # ONLY for Qt5, ignore on qt4
                deviceSubMenuAudio.setToolTipsVisible(True)
            except:
                pass
            deviceSubMenuAudio.addAction(self.AudioInfoAction)
            deviceSubMenuAudio.addAction(self.AudioInfoActionExt)
            deviceSubMenuAudio.addAction(self.AudioSwitchAction)
            #deviceSubMenuAudio.addAction(self.AudioPulseDirAction)
            deviceSubMenuAudio.addAction(self.AudioPlotAction)

    # valid for I2CSensors only
        if gglobs.I2CActivation :
            deviceSubMenuI2C  = deviceMenu.addMenu("I2CSensors Series")
            try: # ONLY for Qt5, ignore on qt4
                deviceSubMenuI2C.setToolTipsVisible(True)
            except:
                pass
            deviceSubMenuI2C.addAction(self.I2CInfoAction)
            deviceSubMenuI2C.addAction(self.I2CInfoActionExt)
            deviceSubMenuI2C.addAction(self.I2CResetAction)

    # valid for RadMon only
        if gglobs.RMActivation  :
            deviceSubMenuRM  = deviceMenu.addMenu("RadMon Series")
            try: # ONLY for Qt5, ignore on qt4
                deviceSubMenuRM.setToolTipsVisible(True)
            except:
                pass
            deviceSubMenuRM.addAction(self.RMInfoAction)
            deviceSubMenuRM.addAction(self.RMInfoActionExt)

    # valid for AmbioMon only
        if gglobs.AmbioActivation  :
            deviceSubMenuAmbio  = deviceMenu.addMenu("AmbioMon Series")
            try: # ONLY for Qt5, ignore on qt4
                deviceSubMenuAmbio.setToolTipsVisible(True)
            except:
                pass
            deviceSubMenuAmbio.addAction(self.AmbioInfoAction)
            deviceSubMenuAmbio.addAction(self.AmbioInfoActionExt)
            deviceSubMenuAmbio.addAction(self.AmbioConfigAction)

    # valid for LabJack only
        if gglobs.LJActivation  :
            deviceSubMenuLJ  = deviceMenu.addMenu("LabJack Series")
            try: # ONLY for Qt5, ignore on qt4
                deviceSubMenuLJ.setToolTipsVisible(True)
            except:
                pass
            deviceSubMenuLJ.addAction(self.LJInfoAction)
            deviceSubMenuLJ.addAction(self.LJInfoActionExt)


    # widgets for device in toolbar
        devBtnSize = 60
        # !!! MUST NOT have a colon ':' after QPushButton !!!
        self.dbtnStyleSheetON    = "QPushButton {margin-right:5px; background-color: #12cc3d; border-radius: 2px; border:1px solid silver; color: black; font-size:14px; font-weight:bold}"
        self.dbtnStyleSheetOFF   = "QPushButton {margin-right:5px;  }"
        self.dbtnStyleSheetError = "QPushButton {margin-right:5px; background-color: #ff3333; border-radius: 2px; border:1px solid silver; color: black; font-size:14px; font-weight:bold}"

        self.dbtnGMCPower = QPushButton()
        self.dbtnGMCPower.setIcon(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_power-round_off.png'))))
        self.dbtnGMCPower.setFixedSize(32,33)
        self.dbtnGMCPower.setEnabled(False)
        self.dbtnGMCPower.setStyleSheet("QPushButton {margin-right:1px; border:0px; }")
        self.dbtnGMCPower.setIconSize(QSize(31,31))
        self.dbtnGMCPower.setToolTip ('Toggle GMC Device Power ON / OFF')
        self.dbtnGMCPower.setAutoFillBackground(True) # This is important!! Why???
        self.dbtnGMCPower.clicked.connect(lambda: self.toggleGMCPower())

        self.connectTextGMC = 'GMC'
        self.dbtnGMC = QPushButton(self.connectTextGMC)
        self.dbtnGMC.setFixedSize(devBtnSize,32)
        self.dbtnGMC.setToolTip("GMC Device - Turns green once a connection is made - click for info")
        self.dbtnGMC.setStyleSheet(self.dbtnStyleSheetOFF)
        self.dbtnGMC.setAutoFillBackground(True) # This is important!! Why???
        self.dbtnGMC.clicked.connect(lambda: self.printGMCDevInfo(extended=False))

        self.connectTextRM = 'RadM'
        self.dbtnRM =  QPushButton(self.connectTextRM)
        self.dbtnRM.setFixedSize(devBtnSize,32)
        self.dbtnRM.setToolTip("RadMon Device - Turns green once a connection is made - click for info")
        self.dbtnRM.setStyleSheet(self.dbtnStyleSheetOFF)
        self.dbtnRM.setAutoFillBackground(True) # 'This is important!!'  Why???
        self.dbtnRM.clicked.connect(lambda: self.printRMDevInfo())

        self.connectTextAmbio = 'Ambio'
        self.dbtnAmbio =  QPushButton(self.connectTextAmbio)
        self.dbtnAmbio.setFixedSize(devBtnSize, 32)
        self.dbtnAmbio.setToolTip("AmbioMon Device - Turns green once a connection is made - click for info")
        self.dbtnAmbio.setStyleSheet(self.dbtnStyleSheetOFF)
        self.dbtnAmbio.setAutoFillBackground(True) # 'This is important!!'  Why???
        self.dbtnAmbio.clicked.connect(lambda: self.printAmbioDevInfo())

        self.connectTextLJ = 'LabJ'
        self.dbtnLJ =  QPushButton(self.connectTextLJ)
        self.dbtnLJ.setFixedSize(devBtnSize, 32)
        self.dbtnLJ.setToolTip("LabJack Device - Turns green once a connection is made - click for info")
        self.dbtnLJ.setStyleSheet(self.dbtnStyleSheetOFF)
        self.dbtnLJ.setAutoFillBackground(True) # 'This is important!!'  Why???
        self.dbtnLJ.clicked.connect(lambda: self.printLJDevInfo())

        self.connectTextAudio = 'Audio'
        self.dbtnAudio =  QPushButton(self.connectTextAudio)
        self.dbtnAudio.setFixedSize(devBtnSize, 32)
        self.dbtnAudio.setToolTip("AudioCounter Device - Turns green once a connection is made - click for info")
        self.dbtnAudio.setStyleSheet(self.dbtnStyleSheetOFF)
        self.dbtnAudio.setAutoFillBackground(True) # 'This is important!!'  Why???
        self.dbtnAudio.clicked.connect(lambda: self.printAudioDevInfo())

        self.connectTextI2C = 'I2C'
        self.dbtnI2C =  QPushButton(self.connectTextI2C)
        self.dbtnI2C.setFixedSize(devBtnSize, 32)
        self.dbtnI2C.setToolTip("I2C Device - Turns green once a connection is made - click for info")
        self.dbtnI2C.setStyleSheet(self.dbtnStyleSheetOFF)
        self.dbtnI2C.setAutoFillBackground(True) # 'This is important!!'  Why???
        self.dbtnI2C.clicked.connect(lambda: self.printI2CDevInfo())

    # toolbar Devices
        toolbar = self.addToolBar('Devices')
        toolbar.setToolTip("Devices Toolbar")
        toolbar.setIconSize(QSize(32,32))    # standard size is too small

        toolbar.addAction(self.toggleDeviceConnectionAction) # Connect icon
        toolbar.addWidget(QLabel("   "))            # spacer
        #toolbar.addAction(self.DevicePowerToggle)   # GMC power icon

        if gglobs.GMCActivation  :
            toolbar.addWidget(self.dbtnGMCPower)        # GMC power icon
            toolbar.addWidget(self.dbtnGMC)             # GMC device display

        if gglobs.AudioActivation  :
            toolbar.addWidget(self.dbtnAudio)           # AudioCounter device display

        if gglobs.I2CActivation  :
            toolbar.addWidget(self.dbtnI2C)           # I2C device display

        if gglobs.RMActivation  :
            toolbar.addWidget(self.dbtnRM)              # RadMon device display

        if gglobs.AmbioActivation  :
            toolbar.addWidget(self.dbtnAmbio)           # AmbioMon device display

        if gglobs.LJActivation  :
            toolbar.addWidget(self.dbtnLJ)              # LabJack device display


#Log Menu
        self.logLoadFileAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_log_get.png'))), 'Get Log or Create New One', self)
        self.logLoadFileAction.setShortcut('Ctrl+F')
        addMenuTip(self.logLoadFileAction, 'Load database for logging or create new one, and plot')
        self.logLoadFileAction.triggered.connect(lambda: self.getLogFile(source="Database"))

        self.logLoadCSVAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_log_get.png'))), 'Get Log from CSV File', self)
        addMenuTip(self.logLoadCSVAction, 'Load existing *.log or other CSV file, convert to database, and plot')
        self.logLoadCSVAction.triggered.connect(lambda: self.getLogFile(source="CSV File"))

        self.startloggingAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_log_start.png'))), 'Start Logging', self, enabled=False)
        self.startloggingAction.setShortcut('Ctrl+L')
        addMenuTip(self.startloggingAction, 'Start logging from devices')
        self.startloggingAction.triggered.connect(self.startLogging)

        self.stoploggingAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_log_stop.png'))), 'Stop Logging', self, enabled=False)
        self.stoploggingAction.setShortcut('Ctrl+S')
        addMenuTip(self.stoploggingAction, 'Stop logging from devices')
        self.stoploggingAction.triggered.connect(self.stopLogging)

        self.addCommentAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, ''))), 'Add Comment to Log', self, enabled=False)
        self.addCommentAction.setShortcut('Ctrl+A')
        addMenuTip(self.addCommentAction, 'Add a comment to the current log')
        self.addCommentAction.triggered.connect(lambda: self.addComment("Log"))

        self.showLogDataAction = QAction('Show Log Data', self)
        addMenuTip(self.showLogDataAction, 'Show all records from current log')
        self.showLogDataAction.triggered.connect(lambda: self.showData("Log", full= True))

        self.showLogTagsAction = QAction('Show Log Tags/Comments', self)
        addMenuTip(self.showLogTagsAction, 'Show only records from current log containing tags or comments')
        self.showLogTagsAction.triggered.connect(self.showLogTags)

        self.showLogExcerptAction = QAction('Show Log Data Excerpt', self)
        addMenuTip(self.showLogExcerptAction, 'Show first and last few records of current log')
        self.showLogExcerptAction.triggered.connect(lambda: self.showData("Log", full=False))

        self.quickLogAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_quick_log.png'))), 'Quick Log', self, enabled=False)
        self.quickLogAction.setShortcut('Ctrl+K')
        addMenuTip(self.quickLogAction, 'One-click log. Saves always into database default.logdb; will be overwritten on next Quick Log click')
        self.quickLogAction.triggered.connect(self.quickLog)

        self.logSnapAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_log_snap.png'))), 'Snap a new log record', self, enabled=False)
        addMenuTip(self.logSnapAction, 'Get a new log record immediately')
        self.logSnapAction.triggered.connect(self.snapLogValue)

        self.setLogTimingAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_log_options.png'))), 'Set Log Timings', self, enabled=False)
        addMenuTip(self.setLogTimingAction, 'Set Log Timings')
        self.setLogTimingAction.triggered.connect(self.setLogTimings)

        loggingMenu = menubar.addMenu('&Log')
        try: # ONLY for Qt5, ignore on qt4
            loggingMenu.setToolTipsVisible(True)
        except:
            pass
        loggingMenu.addAction(self.logLoadFileAction)
        loggingMenu.addAction(self.logLoadCSVAction)
        loggingMenu.addAction(self.setLogTimingAction)
        loggingMenu.addAction(self.startloggingAction)
        loggingMenu.addAction(self.stoploggingAction)
        loggingMenu.addAction(self.quickLogAction)
        loggingMenu.addAction(self.addCommentAction)
        loggingMenu.addAction(self.showLogDataAction)
        loggingMenu.addAction(self.showLogExcerptAction)
        loggingMenu.addAction(self.showLogTagsAction)
        #loggingMenu.triggered[QAction].connect(self.processtrigger)

        toolbar = self.addToolBar('Log')
        toolbar.setToolTip("Log Toolbar")
        toolbar.setIconSize(QSize(32,32))  # standard size is too small
        toolbar.addAction(self.logLoadFileAction)
        #toolbar.addAction(self.logLoadCSVAction)
        toolbar.addAction(self.startloggingAction)
        toolbar.addAction(self.quickLogAction)
        toolbar.addAction(self.logSnapAction)
        toolbar.addAction(self.stoploggingAction)


#History Menu
        self.histDeviceAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_hist_device_active.png'))), 'Get History from Device ', self, enabled=False)
        self.histDeviceAction.setShortcut('Ctrl+H')
        addMenuTip(self.histDeviceAction, 'Load history data from device, create database, and plot')
        self.histDeviceAction.triggered.connect(lambda: self.getHistory("Device"))

        self.histLoadDBAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_hist_DB_active.svg.png'))), 'Get History from Database', self)
        addMenuTip(self.histLoadDBAction, 'Load history data from database and plot')
        self.histLoadDBAction.triggered.connect(lambda: self.getHistory("Database"))

        self.histLoadBinAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_hist_bin_active.png'))), 'Get History from Binary File', self)
        addMenuTip(self.histLoadBinAction, 'Load history data from binary file and plot')
        self.histLoadBinAction.triggered.connect(lambda: self.getHistory("Binary File"))

        self.histLoadHisAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_hist_his_active.png'))), 'Get History from CSV File', self)
        addMenuTip(self.histLoadHisAction, 'Load existing *.his or other CSV file, convert to database file, and plot')
        self.histLoadHisAction.triggered.connect(lambda: self.getHistory("Parsed File"))

    # bin data
        self.showHistBinDataAction = QAction('Show History Binary Data', self)
        addMenuTip(self.showHistBinDataAction, 'Show history binary data in human readable form')
        self.showHistBinDataAction.triggered.connect(lambda: self.showData("HisBin"))

        self.showHistBinDataExcerptAction = QAction('Show History Binary Data Excerpt', self)
        addMenuTip(self.showHistBinDataExcerptAction, 'Show first and last few lines of history binary data in human readable form')
        self.showHistBinDataExcerptAction.triggered.connect(lambda: self.showData("HisBin", full=False))

        self.showHistBinDataDetailAction = QAction('Show History Binary Data Bytecount', self)
        addMenuTip(self.showHistBinDataDetailAction, 'Show counts of bytes in history binary data')
        self.showHistBinDataDetailAction.triggered.connect(ghist.printHistDetails)

        self.showHistBinDataSaveAction = QAction('Save History Binary Data to File', self)
        addMenuTip(self.showHistBinDataSaveAction, 'Save the history binary data as a *.bin file')
        self.showHistBinDataSaveAction.triggered.connect(ghist.saveHistBinaryData)

    # tags/comments
        self.showHistHisTagsAction = QAction('Show History Tags/Comments', self)
        addMenuTip(self.showHistHisTagsAction, 'Show only records from history containing tags or comments')
        self.showHistHisTagsAction.triggered.connect(self.showHisTags)

    # his data
        self.showHistHisDataAction = QAction('Show History Data', self)
        addMenuTip(self.showHistHisDataAction, 'Show history data as parsed from binary data')
        self.showHistHisDataAction.triggered.connect(lambda: self.showData("His"))

        self.showHistHisDataExcerptAction = QAction('Show History Data Excerpt', self)
        addMenuTip(self.showHistHisDataExcerptAction, 'Show first and last few records of history data parsed from binary data')
        self.showHistHisDataExcerptAction.triggered.connect(lambda: self.showData("His", full=False))


        self.addHisCommentAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, ''))), 'Add Comment to History', self, enabled=False)
        addMenuTip(self.addHisCommentAction, 'Add a comment to the current history')
        self.addHisCommentAction.triggered.connect(lambda: self.addComment("His"))

        historyParseAction = QAction("Show History Data with Parse Comments", self)
        addMenuTip(historyParseAction, "Show History Data including extended Parse Comments")
        historyParseAction.triggered.connect(gsql.createParseFromDB)

        historyFFAction = QAction("Show History Binary Data as FF Map", self)
        addMenuTip(historyFFAction, "Show History Binary Data as a map highlighting the locations of bytes with FF value")
        historyFFAction.triggered.connect(gsql.createFFmapFromDB)

        historyMenu = menubar.addMenu('Histor&y')
        try: # ONLY for Qt5, ignore on qt4
            historyMenu.setToolTipsVisible(True)
        except:
            pass
        historyMenu.addAction(self.histDeviceAction)
        historyMenu.addAction(self.histLoadDBAction)
        historyMenu.addAction(self.histLoadBinAction)
        historyMenu.addAction(self.histLoadHisAction)
        historyMenu.addAction(self.addHisCommentAction)
        historyMenu.addAction(self.showHistHisDataAction)
        historyMenu.addAction(self.showHistHisDataExcerptAction)
        historyMenu.addAction(self.showHistHisTagsAction)

        historySubMenu = historyMenu.addMenu("History Details")
        try: # ONLY for Qt5, ignore on qt4
            historySubMenu.setToolTipsVisible(True)
        except:
            pass
        historySubMenu.addAction(historyParseAction)
        historySubMenu.addAction(self.showHistBinDataDetailAction) # bytecount
        historySubMenu.addAction(self.showHistBinDataAction)
        historySubMenu.addAction(self.showHistBinDataExcerptAction)
        historySubMenu.addAction(historyFFAction)
        historySubMenu.addAction(self.showHistBinDataSaveAction)
        #historyMenu.triggered[QAction].connect(self.processtrigger)

        toolbar     = self.addToolBar('History')
        toolbar.setToolTip("History Toolbar")
        toolbar.setIconSize(QSize(32,32))  # standard size is too small
        toolbar.addAction(self.histDeviceAction)
        toolbar.addAction(self.histLoadDBAction)
        #toolbar.addAction(self.histLoadBinAction)
        #toolbar.addAction(self.histLoadHisAction)

# Web menu
        # menu entry and toolbar button for Map access
        self.WebAction = QAction(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_map.png'))), 'Update Radiation World Maps', self, enabled=False)
        addMenuTip(self.WebAction, 'Update Radiation World Maps using average of data shown in the plot')
        self.WebAction.triggered.connect(gtools.pushToWeb)

        webMenu = menubar.addMenu('&Web')
        try: # ONLY for Qt5, ignore on qt4
            webMenu.setToolTipsVisible(True)
        except:
            pass
        webMenu.addAction(self.WebAction)

        toolbar = self.addToolBar('Web')
        toolbar.setToolTip("Web Toolbar")
        toolbar.setIconSize(QSize(32,32))  # standard size is too small
        toolbar.addAction(self.WebAction)

#Help Menu
        self.helpQickStartAction = QAction('Quickstart', self)
        addMenuTip(self.helpQickStartAction, 'Guidance for an easy start')
        self.helpQickStartAction.triggered.connect(self.helpQuickStart)

        self.helpManualUrlAction = QAction('GeigerLog Manual', self)
        addMenuTip(self.helpManualUrlAction, 'Open the GeigerLog Manual (locally if available, or online)')
        self.helpManualUrlAction.triggered.connect(self.openUrl)

        self.helpFirmwareBugAction = QAction("Devices' Firmware Bugs", self)
        addMenuTip(self.helpFirmwareBugAction, 'Info on Firmware Bugs of the Devices and Workarounds')
        self.helpFirmwareBugAction.triggered.connect(self.helpFirmwareBugs)

        self.helpWorldMapsAction = QAction('Radiation World Maps', self)
        addMenuTip(self.helpWorldMapsAction, 'Contributing to the Radiation World Maps')
        self.helpWorldMapsAction.triggered.connect(self.helpWorldMaps)

        self.helpOccupationalRadiationAction = QAction('Occupational Radiation Limits', self)
        addMenuTip(self.helpOccupationalRadiationAction, 'Occupational Radiation Limits in USA and Germany')
        self.helpOccupationalRadiationAction.triggered.connect(self.helpOccupationalRadiation)

        self.DeviceSetUSBportAction = QAction('Show && Select USB Port and Baudrate', self)
        addMenuTip(self.DeviceSetUSBportAction, 'Select the USB-to-Serial Port and  Baudrate')
        self.DeviceSetUSBportAction.triggered.connect(self.helpSetPort)

        self.DeviceUSBDiscoveryAction = QAction('Autodiscover Connected USB Port', self)
        addMenuTip(self.DeviceUSBDiscoveryAction, 'Find the USB Port connected to a GMC Geiger counter and the Baudrate automatically')
        self.DeviceUSBDiscoveryAction.triggered.connect(self.USBautoDiscovery)

        self.helpAboutAction = QAction('About GeigerLog', self)
        addMenuTip(self.helpAboutAction, 'About the GeigerLog program')
        self.helpAboutAction.triggered.connect(self.helpAbout)

        #self.helpAboutQTAction = QAction('About Qt', self)
        #self.helpAboutQTAction.setStatusTip('About the Qt toolkit used by GeigerLog')
        #self.helpAboutQTAction.setToolTip('About the Qt toolkit used by GeigerLog')
        #self.helpAboutQTAction.triggered.connect(QApplication.aboutQt)

        # next entries no longer in help menu; visible on devel menu
        self.helpOptionsAction = QAction('Options', self)
        addMenuTip(self.helpOptionsAction, 'Show command line options')
        self.helpOptionsAction.triggered.connect(self.helpOptions)

        self.changeOptionsAction = QAction('Change Options', self)
        addMenuTip(self.changeOptionsAction, 'Allows to change some command line options during running')
        self.changeOptionsAction.triggered.connect(self.changeOptions)

        self.helpSystemInfoAction = QAction('System Info', self)
        addMenuTip(self.helpSystemInfoAction, 'Show Details on the Current Program Settings and Environment')
        self.helpSystemInfoAction.triggered.connect(self.showSystemInfo)

        #self.DeviceListUSBAction = QAction('List USB Ports', self)
        #self.DeviceListUSBAction.setStatusTip('List the USB-to-Serial Ports on Your System')
        #self.DeviceListUSBAction.triggered.connect(self.helpShowUSBPorts)

        helpMenu = menubar.addMenu('&Help')
        try: # ONLY for Qt5, ignore on qt4
            helpMenu.setToolTipsVisible(True)
        except:
            pass
        helpMenu.addAction(self.helpQickStartAction)
        helpMenu.addAction(self.helpManualUrlAction)
        helpMenu.addAction(self.helpFirmwareBugAction)
        helpMenu.addAction(self.helpWorldMapsAction)
        helpMenu.addAction(self.helpOccupationalRadiationAction)
        helpMenu.addSeparator()
        #    helpMenu.addAction(self.helpOptionsAction)
        #    helpMenu.addAction(self.changeOptionsAction)
        #    helpMenu.addAction(self.helpSystemInfoAction)
        #    helpMenu.addAction(self.DeviceListUSBAction)
        helpMenu.addAction(self.DeviceSetUSBportAction)
        helpMenu.addAction(self.DeviceUSBDiscoveryAction)
        helpMenu.addSeparator()
        #helpMenu.addAction(self.helpAboutQTAction)
        helpMenu.addAction(self.helpAboutAction)
        #helpMenu.triggered[QAction].connect(self.processtrigger)

        if gglobs.devel:
            develMenu = menubar.addMenu('Devel')
            try: # ONLY for Qt5, ignore on qt4
                develMenu.setToolTipsVisible(True)
            except:
                pass

            develIotaAction = QAction("printVarsStatus", self)
            develIotaAction.triggered.connect(lambda: printVarsStatus(origin = "btnEpsilon"))
            develMenu.addAction(develIotaAction)

            develAlphaAction = QAction("Eval_plotFFT", self)
            develAlphaAction.triggered.connect(self.xxxEval_plotFFT)
            develMenu.addAction(develAlphaAction)

            develBetaAction = QAction("gsynth.createSyntheticLog", self)
            develBetaAction.triggered.connect(gsynth.createSyntheticLog)
            develMenu.addAction(develBetaAction)

            develGammaAction = QAction("popup", self)
            develGammaAction.triggered.connect(self.popup)
            develMenu.addAction(develGammaAction)

            develDeltaAction = QAction("gtools.pushToWeb", self)
            develDeltaAction.triggered.connect(gtools.pushToWeb)
            develMenu.addAction(develDeltaAction)

            # Configure AmbioMon++
            #develEpsilonAction = QAction("configureRadMon", self)
            #develEpsilonAction.triggered.connect(self.configureRadMon)
            #develMenu.addAction(develEpsilonAction)

            develEtaAction = QAction("helpOptions", self)
            develEtaAction.triggered.connect(self.helpOptions)
            develMenu.addAction(develEtaAction)

            develZetaAction = QAction("changeOptions", self)
            develZetaAction.triggered.connect(self.changeOptions)
            develMenu.addAction(develZetaAction)

            develThetaAction = QAction("showSystemInfo", self)
            develThetaAction.triggered.connect(self.showSystemInfo)
            develMenu.addAction(develThetaAction)

            #devel1Action = QAction("printPlotData", self)
            #devel1Action.triggered.connect(lambda: gtools.printPlotData())
            #develMenu.addAction(devel1Action)


# add navigation toolbar as last toolbar
        self.addToolBar(self.navtoolbar)

# DataOptions
    # labels and entry fields
        dltitle  = QLabel("Data")
        dltitle.setFont(QFont("system", weight=QFont.Bold))

        dlcf     = QLabel("Database Files")
        dlcf.setAlignment(Qt.AlignCenter)

        dlcy     = QLabel("Timings")
        dlcy.setAlignment(Qt.AlignCenter)
        dlcy.setFixedWidth(90)

        dlnotepad   = QLabel("NotePad")
        dlnotepad.setAlignment(Qt.AlignCenter)
        dlnotepad.setFixedWidth(90)

        dllog=QLabel("Log:")

        self.dcfLog=QLineEdit()
        self.dcfLog.setReadOnly(True)
        self.dcfLog.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")
        self.dcfLog.setToolTip('The full path of the Log-File if any is loaded')

        self.dcycl  = QPushButton()
        self.dcycl.setToolTip('Current setting of logging cycle in seconds')
        self.dcycl.clicked.connect(self.setLogTimings)
        self.dcycl.setFixedWidth(90)

        dlhist=QLabel("History:")
        self.dcfHis=QLineEdit()
        self.dcfHis.setReadOnly(True)
        self.dcfHis.setStyleSheet("QLineEdit { background-color : #DFDEDD; color : rgb(80,80,80); }")
        self.dcfHis.setToolTip('The full path of the History-File if any is loaded')

        dbtnPlotLog =  QPushButton('Plot')
        dbtnPlotLog.clicked.connect(lambda: self.plotGraph('Log'))
        dbtnPlotLog.setMaximumWidth(36)
        dbtnPlotLog.setToolTip("Plot the Log File")

        dbtnPlotHis =  QPushButton('Plot')
        dbtnPlotHis.clicked.connect(lambda: self.plotGraph('His'))
        dbtnPlotHis.setMaximumWidth(36)
        dbtnPlotHis.setToolTip("Plot the History File")

    # button: clear notepad
        clearbutton    =  QPushButton('Clear')
        clearbutton.clicked.connect(self.clearNotePad)
        clearbutton.setToolTip('Delete all content of the NotePad')
        clearbutton.setFixedWidth(90)

    # button: print data excerpt to notepad
        self.printbutton    =  QPushButton('DataExcerpt')
        self.printbutton.clicked.connect(lambda: self.showData(full=False))
        self.printbutton.setToolTip('Print Log or His Data to the NotePad')
        self.printbutton.setFixedWidth(90)

    # button: select history saving mode
        self.btnHistSaveMode =  QPushButton('Mode: ---')
        self.btnHistSaveMode.clicked.connect(self.setGMCDeviceHistSaveMode)
        self.btnHistSaveMode.setFixedWidth(90)
        self.btnHistSaveMode.setEnabled(False)
        self.btnHistSaveMode.setToolTip('Select the History Saving Mode')

    # separator lines - vertical
        vlinedB0 = QFrame()
        vlinedB0.setFrameShape(QFrame.VLine)

    # layout the Data Options
        dataOptions=QGridLayout()
        #dataOptions.setContentsMargins(*self.ContentsMargins)

        row = 0
        dataOptions.addWidget(dltitle,                 row, 0)
        # 1 is empty
        dataOptions.addWidget(dlcf,                    row, 2)
        dataOptions.addWidget(dlcy,                    row, 3)
        dataOptions.addWidget(vlinedB0,                row, 4, 4, 1)
        dataOptions.addWidget(dlnotepad,               row, 5)

        row = 1
        dataOptions.addWidget(dllog,                   row, 0)
        dataOptions.addWidget(dbtnPlotLog,             row, 1)
        dataOptions.addWidget(self.dcfLog,             row, 2)
        dataOptions.addWidget(self.dcycl,              row, 3)
        # 4 is empty (vline)
        dataOptions.addWidget(self.printbutton,        row, 5)

        row = 2
        dataOptions.addWidget(dlhist,                  row, 0)
        dataOptions.addWidget(dbtnPlotHis,             row, 1)
        dataOptions.addWidget(self.dcfHis,             row, 2)
        dataOptions.addWidget(self.btnHistSaveMode,    row, 3)
        # 4 is empty (vline)
        dataOptions.addWidget(clearbutton,             row, 5)

        # group Data Options into Groupbox
        #self.frame=QFrame()
        #self.frame.setFrameStyle(QFrame.Panel | QFrame.Raised);
        #self.frame.setStyleSheet("border: 1pt pink;")
        #dataOptionsGroup = QGroupBox(self.frame)
        dataOptionsGroup = QGroupBox()
        dataOptionsGroup.setLayout(dataOptions)
        #dataOptionsGroup.setStyleSheet("background-color:lightpink;")
        #dataOptionsGroup.setContentsMargins(0,0,0,0)


# GraphOptions
        ltitle  = QLabel("Graph")
        ltitle.setFont(QFont("system", weight=QFont.Bold))

        lmin    = QLabel("Min")
        lmin.setAlignment(Qt.AlignCenter)

        lmax    = QLabel("Max")
        lmax.setAlignment(Qt.AlignCenter)

        btnSetCalib =  QPushButton('Set Calibs')
        btnSetCalib.clicked.connect(self.setCalibrationFactors)
        btnSetCalib.setFixedWidth(70)
        btnSetCalib.setToolTip("Set Calibrations for all tubes temporarily")


        lunit   = QLabel("Units")
        lunit.setAlignment(Qt.AlignCenter)

        ewidth = 120
        lcounts = QLabel("Counter")
        ly2     = QLabel("Ambient")
        ltime   = QLabel("Time")

        self.ymin = QLineEdit()
        self.ymin.setToolTip('Minimum setting for Counter axis')

        self.ymax = QLineEdit()
        self.ymax.setToolTip('Maximum setting for Counter axis')

        self.yunit = QComboBox()
        self.yunit.addItems(["CPM", "µSv/h"])
        self.yunit.setMaximumWidth(70)
        self.yunit.setToolTip('Select the Count Unit for the plot')
        self.yunit.currentIndexChanged.connect(self.changedGraphCountUnit)

        self.y2min=QLineEdit()
        self.y2min.setToolTip('Minimum setting for Ambient axis')

        self.y2max=QLineEdit()
        self.y2max.setToolTip('Maximum setting for Ambient axis')

        self.y2unit = QComboBox()
        self.y2unit.addItems(["°C", "°F"])
        self.y2unit.setMaximumWidth(70)
        self.y2unit.setToolTip('Select the Temperature Unit')
        self.y2unit.currentIndexChanged.connect(self.changedGraphTemperatureUnit)

        self.xmin=QLineEdit()
        self.xmin.setToolTip('The minimum (left) limit of the time to be shown. Enter manuallly or by left-mouse-click on the graph')

        self.xmax=QLineEdit()
        self.xmax.setToolTip('The maximum (right) limit of the time to be shown. Enter manuallly or by right-mouse-click on the graph')

        self.xunit = QComboBox()
        self.xunit.addItems(["Time", "auto", "second", "minute", "hour", "day"])
        self.xunit.setMaximumWidth(70)
        self.xunit.currentIndexChanged.connect(self.changedGraphTimeUnit)
        self.xunit.setToolTip('The time axis to be shown as Time-of-Day (Time) or time since first record in seconds, minutes, hours, days; auto selects most appropriate period')

        # The drop-down selector for selected variable
        self.select = QComboBox()
        self.select.setToolTip('The data to be selected for analysis')
        self.select.setEnabled(False)
        self.select.currentIndexChanged.connect(self.changedGraphSelectedVariable)
        self.select.setMaxVisibleItems(12)
        for vname in gglobs.varnames:
            self.select.addItems([gglobs.vardict[vname][0]])

        # The checkboxes to select the displayed variables
        self.varDisplayCheckbox = {}
        for vname in gglobs.varnames:
            vshort = gglobs.vardict[vname][1]
            vlong  = gglobs.vardict[vname][0]

            self.varDisplayCheckbox[vname] = QCheckBox    (vshort)
            self.varDisplayCheckbox[vname].setToolTip     (vlong)
            self.varDisplayCheckbox[vname].setChecked     (False)
            self.varDisplayCheckbox[vname].setEnabled     (False)
            self.varDisplayCheckbox[vname].setTristate    (False)

            # "double lambda needed for closure" WTF???
            self.varDisplayCheckbox[vname].stateChanged.connect((lambda x: lambda: self.changedGraphDisplayCheckboxes(x))(vname))

        chk_width = 20

        self.avgbox = QCheckBox("Avg")
        self.avgbox.setLayoutDirection(Qt.RightToLeft)
        self.avgbox.setChecked(gglobs.avgChecked)
        self.avgbox.setTristate (False)
        self.avgbox.setToolTip("If checked, Average and ±95% lines will be shown")
        self.avgbox.stateChanged.connect(self.changedGraphOptionsAvg)

        self.mavbox = QCheckBox("MvAvg")
        self.mavbox.setLayoutDirection(Qt.RightToLeft)
        self.mavbox.setChecked(gglobs.mavChecked)
        self.mavbox.setTristate (False)
        self.mavbox.setToolTip('If checked a Moving Average line will be drawn')
        self.mavbox.stateChanged.connect(self.changedGraphOptionsMav)

        self.mav=QLineEdit()
        self.mav.setMinimumWidth(50)
        self.mav.setMaximumWidth(50)
        self.mav.setToolTip('Enter the Moving Average smoothing period in seconds')
        self.mav.setText(str(gglobs.mav_initial))
        self.mav.textChanged.connect(self.changedGraphOptionsMavText)

        btn_width = 50

        btnPoisson =  QPushButton('Poiss')
        btnPoisson.clicked.connect(lambda: self.plotPoisson())
        btnPoisson.setFixedWidth(btn_width)
        btnPoisson.setToolTip("Shows a plot of a Poisson curve on a histogram of the data in the current plot")

        btnFFT =  QPushButton('FFT')
        btnFFT.clicked.connect(lambda: self.plotFFT())
        btnFFT.setFixedWidth(btn_width)
        btnFFT.setToolTip("Show a plot of FFT spectra & Autocorrelation of the data in the current plot")

        btnPlotStats =  QPushButton('Stats')
        btnPlotStats.clicked.connect(lambda: gtools.printStats())
        btnPlotStats.setFixedWidth(btn_width)
        btnPlotStats.setToolTip("Shows the Statistics of the data in the current plot")

        btnQuickStats =  QPushButton('SuSt')
        btnQuickStats.clicked.connect(lambda: gtools.printSuSt())
        btnQuickStats.setFixedWidth(btn_width)
        btnQuickStats.setToolTip("Shows an All-Variables Overview of the data in the current plot")

        btnReset  = QPushButton('Reset')
        btnReset.clicked.connect(self.reset_replotGraph)
        btnReset.setFixedWidth(btn_width)
        btnReset.setToolTip("Reset all Graph Options to Default conditions")

        btnClear  = QPushButton('Clear')
        btnClear.clicked.connect(self.clearGraphLimits)
        btnClear.setFixedWidth(btn_width)
        btnClear.setToolTip("Clear the Graph Limit Options to Default conditions")

        btnApplyGraph = QPushButton('Apply')
        btnApplyGraph.clicked.connect(self.applyGraphOptions)
        btnApplyGraph.setStyleSheet("background-color: lightblue")
        btnApplyGraph.setFixedWidth(btn_width)
        btnApplyGraph.setMinimumHeight(65)
        btnApplyGraph.setToolTip("Apply the Graph Options and replot")
        btnApplyGraph.setDefault(True)

        self.labelVar = QLabel("---")
        self.labelVar.setToolTip("Shows the variable value in additional units when logging")
        self.labelVar.setMinimumWidth(130)
        self.labelVar.setFont(QFont('sans', 13, QFont.Bold))
        self.labelVar.setStyleSheet('color:darkgray;')
        self.labelVar.setAlignment(Qt.AlignCenter)
        self.labelVar.mousePressEvent=gtools.displayLastValues


    # separator lines
        vlineA0 = QFrame()
        vlineA0.setFrameShape(QFrame.VLine)

        hlineB3 = QFrame()
        hlineB3.setFrameShape(QFrame.HLine)

    # OFF / ON button
        btn_width = 35
        btnOFF = QPushButton('OFF')
        btnOFF .setToolTip("Uncheck all variables")
        btnOFF .clicked.connect(lambda: self.plotVarsOffOn("OFF"))
        btnOFF .setMaximumWidth(btn_width)

        btnON  = QPushButton('ON')
        btnON  .setToolTip("Check all avialable variables")
        btnON  .clicked.connect(lambda: self.plotVarsOffOn("ON"))
        btnON  .setMaximumWidth(btn_width)

    # layout of variables check boxes with OFF / ON button
        layoutH = QHBoxLayout()
        layoutH.addWidget(btnOFF)
        layoutH.addWidget(btnON)
        for i, vname in enumerate(gglobs.varnames):
            layoutH.addWidget(self.varDisplayCheckbox[vname])

        self.btnColor  = QPushButton('Color')
        self.btnColorText = "Color of selected variable; click to change it. Current color:  "
        self.btnColor  .setToolTip(self.btnColorText)
        self.btnColor  .clicked.connect(lambda: self.colorPicker())
        self.btnColor  .setMaximumWidth(50)

    #layout the GraphOptions
        graphOptions=QGridLayout()
        graphOptions.setContentsMargins(5,5,5,5) #spacing around the graph options

        # to define the order of stepping through by tab key
        # row 1 .. 3, col 1+2 is put in front
        row = 1
        graphOptions.addWidget(self.ymin,       row, 1)
        graphOptions.addWidget(self.ymax,       row, 2)
        row = 2
        graphOptions.addWidget(self.y2min,      row, 1)
        graphOptions.addWidget(self.y2max,      row, 2)
        row = 3
        graphOptions.addWidget(self.xmin,       row, 1)
        graphOptions.addWidget(self.xmax,       row, 2)

        row = 0
        graphOptions.addWidget(ltitle,          row, 0)
        graphOptions.addWidget(lmin,            row, 1)
        graphOptions.addWidget(lmax,            row, 2)
        graphOptions.addWidget(btnReset,        row, 3)
        graphOptions.addWidget(btnSetCalib,     row, 4)
        graphOptions.addWidget(vlineA0,         row, 5, 4, 1)
        graphOptions.addWidget(self.select,     row, 6, 1, 2)
        graphOptions.addWidget(btnQuickStats,   row, 8)

        row = 1
        graphOptions.addWidget(lcounts,         row, 0)
        # see above
        # see above
        graphOptions.addWidget(btnClear,        row, 3)
        graphOptions.addWidget(self.yunit,      row, 4)
        # col 5 is empty (vert line)
        graphOptions.addWidget(self.mavbox,     row, 6)
        graphOptions.addWidget(self.mav,        row, 7)
        graphOptions.addWidget(btnPlotStats,    row, 8)

        row = 2
        graphOptions.addWidget(ly2,             row, 0)
        # see above
        # see above
        graphOptions.addWidget(btnApplyGraph,   row, 3, 2, 1)
        graphOptions.addWidget(self.y2unit,     row, 4)
        # col 5 is empty (vert line)
        graphOptions.addWidget(self.avgbox,     row, 6)
        graphOptions.addWidget(self.btnColor,   row, 7)
        graphOptions.addWidget(btnPoisson,      row, 8)

        row = 3
        graphOptions.addWidget(ltime,           row, 0)
        # see above
        # see above
        graphOptions.addWidget(self.xunit,      row, 4)
        # col 5 is empty (vert line)
        graphOptions.addWidget(self.labelVar,   row, 6, 1, 2)
        graphOptions.addWidget(btnFFT,          row, 8)

        row = 4
        graphOptions.addWidget(hlineB3,         row, 0, 1, 9)

        row = 5
        graphOptions.addLayout(layoutH,         row, 0, 1, 9)

    # group Graph Options into Groupbox
        graphOptionsGroup = QGroupBox()
        graphOptionsGroup.setContentsMargins(0,0,0,0)

        graphOptionsGroup.setLayout(graphOptions)
        graphOptionsGroup.setMaximumHeight(200)
        #graphOptionsGroup.setStyleSheet("background-color:lightpink;")

# NotePad
        self.notePad = QTextEdit()
        self.notePad.setReadOnly(True)
        self.notePad.setFont(self.fontstd)
        self.notePad.setLineWrapMode(QTextEdit.NoWrap)
        self.notePad.setStyleSheet("color: rgb(60, 60, 60)")
        #self.notePad.setStyleSheet("background-color:lightgreen;")

        #set gglobs.notePad (used for fprint in utils)
        gglobs.notePad = self.notePad

# LogPad
        #self.logPad = QTextEdit("LogPad")
        self.logPad = QTextEdit()
        self.logPad.setReadOnly(True)
        self.logPad.setFont(self.fontstd)
        self.logPad.setLineWrapMode(QTextEdit.NoWrap)
        self.logPad.setStyleSheet("color: rgb(60, 60, 60)")
        #self.logPad.setStyleSheet("background-color:lightgreen;")

        #set gglobs.logPad (used for logPrint in utils)
        gglobs.logPad = self.logPad

# set the layout - left side
        splitterPad = QSplitter(Qt.Vertical)
        splitterPad.addWidget(self.notePad)
        splitterPad.addWidget(self.logPad)
        splitterPad.setSizes([800, 300])

        layoutLeft = QVBoxLayout()
        layoutLeft.addWidget(dataOptionsGroup)
        layoutLeft.addWidget(splitterPad)
        layoutLeft.setContentsMargins(0,0,0,0)
        layoutLeft.setSpacing(0)

# set the layout - right side
        myLayout =  QVBoxLayout()     # to show canvas with frame
        myLayout.setContentsMargins(0,0,0,0) # left, top, right, bottom
        myLayout.setSpacing(0)
        myLayout.addWidget(self.canvas)

        myGroup = QGroupBox()
        myGroup.setLayout(myLayout)
        myGroup.setContentsMargins(0,0,0,0)
        #myGroup.setStyleSheet("background-color:lightblue;")
        myGroup.setStyleSheet("background-color:#DFDEDD;") # same color as canvas

        layoutRight = QVBoxLayout()
        layoutRight.addWidget(graphOptionsGroup)
        layoutRight.addWidget(self.canvas)      # add canvas directly, no frame
        layoutRight.setContentsMargins(0,0,0,0)
        layoutRight.setSpacing(0)

# set the layout - both
        leftWidget = QWidget()
        leftWidget.setLayout(layoutLeft)

        rightWidget = QWidget()
        rightWidget.setLayout(layoutRight)

        splitterBoth = QSplitter(Qt.Horizontal)
        splitterBoth.addWidget(leftWidget)
        splitterBoth.addWidget(rightWidget)
        splitterBoth.setSizes([800, 750])
        splitterBoth.setContentsMargins(5,0,5,0)

# centralwidget
        self.setCentralWidget(splitterBoth)

#timer for logging
        self.timer = QTimer()
        self.timer.timeout.connect(self.getLogValues)

#show
        self.dcfLog.setText(str(gglobs.logFilePath))     # default is None
        self.dcfHis.setText(str(gglobs.hisFilePath))
        self.showTimingSetting (gglobs.logcycle)

        self.show()
        if gglobs.window_size == "maximized":
            self.showMaximized()

        vprint("Fonts:  App     -",       strFontInfo("", app.font()))  # print font info for QApplication
        vprint("Fonts:  logPad  -",       strFontInfo("", self.logPad.fontInfo()))
        vprint("Fonts:  notePad -",       strFontInfo("", self.notePad.fontInfo()))
        vprint("Fonts:  menubar -",       strFontInfo("", menubar.fontInfo()))
        vprint("Screen: Dimensions: ",   QDesktopWidget().screenGeometry()) # gives screen dimensions
        vprint("Screen: Available:  ",   screen_available)                        # gives screen dimensions available

        # Note on Windows sizes:
        # "On X11, a window does not have a frame until the window manager decorates it."
        # see: http://doc.qt.io/qt-4.8/application-windows.html#window-geometry
        dprint("Window: Dimensions: ", self.geometry(), " w/o Frame") # gives Windows dimensions but has the frame EXCLUDED!
        dprint("Window: Dimensions: ", self.frameGeometry(), " WITH Frame (not valid on X11)") # self.frameGeometry() gives Windows dimensions including frame, but not on X11!

        # copyright message
        message = __copyright__ + ", by " + __author__ + ", License: " + __license__
        self.showStatusMessage(message, timing=0, error=False) # message remains until overwritten by next

        QApplication.processEvents()

        wprint("Data  Options group: height: {}, width: {}".format(dataOptionsGroup.height(), dataOptionsGroup.width()))
        wprint("Graph Options group: height: {}, width: {}".format(graphOptionsGroup.height(), graphOptionsGroup.width()))

        dprint(TGREEN + "Startup complete " + "-" * 110 + TDEFAULT + "\n")


        if gglobs.startup_failure > "":
            #efprint(gglobs.startup_failure)
            playWav("error")
            self.startup_failure()
            self.close()


        # Devel Data - start GeigerLog with command 'devel' e.g.: 'geigerlog -dv devel'
        if gglobs.devel1:
            testFile = gglobs.dataPath + "/default.logdb"

            if os.access(testFile , os.R_OK):
                self.getLogFile(defaultLogDBPath = testFile)
            else:
                dprint("Testfile '{}' not found".format(testFile), debug=True)

        if gglobs.devel2:
            self.switchConnections(new_connection = "ON")

#========== END __init__ ======================================================
#
#========== BEGIN Class Functions =============================================

    def startup_failure(self):
        """if configuration file is missing or incorrect"""

        msg = QMessageBox(self)
        msg.setWindowIcon(self.iconGeigerLog)
        msg.setWindowTitle("ERROR")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.startup_failure)
        msg.setStandardButtons(QMessageBox.Ok)
        msg.setDefaultButton(QMessageBox.Ok)
        msg.setEscapeButton(QMessageBox.Ok)
        msg.setWindowModality(Qt.WindowModal)

        btn = QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QMessageBox.YesRole)
        msg.exec_()


    def saveNotepad(self):
        """Save Content of NotePad to file"""

        if gglobs.currentDBPath is None:
            self.showStatusMessage("No data available")
            return

        newFile = gglobs.currentDBPath + '.notes'
        fprint(header("Saving NotePad Content"))
        fprint("to File: {}\n".format(newFile))


        nptxt = self.notePad.toPlainText()  # Saving in Plain Text format; all is b&W,
                                            # colors are not preserved
        #htxt = self.notePad.toHtml()       # Saving in HTML Format; preserves any color
        #print("nptxt:", nptxt)

        with open(newFile, 'a') as f:
            f.write(nptxt)


    def colorPicker(self):
        """Called by the color picker button in the graph options.
        Changes color of the selected variable"""

        if gglobs.currentConn == None: return # no color change unless something is loaded

        colorDial   = QColorDialog(self)
        color       = colorDial.getColor()
        if color.isValid():
            vprint("colorPicker: new color picked:", color.name())
            self.btnColor.setStyleSheet("QWidget { background-color: %s }" % (color.name()))
            self.btnColor.setToolTip  (self.btnColorText + str(color.name()))
            self.btnColor.setStatusTip(self.btnColorText + str(color.name()))
            self.btnColor.setText("")
            QApplication.processEvents()

            # tuples cannot be changed, but dicts can
            vname                  = getNameSelectedVar()
            gglobs.varStyle[vname] = (color.name(), gglobs.varStyle[vname][1])
            self.applyGraphOptions()

        self.notePad.setFocus()


    def popup(self):

        """ checking radiobuttons
        radio1 = QRadioButton("button 1")
        radio2 = QRadioButton("button 2")
        radio3 = QRadioButton("button 3")

        for i in range(1,4):
            buttonname = "radio" + str(i)           # das geht???????
            if buttonname.isChecked():
                print buttonname + "is Checked"
        """

        #if gglobs.ser == None:
        if not gglobs.GMCConnection:
            self.showStatusMessage("No Device Connected")
            return

        # https://www.tutorialspoint.com/pyqt/pyqt_qlineedit_widget.htm
        # https://snorfalorpagus.net/blog/2014/08/09/validating-user-input-in-pyqt4-using-qvalidator/

        myLocale = QLocale (QLocale(QLocale.English, QLocale.UnitedStates))

        setDefault = False

        while True:
            #fbox=QFormLayout()
            fbox=QFormLayout()
            #fbox.setFieldGrowthPolicy (2)
            fbox.setFieldGrowthPolicy (QFormLayout.AllNonFixedFieldsGrow)

            # power
            #r01=QRadioButton("On")
            r01=QRadioButton("On")
            r02=QRadioButton("Off")
            powergroup = QButtonGroup()
            powergroup.addButton(r01)
            powergroup.addButton(r02)
            hbox0=QHBoxLayout()
            hbox0.addWidget(r01)
            hbox0.addWidget(r02)
            hbox0.addStretch()
            fbox.addRow(QLabel("Power"),hbox0)
            if gcommands.isPowerOn() == 'ON':
                r01.setChecked(True)
            else:
                r02.setChecked(True)

            # alarm
            r11=QRadioButton("On")
            r12=QRadioButton("Off")
            alarmgroup = QButtonGroup()
            alarmgroup.addButton(r11)
            alarmgroup.addButton(r12)

            hbox1=QHBoxLayout()
            hbox1.addWidget(r11)
            hbox1.addWidget(r12)
            hbox1.addStretch()
            fbox.addRow(QLabel("Alarm"),hbox1)
            if gcommands.isAlarmOn() == 'ON':
                r11.setChecked(True)
            else:
                r12.setChecked(True)

            # Speaker
            r21=QRadioButton("On")
            r22=QRadioButton("Off")
            #speakergroup = QButtonGroup()
            speakergroup = QButtonGroup()
            speakergroup.addButton(r21)
            speakergroup.addButton(r22)
            hbox2=QHBoxLayout()
            hbox2.addWidget(r21)
            hbox2.addWidget(r22)
            hbox2.addStretch()
            fbox.addRow(QLabel("Speaker"),hbox2)
            if gcommands.isSpeakerOn() == 'ON':
                r21.setChecked(True)
            else:
                r22.setChecked(True)

            # history Saverdatatapye
            hbox3=QHBoxLayout()
            cb1=QComboBox()
            cb1.addItems(gglobs.savedatatypes)
            hbox3.addWidget(cb1)
            hbox3.addStretch()
            fbox.addRow(QLabel("History Saving Mode"),hbox3)

            if not gglobs.GMCConnection:
            #if gglobs.ser == None:
                cb1.setCurrentIndex(0)
            else:
                cb1.setCurrentIndex(gglobs.savedataindex)

            # WiFi settings
            l1e=QLineEdit()
            l1e.setMaxLength (32)
            l2e=QLineEdit()
            l2e.setMaxLength (32)
            l3e=QLineEdit()
            l3e.setMaxLength (32)
            l4e=QLineEdit()
            l4e.setMaxLength (32)
            l5e=QLineEdit()
            l5e.setMaxLength (32)
            l6e=QLineEdit()
            l6e.setMaxLength (32)

            # self.calibration
            self.calHead = QHBoxLayout()
            self.calHead.addWidget(QLabel(" CPM"))
            self.calHead.addWidget(QLabel(" µSv/h"))
            self.calHead.addWidget(QLabel(" µSv/h / CPM"))

            fbox.addRow("Calibration Units:", self.calHead)

            self.cal0     = QHBoxLayout()
            self.cal0_cpm = QLineEdit()
            self.cal0_cpm.setValidator (QIntValidator(0, 99999))
            #self.cal0_cpm.textChanged.connect(self.textChanged)
            #self.cal0_cpm.textChanged.connect(lambda: self.textChanged("self.cal0_cpm"))
            self.cal0_cpm.editingFinished.connect(lambda: self.editingFinished("self.cal0_cpm"))
            #self.cal0_cpm.textEdited.connect(lambda: self.textChanged("self.cal0_cpm"))
            self.cal0_cpm.setToolTip("Enter an integer from 0 ... 99999")

            self.cal0_usv = QLineEdit()
            #self.cal0_usv.setValidator(QDoubleValidator(0, 9999, 4))
            #self.cal0_usv.textChanged.connect(lambda: self.textChanged(123))
            self.cal0_usv.editingFinished.connect(lambda: self.editingFinished("self.cal0_usv"))
            #self.cal0_usv.textEdited.connect(lambda: self.textChanged("self.cal0_usv"))
            #self.cal0_usv.textChanged.connect(self.check_state)
            self.cal0_usv.setToolTip("Enter a number from 0 ... 9999 with no more than 4 decimals")

            #self.cal0_fac = QLineEdit()
            #self.cal0_fac.setEnabled(False)
            self.cal0_fac = QLabel()

            self.cal0.addWidget(self.cal0_cpm)
            self.cal0.addWidget(self.cal0_usv)
            self.cal0.addWidget(self.cal0_fac)
            fbox.addRow("Calibration Point 1", self.cal0)

            self.cal1     = QHBoxLayout()
            self.cal1_cpm = QLineEdit()
            self.cal1_cpm.setValidator (QIntValidator(0, 99999))
            self.cal1_usv = QLineEdit()
            #self.cal1_fac = QLineEdit()
            #self.cal1_fac.setEnabled(False)
            self.cal1_fac = QLabel()

            self.cal1.addWidget(self.cal1_cpm)
            self.cal1.addWidget(self.cal1_usv)
            self.cal1.addWidget(self.cal1_fac)
            fbox.addRow("Calibration Point 2", self.cal1)

            self.cal2     = QHBoxLayout()
            self.cal2_cpm = QLineEdit()
            self.cal2_cpm.setValidator (QIntValidator(0, 99999))
            self.cal2_usv = QLineEdit()
            #self.cal2_fac = QLineEdit()
            #self.cal2_fac.setEnabled(False)
            self.cal2_fac = QLabel()

            self.cal2.addWidget(self.cal2_cpm)
            self.cal2.addWidget(self.cal2_usv)
            self.cal2.addWidget(self.cal2_fac)
            fbox.addRow("Calibration Point 3", self.cal2)

            for i in range(0,3):
                self.calcpm = gglobs.cfgLow["CalibCPM_{}".format(i)]
                self.calusv = gglobs.cfgLow["CalibuSv_{}".format(i)]
                self.calfac = self.calusv / self.calcpm

                if i == 0:
                    self.cal0_cpm.setText("{:1.0f}".format(self.calcpm))
                    self.cal0_usv.setText("{:1.2f}".format(self.calusv))
                    self.cal0_fac.setText("{:1.6f}".format(self.calfac))
                elif i == 1:
                    self.cal1_cpm.setText("{:1.0f}".format(self.calcpm))
                    self.cal1_usv.setText("{:1.2f}".format(self.calusv))
                    self.cal1_fac.setText("{:1.6f}".format(self.calfac))
                elif i == 2:
                    self.cal2_cpm.setText("{:1.0f}".format(self.calcpm))
                    self.cal2_usv.setText("{:1.2f}".format(self.calusv))
                    self.cal2_fac.setText("{:1.6f}".format(self.calfac))


            fbox.addRow("Website",l1e)
            fbox.addRow("URL",l2e)
            fbox.addRow("SSID",l3e)
            fbox.addRow("Password",l4e)
            fbox.addRow("CounterID",l5e)
            fbox.addRow("UserID",l6e)

            if setDefault :
                l1e.setText(gglobs.GMCmap["Website"])
                l2e.setText(gglobs.GMCmap["URL"])
                l3e.setText(gglobs.GMCmap["SSID"])
                l4e.setText(gglobs.GMCmap["Password"])
                l5e.setText(gglobs.GMCmap["CounterID"])
                l6e.setText(gglobs.GMCmap["UserID"])

            else:
                l1e.setText(gglobs.cfgMap["Website"])
                l2e.setText(gglobs.cfgMap["URL"])
                l3e.setText(gglobs.cfgMap["SSID"])
                l4e.setText(gglobs.cfgMap["Password"])
                l5e.setText(gglobs.cfgMap["CounterID"])
                l6e.setText(gglobs.cfgMap["UserID"])

            #fbox.addRow(QPushButton("Submit"),QPushButton("Cancel"))

            self.dialog = QDialog()
            self.dialog.setWindowIcon(self.iconGeigerLog)
            self.dialog.setFont(self.fontstd)
            self.dialog.setWindowTitle("popup")
            #d.setWindowModality(Qt.ApplicationModal)
            self.dialog.setWindowModality(Qt.WindowModal)
            #d.setMinimumWidth(800)
            #self.dialog.setMinimumHeight(gglobs.window_height + 50)


            # buttonbox: https://srinikom.github.io/pyside-docs/PySide/QtGui/QDialogButtonBox.html
            bbox    = QDialogButtonBox()

            bbox.addButton("Apply my Defaults", QDialogButtonBox.HelpRole)
            #bbox.setStandardButtons(QDialogButtonBox.Ok|QDialogButtonBox.Cancel|QDialogButtonBox.Reset)
            bbox.setStandardButtons(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
            bbox.addButton("My Reset", QDialogButtonBox.ResetRole)
            bbox.accepted.connect(lambda: self.dialog.done(0))
            bbox.rejected.connect(lambda: self.dialog.done(1))
            bbox.helpRequested.connect(lambda: self.dialog.done(2))
            bbox.clicked .connect(lambda: self.dialog.done(3))

            layoutV   = QVBoxLayout(self.dialog)
            layoutV.addLayout(fbox)
            layoutV.addWidget(bbox)

            ex = self.dialog.exec_()             # both seem to work the same


            print("-------------Ex:", ex)

            if ex == 0:
                pass
                break
            elif ex == 2:
                setDefault = True
            elif ex == 3:
                setDefault = False
            else:
                break


        print("r01 is Checked: ", r01.isChecked())
        print("r02 is Checked: ", r02.isChecked())
        print("r11 is Checked: ", r11.isChecked())
        print("r12 is Checked: ", r12.isChecked())
        print("r21 is Checked: ", r21.isChecked())
        print("r22 is Checked: ", r22.isChecked())
        print("cb1.currentIndex():", cb1.currentIndex())


    def textChanged(self,  number, *args, **kwargs):
        """ Function doc """

        print("textChanged:---------------------------")
        print("len(args):", len(args))
        for a in args:
            print("a:", a)

        print("len(kwargs):", len(kwargs))
        for a in kwargs:
            print("a:", a)
        print("number is:", number)

        print("self.sender:",               self.sender)
        print("self.sender():",             self.sender())
        print("self.sender().text:",        self.sender().text)
        print("self.sender().text():",      self.sender().text())
        print("self.sender().validator:",   self.sender().validator)
        print("self.sender().validator():", self.sender().validator())

        sender = self.sender()
        validator = sender.validator()
        state = validator.validate(sender.text(), 0)[0]
        print("validator.validate(sender.text(), 0):", validator.validate(sender.text(), 0))
        print("validator.validate(sender.text(), 1):", validator.validate(sender.text(), 1))

        print("float(self.sender().text()):",      float(self.sender().text()))


    def editingFinished(self, text, *args, **kwargs):
        """ Function doc """
        print("editingFinished---------------------------")
        print("len(args):", len(args))
        for a in args:
            print("a:", a)

        print("len(kwargs):", len(kwargs))
        for a in kwargs:
            print("a:", a)

        print("self.sender().text:",        self.sender().text)

        try:
            print("float(self.sender().text()):",      float(self.sender().text()))
        except:
            print("float(self.sender().text()):",      "##############################")

        try:
            usv = float(self.cal0_usv.text())
            self.cal0_fac.setText("{:1.6f}".format(usv  / float(self.cal0_cpm.text() )))
        except:
            self.cal0_usv.setFocus()
            self.cal0_usv.setStyleSheet('QLineEdit { background-color: %s }' % 'yellow')

            playWav("error")


    def check_state(self, *args, **kwargs):
        print("check_state:---------------------------")
        print("len(args):", len(args))
        for a in args:
            print("a:", a)

        print("len(kwargs):", len(kwargs))
        for a in kwargs:
            print("a:", a)
        print("self.sender:",               self.sender)
        print("self.sender():",             self.sender())
        print("self.sender().text:",        self.sender().text)
        print("self.sender().text():",      self.sender().text())
        print("self.sender().validator:",   self.sender().validator)
        print("self.sender().validator():", self.sender().validator())

        sender = self.sender()
        validator = sender.validator()
        state = validator.validate(sender.text(), 0)[0]
        print("validator.validate(sender.text(), 0):", validator.validate(sender.text(), 0))
        print("validator.validate(sender.text(), 1):", validator.validate(sender.text(), 1))

        print("float(self.sender().text()):",      float(self.sender().text()))

        if state == QValidator.Acceptable:
            #color = '#c4df9b' # green
            color = 'white'
        elif state == QValidator.Intermediate:
            color = '#fff79a' # yellow
        else:
            playWav("error")
            color = '#f6989d' # red
        sender.setStyleSheet('QLineEdit { background-color: %s }' % color)


    def snapLogValue(self, event):
        """Take a measurement when toolbar icon Snap is clicked, or when the
        variable value display in Graph options is clicked"""
        #Note: variable value display click inactivated

        if not gglobs.logging: return

        vprint("snapLogValue:")
        debugIndent(1)

        self.getLogValues()

        fprint(header("Snapped Log Values"))
        fprint(gglobs.lastRecord)
        vprint("snapLogValue: " + gglobs.lastRecord)

        # comment to the DB
        ctype       = "COMMENT"
        cJulianday  = "NOW"
        cinfo       = "Snapped log values: {}".format(gglobs.lastRecord)
        gsql.DB_insertComments(gglobs.logConn, [[ctype, cJulianday, "localtime", cinfo]])

        debugIndent(0)


#exit GeigerLog
    def closeEvent(self, event):
        """is called via self.close! Allow to Exit unless Logging is active"""

        # event: QEvent.Close = 19 : Widget was closed
        dprint("closeEvent: event type: {}".format(event.type()))
        debugIndent(1)

        if gglobs.logging :
            event.ignore()
            self.showStatusMessage("Cannot exit when logging! Stop logging first")
            dprint("closeEvent: ignored; Cannot exit when logging! Stop logging first")
        else:
            event.accept()                   # allow closing the window
            dprint("closeEvent: accepted")

            # terminate the devices
            if gglobs.GMCConnection     : gcommands   .terminateGMC()
            if gglobs.RMConnection      : gradmon     .terminateRadMon()
            if gglobs.AmbioConnection   : gambiomon   .terminateAmbioMon()
            if gglobs.LJConnection      : glabjack    .terminateLabJack() # LJ might not be loaded
            if gglobs.AudioConnection   : gaudio      .terminateAudio()
            if gglobs.I2CConnection     : gi2c        .terminateI2C()

            # close the databases for Log and His
            gsql .DB_closeDatabase(gglobs.logConn)
            gsql .DB_closeDatabase(gglobs.hisConn)

            QApplication.quit()              # works but keeps prog running, CTRL-C needed
            QApplication.closeAllWindows()   # works but keeps prog running, CTRL-C needed

            dprint("closeEvent: Exiting now")
            sys.exit(0)                      # sometimes needed to really shut down

        debugIndent(0)


#GraphOptions

    def changedGraphSelectedVariable(self):
        """called from the select combo for variables"""

        self.applyGraphOptions()


    def changedGraphDisplayCheckboxes(self, value):
        """Graph varDisplayCheckbox Value has changed"""

        if not gglobs.allowGraphUpdate: return

        oldIndex = self.select.currentIndex()

        text    = gglobs.vardict[value][0]
        index   = self.select.findText(text)
        #print("changedGraphDisplayCheckboxes: var:{}, longname:{}, index:{}".format(value, text, index))

        if self.varDisplayCheckbox[value].isChecked():
            # sets and enables the select combobox to the checked variable
            # thus making it to the selected variable
            self.select.model().item(index) .setEnabled(True)
            self.select                     .setCurrentIndex(index)

        else:
            # disables the unchecked variable on the select combobox,
            # and sets it to the first enabled entry. If none found then CPM is selected
            self.select.model().item(index) .setEnabled(False)
            foundSelVar = 0
            for i, key in enumerate(gglobs.varnames):
                #print("i, key, self.select.model().item(i) .isEnabled():", i, key, self.select.model().item(i) .isEnabled())
                if self.select.model().item(i) .isEnabled():
                    foundSelVar = i
                    break
            if self.select.currentIndex() == index: self.select.setCurrentIndex(foundSelVar)

        #print("----self.select.model().item(index).isEnabled:", self.select.model().item(index).isEnabled())

        # if the index is not changed, then an update is needed; otherwise
        # a changed index results in an update anyway via changedGraphSelectedVariable
        if self.select.currentIndex() == oldIndex:  self.applyGraphOptions()


    def changedGraphOptionsAvg(self, i):
        """Graph Option Avg has changed"""

        #print("changedGraphOptionsAvg: i:", i)
        gglobs.avgChecked  = self.avgbox.isChecked()
        self.applyGraphOptions()


    def changedGraphOptionsMav(self, i):
        """Graph Option Mav has changed"""

        #print("changedGraphOptionsMav: i:", i)
        gglobs.mavChecked  = self.mavbox.isChecked()
        if gglobs.mavChecked: gglobs.fprintMAV = True
        self.applyGraphOptions()


    def changedGraphOptionsMavText(self, i):
        """Graph Option MavText has changed"""

        #print("changedGraphOptionsMavText: i:", i)
        if self.mavbox.isChecked():
            #print("self.mavbox.isChecked():", self.mavbox.isChecked())
            gglobs.fprintMAV = True

        self.applyGraphOptions()


    def changedGraphCountUnit(self, i):
        """counter unit Graph Options for left Y-axis was changed"""

        oldYunit            = gglobs.YunitCurrent
        gglobs.YunitCurrent = str(self.yunit.currentText())
        newYunit            = gglobs.YunitCurrent
        #print("changedGraphCountUnit: i:", i, ",  oldYunit:", oldYunit, ",  newYunit:", newYunit)

        # convert Y to CPM unit if not already CPM
        if oldYunit == "µSv/h":
            if gglobs.Ymin != None: gglobs.Ymin = gglobs.Ymin / gglobs.calibration
            if gglobs.Ymax != None: gglobs.Ymax = gglobs.Ymax / gglobs.calibration

        # convert Y to µSv/h unit if not already µSv/h
        if newYunit == "µSv/h":
            if gglobs.Ymin != None: gglobs.Ymin = gglobs.Ymin * gglobs.calibration
            if gglobs.Ymax != None: gglobs.Ymax = gglobs.Ymax * gglobs.calibration

        if gglobs.Ymin == None: self.ymin.setText("")
        else:                   self.ymin.setText("{:.5g}".format(gglobs.Ymin))

        if gglobs.Ymax == None: self.ymax.setText("")
        else:                   self.ymax.setText("{:.5g}".format(gglobs.Ymax))

        if newYunit == "µSv/h":
            for vname in ("CPM", "CPS", "CPM1st", "CPS1st", "CPM2nd", "CPS2nd", "CPM3rd", "CPS3rd"):
                gglobs.varunit[vname] = "µSv/h"

        else: # newYunit == CPM
            for vname in ("CPM", "CPM1st", "CPM2nd", "CPM3rd"):
                gglobs.varunit[vname] = "CPM"

            for vname in ("CPS", "CPS1st", "CPS2nd", "CPS3rd"):
                gglobs.varunit[vname] = "CPS"

        self.applyGraphOptions()


    def changedGraphTemperatureUnit(self, i):
        """Temperature unit Graph Options was changed"""

        #print("changedGraphTemperatureUnit: New T unit:  i:", i, str(self.y2unit.currentText()) )

        if   i == 0:    gglobs.varunit["T"] = "°C"
        elif i == 1:    gglobs.varunit["T"] = "°F"

        self.applyGraphOptions()


    def changedGraphTimeUnit(self, i):
        """recalc xmin, xmax on Time unit changes"""

        #print("-----------------------changedGraphTimeUnit: i:", i)

        if np.all(gglobs.logTime) == None: return

        oldXunit = gglobs.XunitCurrent
        #print "oldXunit", oldXunit

        # convert all entries to days since start
        if   oldXunit == "Time":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft - gglobs.logTimeFirst
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright - gglobs.logTimeFirst

        elif oldXunit == "day": # no changes all in days
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright

        elif oldXunit == "hour":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft / 24.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright / 24.

        elif oldXunit == "minute":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft / 1440.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright / 1440.

        elif oldXunit == "second":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft / 86400.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright / 86400.

        gglobs.XunitCurrent = str(self.xunit.currentText())
        newXunit            = gglobs.XunitCurrent

        if newXunit == "auto":
            l = gglobs.logTime.max() - gglobs.logTime.min()
            #print "l=", l
            if   l > 3:          Xunit = "day"
            elif l * 24. > 3:    Xunit = "hour"
            elif l * 1440. > 3:  Xunit = "minute"
            else:                Xunit = "second"

            newXunit = Xunit

        gglobs.XunitCurrent = newXunit
        gglobs.Xunit        = newXunit
        #print "newXunit", newXunit

        if newXunit == "Time":
            if gglobs.Xleft  != None: gglobs.Xleft =  (str(mpld.num2date((gglobs.Xleft  + gglobs.logTimeFirst))))[:19]
            if gglobs.Xright != None: gglobs.Xright = (str(mpld.num2date((gglobs.Xright + gglobs.logTimeFirst))))[:19]

        elif newXunit == "day": # no changes all in days
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright

        elif newXunit == "hour":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft * 24.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright * 24.

        elif newXunit == "minute":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft * 1440.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright * 1440.

        elif newXunit == "second":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft * 86400.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright * 86400.

        if gglobs.Xleft == None:
            self.xmin.setText("")
        else:
            try:
                xl = "{:1.8f}".format(float(gglobs.Xleft))
            except:
                xl = gglobs.Xleft
            self.xmin.setText(xl)

        if gglobs.Xright == None:
            self.xmax.setText("")
        else:
            try:
                xr = "{:1.8f}".format(float(gglobs.Xright))
            except:
                xr = gglobs.Xright
            self.xmax.setText(xr)

        self.applyGraphOptions()


    def keyPressEvent(self, event):
        """Apply Graph is only Button to accept Enter and Return key"""

        # from: http://pyqt.sourceforge.net/Docs/PyQt4/qt.html#Key-enum
        # Qt.Key_Return     0x01000004
        # Qt.Key_Enter      0x01000005  Typically located on the keypad. (= numeric keypad)
        #print("event.key():", event.key())

        if event.key() in (Qt.Key_Enter, Qt.Key_Return):
            self.applyGraphOptions()


    def plotVarsOffOn(self, newstate="OFF"): # alt: 'ON'
        """checks or unchecks all variables from plotting"""

        gglobs.allowGraphUpdate    = False
        if newstate == "OFF":
            for i, vname in enumerate(gglobs.varnames):
                self.varDisplayCheckbox[vname].setChecked(False)
                self.select.model().item(i)   .setEnabled(False)
        else:
            for i, vname in enumerate(gglobs.varnames):
                if gglobs.varcheckedCurrent[vname]:
                    self.varDisplayCheckbox[vname].setChecked(True)
                    self.varDisplayCheckbox[vname].setEnabled(True)
                    self.select.model().item(i)   .setEnabled(True)

        # makes the index of the first enabled variable as the currentindex of the
        # variable select drop-down box
        for i, vname in enumerate(gglobs.varnames):
            #print("----i, self.select.model().item(i).isEnabled:", i, gglobs.ex.select.model().item(i).isEnabled())
            if self.select.model().item(i).isEnabled():
                gglobs.ex.select          .setCurrentIndex(i)
                break

        gglobs.allowGraphUpdate    = True
        self.applyGraphOptions() # not automatically done due to
                                 # blocking by gglobs.allowGraphUpdate


    def clearGraphLimits(self, fprintMAV = False):
        """resets all min, max graph options to empty and plots the graph"""

        dprint("clearGraphLimits:")
        debugIndent(1)

        gglobs.Xleft               = None
        gglobs.Xright              = None
        self.xmin.                   setText("")
        self.xmax.                   setText("")

        gglobs.Ymin                = None
        gglobs.Ymax                = None
        self.ymin.                   setText("")
        self.ymax.                   setText("")

        gglobs.Y2min               = None
        gglobs.Y2max               = None
        self.y2min.                  setText("")
        self.y2max.                  setText("")

        gplot.makePlot()

        debugIndent(0)


    def reset_replotGraph(self, fprintMAV = False):
        """resets all graph options to start conditions and plots the graph"""

        dprint("reset_replotGraph:")
        debugIndent(1)

        gglobs.allowGraphUpdate    = False

        gglobs.Xleft               = None
        gglobs.Xright              = None
        gglobs.Xunit               = "Time"
        self.xmin.                   setText("")
        self.xmax.                   setText("")
        self.xunit.                  setCurrentIndex(0)

        gglobs.Ymin                = None
        gglobs.Ymax                = None
        gglobs.Yunit               = "CPM"
        self.ymin.                   setText("")
        self.ymax.                   setText("")
        self.yunit.                  setCurrentIndex(0)

        gglobs.Y2min               = None
        gglobs.Y2max               = None
        gglobs.Y2unit              = "°C"
        self.y2min.                  setText("")
        self.y2max.                  setText("")
        self.y2unit.                 setCurrentIndex(0)

        self.select.                 setCurrentIndex(0)
        self.select.                 setEnabled(True)

        gglobs.avgChecked          = False
        self.avgbox.                 setChecked(gglobs.avgChecked)

        gglobs.mavChecked          = False
        self.mavbox.                 setChecked(gglobs.mavChecked)

        gglobs.mav                 = gglobs.mav_initial
        self.mav.                    setText(str(gglobs.mav_initial))

        gglobs.varStyle            = gglobs.varStyleDefault.copy() # reset colors and linetype

        gglobs.allowGraphUpdate    = True

        self.updateDisplayVariableValue()
        self.plotVarsOffOn(newstate="ON")   # also does a plot with applyGraphOptions # just changed

        debugIndent(0)


    def applyGraphOptions(self):

        if gglobs.currentConn == None: return

        #replace comma with dot, strip outer whitespace
        xmin  = (str(self.xmin.text()).replace(",", ".")).strip()
        xmax  = (str(self.xmax.text()).replace(",", ".")).strip()
        xunit = str(self.xunit.currentText())

        ymin  = (str(self.ymin.text()).replace(",", ".")).strip()
        ymax  = (str(self.ymax.text()).replace(",", ".")).strip()
        yunit = str(self.yunit.currentText())

        y2min  = (str(self.y2min.text()).replace(",", ".")).strip()
        y2max  = (str(self.y2max.text()).replace(",", ".")).strip()

        mav   = (str(self.mav.text()).replace(",", ".") ).strip()

    #    print( "X  xmin, xmax, xunit:", xmin, xmax, xunit)
    #    print( "Y: ymin, ymax, yunit, mav", ymin, ymax, yunit, mav)

        if  xmin == "":
            gglobs.Xleft  = None
        else:
            if gglobs.Xunit == "Time":
                try:
                    gglobs.Xleft = mpld.datestr2num(str(xmin))
                except:
                    gglobs.Xleft = None
                    efprint("Did not recognize Time Min")
            else:
                try:
                    gglobs.Xleft     = float(xmin)
                except:
                    gglobs.Xleft     = None
                    efprint("Did not recognize Time Min")

        if  xmax == "":
            gglobs.Xright = None
        else:
            if gglobs.Xunit == "Time":
                try:
                    gglobs.Xright = mpld.datestr2num(str(xmax))
                except:
                    gglobs.Xright = None
                    efprint("Did not recognize Time Max")
            else:
                try:
                    gglobs.Xright    = float(xmax)
                except:
                    gglobs.Xright    = None
                    efprint("Did not recognize Time Max")

        #print( "Xleft ", gglobs.Xleft,  ",  Xright", gglobs.Xright)

        if gglobs.Xleft != None and gglobs.Xright != None:
            if gglobs.Xleft >= gglobs.Xright:
                efprint("Wrong numbers: Time Min must be less than Time Max")
                return

        gglobs.Xunit     = xunit

        try:
            gglobs.Ymin      = float(ymin)
        except:
            gglobs.Ymin      = None

        try:
            gglobs.Ymax      = float(ymax)
        except:
            gglobs.Ymax      = None

        if gglobs.Ymin != None and gglobs.Ymax != None:
            if gglobs.Ymin >= gglobs.Ymax:
                efprint("Wrong numbers: Count Rate min must be less than Count Rate max")
                return

        gglobs.Yunit     = yunit

        try:
            gglobs.Y2min      = float(y2min)
        except:
            gglobs.Y2min      = None

        try:
            gglobs.Y2max      = float(y2max)
        except:
            gglobs.Y2max      = None

        if gglobs.Y2min != None and gglobs.Y2max != None:
            if gglobs.Y2min >= gglobs.Y2max:
                efprint("Wrong numbers: Count Rate min must be less than Count Rate max")
                return

        try:
            gglobs.mav     = float(mav)
        except:
            gglobs.mav     = gglobs.mav_initial

        colorName = gglobs.varStyle[getNameSelectedVar()][0]
        self.btnColor.setText("") # self.btnColor.setText(colorName)
        self.btnColor.setStyleSheet("QWidget { background-color: %s;}" % colorName)
        self.btnColor.setToolTip  (self.btnColorText + colorName)
        self.btnColor.setStatusTip(self.btnColorText + colorName)

        gplot.makePlot()
        self.updateDisplayVariableValue()


    def plotGraph(self, dataType):
        """Plots the data as graph; dataType is Log or His"""

        if  dataType == "Log" and gglobs.logConn == None or \
            dataType == "His" and gglobs.hisConn == None:
            self.showStatusMessage("No data available")
            return

        dprint("plotGraph: dataType:", dataType)
        debugIndent(1)

        if dataType == "Log":
            gglobs.activeDataSource     = "Log"
            gglobs.currentConn          = gglobs.logConn
            gglobs.currentDBPath        = gglobs.logDBPath
            gglobs.currentDBData        = gglobs.logDBData
            gglobs.varcheckedCurrent    = gglobs.varcheckedLog.copy()

            self.dcfLog.setText(gglobs.currentDBPath)
            self.dcfLog.setStyleSheet("QLineEdit { background-color: #F9F4C9; color: rgb(80,80,80); }")
            self.dcfHis.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")

        elif dataType == 'His':
            gglobs.activeDataSource     = "His"
            gglobs.currentConn          = gglobs.hisConn
            gglobs.currentDBPath        = gglobs.hisDBPath
            gglobs.currentDBData        = gglobs.hisDBData
            gglobs.varcheckedCurrent    = gglobs.varcheckedHis.copy()

            self.dcfHis.setText(gglobs.currentDBPath)
            self.dcfHis.setStyleSheet("QLineEdit { background-color: #F9F4C9; color: rgb(80,80,80); }")
            self.dcfLog.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")

        else:
            dprint("PROGRAMMING ERROR in geigerlog:plotGraph: var dataType is:", dataType, debug=True)
            sys.exit(1)

        #print("plotGraph: gglobs.activeDataSource:", gglobs.activeDataSource)
        #print("plotGraph: gglobs.currentDBPath, gglobs.logDBPath, gglobs.hisDBPath:\n", gglobs.currentDBPath, "\n", gglobs.logDBPath, "\n", gglobs.hisDBPath)
        #print("plotGraph: gglobs.currentConn, gglobs.logConn, gglobs.hisConn:\n", gglobs.currentConn, "\n", gglobs.logConn, "\n", gglobs.hisConn)
        #print("plotGraph: gglobs.varcheckedCurrent   ", gglobs.varcheckedCurrent)
        #print("plotGraph: gglobs.varcheckedLog", gglobs.varcheckedLog)
        #print("plotGraph: gglobs.varcheckedHis", gglobs.varcheckedHis)

        gglobs.allowGraphUpdate    = False
        for i, vname in enumerate(gglobs.varnames):
            value  = gglobs.varcheckedCurrent[vname]   # bool
            #print("vname, values in gglobs.varcheckedCurrent.items():", vname, value)
            self.varDisplayCheckbox[vname]  .setChecked(value)
            self.varDisplayCheckbox[vname]  .setEnabled(value)
            self.select.model().item(i)     .setEnabled(value)
        gglobs.allowGraphUpdate    = True


        if gglobs.currentDBData.size > 0:
            fprint(header("Plot Data"))
            fprint("from: {}".format(gglobs.currentDBPath))

        self.figure.set_facecolor('#F9F4C9') # change colorbg in graph from gray to light yellow
        self.reset_replotGraph()

        debugIndent(0)


    def updatecursorposition(self, event):
        """when cursor inside plot, get position and print to statusbar"""
        # see: https://matplotlib.org/api/backend_bases_api.html#matplotlib.backend_bases.MouseEvent

        # calc based on:
        # gglobs.y1_limit = ax1.get_ylim    defined in gplot.py
        # gglobs.y2_limit = ax2.get_ylim

        try: # results in non-breaqking error messages when no data are displayed
            if event.inaxes:
                x = event.xdata
                y2 = event.ydata
                #print x,y
                y1 = (y2 - gglobs.y2_limit[0]) / (gglobs.y2_limit[1] - gglobs.y2_limit[0]) * (gglobs.y1_limit[1] - gglobs.y1_limit[0]) + gglobs.y1_limit[0]

                if gglobs.Xunit == "Time":
                    tod = (str(mpld.num2date(x)))[:19]          # time of day
                    t   = gplot.getTsr(gglobs.logTimeFirst, x)

                else:
                    tod = gplot.getToD(gglobs.logTimeFirst, x, gglobs.XunitCurrent)
                    t   = "{:0.3f} {}s".format(x, gglobs.XunitCurrent)

                message = "Time since 1st record: {}, Time: {}, Counter: {:0.3f}, Ambient: {:0.3f}".format(t, tod, y1, y2)
                self.showStatusMessage(message, timing=0, error=False) # message remains until overwritten by next
        except:
            pass


    def onclick(self, event):
        """on mouseclick in graph enter time coords into xmin, xmax
        left click = xmin, right click = xmax"""

        try: # if no data are shown, this may result in non-breaking error messages
            if event.inaxes:
                x = event.xdata
                y = event.ydata
                b = event.button
                #print event, x,y,b

                if gglobs.Xunit == "Time":
                    t = (str(mpld.num2date(x)))[:19]
                else:
                    t = "{:0.6f}".format(x)

                if b == 1:                  # left click, xmin
                    self.xmin.setText(t)
                elif b == 3:                # right click, xmax
                    self.xmax.setText(t)
                else:
                    pass
        except:
            pass


#history
    def getHistory(self, source = "Binary File"):
        """getHistory either from source. source is one out of:
        - "Device"
        - "Database"
        - "Binary File"
        - "Parsed File"
        no return; data stored in global variables        """

    #
    # make the filedialog
    #
        # conditions
        if   source == "Database":
            # there must be an existing '*hisdb' file;
            # writing to it is not necessary; it will not be modified
            dlg=QFileDialog(caption = "Get History from Existing Database File", options=QFileDialog.DontUseNativeDialog)
            dlg.setFileMode(QFileDialog.ExistingFile)
            dlg.setNameFilter("History Files (*.hisdb)")

        elif source == "Binary File":
            # there must be an existing, readable '*.bin' file,
            # and it must be allowed to write .hisdb files
            # the bin file will remain unchanged
            dlg=QFileDialog(caption = "Get History from Existing Binary File", options=QFileDialog.DontUseNativeDialog)
            dlg.setFileMode(QFileDialog.ExistingFile)
            dlg.setNameFilter("History Files (*.bin)")

        elif source == "Parsed File":
            # there must be an existing, readable '*.his' file
            # and it must be allowed to write .hisdb files
            # the his file will remain unchanged
            dlg=QFileDialog(caption= "Get History from Existing Parsed File", options=QFileDialog.DontUseNativeDialog)
            dlg.setFileMode(QFileDialog.ExistingFile)
            dlg.setNameFilter("History Files (*.his)")

        elif source == "Device":
            if gglobs.logging:
                fprint(header("Get History from Device"))
                fprint("Cannot load History when logging. Stop Logging first", error=True)
                return

            # may use existing or new .hisdb file, but must be allowed to overwrite this file
            # an existing hisdb file will be overwritten
            dlg=QFileDialog(caption = "Get History from Device - enter new filename or select from existing", options=QFileDialog.DontUseNativeDialog)
            dlg.setFileMode(QFileDialog.AnyFile)
            dlg.setNameFilter("History Files (*.hisdb)")

        else:
            dprint("getHistory: Programming ERROR: undefined source:", source)
            sys.exit(1)

        dlg.setViewMode     (QFileDialog.Detail)
        dlg.setWindowIcon   (self.iconGeigerLog)
        dlg.setDirectory    (gglobs.fileDialogDir)

        # Execute dialog
        if dlg.exec_() == QDialog.Accepted:  pass     # QDialog Accepted
        else:                                return   # QDialog Rejected
    ### end filedialog -  a file was selected

    #
    # Process the selected file
    #
        while True:
            fprint(header("Get History from {}".format(source)))
            dprint("getHistory: from source: ", source)
            debugIndent(1)

            gglobs.fileDialogDir = dlg.directory().path() # remember the directory
            #print("getHistory: fileDialogDir:", gglobs.fileDialogDir)

            fnames      = dlg.selectedFiles()
            fname       = str(fnames[0])                # file path
            fext        = os.path.splitext(fname)[1]    # file ext
            fname_base  = os.path.splitext(fname)[0]    # file basename with path w/o ext
            dprint( "fname:{}, fname_base:{}, fext:{}".format(fname, fname_base, fext))

            gglobs.binFilePath = None
            gglobs.hisFilePath = None

            if   source == "Database":
                gglobs.hisDBPath   = fname # already has extension ".hisdb"
                if not isFileReadable(gglobs.hisDBPath):     break

            elif source == "Binary File":
                gglobs.binFilePath = fname
                gglobs.hisDBPath   = fname_base + ".hisdb"
                if not isFileReadable (gglobs.binFilePath):  break
                if not isFileWriteable(gglobs.hisDBPath):    break

            elif source == "Parsed File":
                gglobs.hisFilePath = fname
                gglobs.hisDBPath   = fname_base + ".hisdb"
                if not isFileReadable (gglobs.hisFilePath):  break
                if not isFileWriteable(gglobs.hisDBPath):    break

            elif source == "Device":
                if fext != ".hisdb":
                    gglobs.hisDBPath   = fname + ".hisdb" # file has any extension or none
                else:
                    gglobs.hisDBPath   = fname            # file already has .hisdb extension
                if not isFileWriteable(gglobs.hisDBPath):    break

            if source in ("Device"):
                if os.path.isfile(gglobs.hisDBPath):
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Critical)
                    msg.setWindowTitle("CAUTION")
                    critical  = """You selected an existing file, which will be <b>OVERWRITTEN</b> if you continue. Please confirm with OK.
        <br><br>Otherwise click Cancel and enter a new filename in the Get History from Device dialog."""
                    msg.setText(critical)
                    msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
                    msg.setDefaultButton(QMessageBox.Cancel)
                    msg.setEscapeButton(QMessageBox.Cancel)
                    retval = msg.exec_()

                    if retval != 1024:
                        fprint("Get History is cancelled")
                        break


            gglobs.currentDBPath   = gglobs.hisDBPath

            #dprint("getHistory: gglobs.binFilePath:     ", gglobs.binFilePath)
            #dprint("getHistory: gglobs.hisFilePath:     ", gglobs.hisFilePath)
            #dprint("getHistory: gglobs.hisDBPath:       ", gglobs.hisDBPath)
            #dprint("getHistory: gglobs.currentDBPath:   ", gglobs.currentDBPath)

            self.setBusyCursor()
            fprint("History database: {}"        .format(gglobs.hisDBPath))
            dprint("getHistory: database file:{}".format(gglobs.hisDBPath))

            self.dcfHis.setText(gglobs.currentDBPath)
            self.clearLogPad()

            # an existing classic his file was selected
            # delete old database first
            if gglobs.hisFilePath != None or gglobs.binFilePath != None:
                gglobs.hisConn = gsql.DB_deleteDatabase(gglobs.hisConn, gglobs.hisDBPath)

            # Open the database
            gglobs.hisConn = gsql.DB_openDatabase  (gglobs.hisConn, gglobs.hisDBPath)

            if gglobs.hisFilePath != None:
                fprint("Creating from file {}".format(gglobs.hisFilePath))
                # read data from CSV file into database
                self.setNormalCursor()
                success = self.getCSV(gglobs.hisFilePath)
                if success:
                    self.setBusyCursor()
                    gsql.DB_convertCSVtoDB(gglobs.hisConn, gglobs.hisFilePath)
                else:
                    efprint("Database creation was cancelled")
                    return

            elif gglobs.binFilePath != None:
                fprint("Creating from file {}".format(gglobs.binFilePath))

            # Make Hist for source = Device, Binary File
            if source in ("Device", "Binary File"):
                error, message = ghist.makeHistory(source)
                if error == -1:                                # a severe error
                    fprint(message, error=True)
                    break

#keep       gglobs.hisDBData                       = self.getDataFromFile() # old stuff keep !!!!
            gglobs.hisDBData, gglobs.varcheckedHis = self.getDataFromDatabase() # also creates varchecked

            self.plotGraph("His")
            self.checkLoggingState()
            QApplication.processEvents() # to make Normal Cursor appear only after graph shown
            break

        self.setNormalCursor()

        debugIndent(0)


    def toolPrintArrayInfo(self, name, array):
        """tool for devel for some array properties"""

        #return

        print("\nArrayname: " + name + ": ")
        print("rows type:   ", type(array))
        print("len(rows):   ", len(array))
        print("all rows:\n",   array)
        print()
        print("rows[0] type:", type(array[0]))
        print("len(rows[0]):", len(array[0]))
        print("all rows[0]:\n", array[0])
        for i in range(len(array[0])):
            print("{}[0][{}]: {}, type:{}".format(name, i, array[0][i], type(array[0][i])))
        print("------------------------------------------------")


    def getDataFromDatabase(self):
        """
        read the data from database
        and create data array with timestamp, CPM, CPS, etc
        """

        dprint("getDataFromDatabase: ")
        debugIndent(1)

        start = time.time()

        nrows           = None                           # set later by DB call
        ncols           = gglobs.datacolsDefault
        localvarchecked = gglobs.varcheckedCurrent.copy()

        sql = """
            SELECT
                Julianday - {} as jday,
                CPM,
                CPS,
                CPM1st,
                CPS1st,
                CPM2nd,
                CPS2nd,
                CPM3rd,
                CPS3rd,
                T,
                P,
                H,
                X
            FROM data
            ORDER BY jday
             """.format(gglobs.JULIAN111)

    # get the db rows
        # as a list of tuples:
        # [(737062.8293287037, 14, 0, None, None, None, None, None, None, None, None),
        #  (737062.8293402777, 14, 0, None, None, None, None, None, None, None, None),
        #  (737062.8293518517, 14 ...
        start3  = time.time()
        res     = gglobs.currentConn.execute(sql)
        rows    = res.fetchall()
        nrows   = len(rows)
        vprint("getDataFromDatabase: {:8.2f}ms sql call, " .format((time.time() - start3) * 1000.))
    #    self.toolPrintArrayInfo("rows", rows)

    # convert db rows to np array
        # np_rows is a type: <class 'numpy.ndarray'>, a ndarray of ndarrays, like:
        # [[737058.5991640585 17 0 ... 1024.68 32.0 9]
        #  [737058.5991872079 17 0 ... None None None]
        #  [737058.5992103536 17 0 ... None None None]
        start4 = time.time()
        np_rows = np.asarray(rows)
        vprint("getDataFromDatabase: {:8.2f}ms convert db rows to np.asarray" .format((time.time() - start4) * 1000.))
    #    self.toolPrintArrayInfo("np_rows", np_rows)

    # create dataarray via slicing
        # dataArray is a type <class 'numpy.ndarray'>
        # this converts the None to nan
        # [[7.37058599e+05 1.70000000e+01 0.00000000e+00 ... 1.02468000e+03  3.20000000e+01 9.00000000e+00]
        #  [7.37058599e+05 1.70000000e+01 0.00000000e+00 ...            nan             nan            nan]
        #  [7.37058599e+05 1.70000000e+01 0.00000000e+00 ...
        start5      = time.time()
        dataArray   = np.empty([nrows, ncols])
        if nrows > 0:    # do it only when data are in the database; error otherwise
            for i in range(0, ncols):     dataArray[:, i] = np_rows[:, i ]
        vprint("getDataFromDatabase: {:8.2f}ms make dataarray from np.asarray" .format((time.time() - start5) * 1000.))
    #    self.toolPrintArrayInfo("dataArray", dataArray)

    # Check the dataarray for columns having ONLY nan values. Block those
    # column from being selectable in combobox and showing in graph
        start6 = time.time()
        # all except DateTime set to true if at least one entry is not nan
        for i, a in enumerate(gglobs.varnames):
            if not np.isnan(dataArray[:, i + 1]).all():
                #print("i:", i, a, "has data")
                localvarchecked [a] = True
            else:
                #print("i:", i, a, "has only nan data")
                localvarchecked [a] = False
        vprint("getDataFromDatabase: {:8.2f}ms for nan checking, " .format((time.time() - start6) * 1000.))

    # Clean up
        dprint("getDataFromDatabase: {:8.2f}ms total for {} records with {} values each".format((time.time() - start) * 1000., nrows, ncols))

        debugIndent(0)

        return dataArray, localvarchecked


    def setLogTimings(self):
        """Set logcycle"""

        dprint("setLogTimings:")
        debugIndent(1)

        lctime     = QLabel("Log Cycle [s]\n(at least 0.1s)")
        lctime.setAlignment(Qt.AlignLeft)

        self.ctime  = QLineEdit()
        validator = QDoubleValidator(0.1, 9999, 1, self.ctime)
        self.ctime.setValidator(validator)
        self.ctime.setToolTip('The logging cycle in seconds')
        self.ctime.setText("{:0.3g}".format(gglobs.logcycle))

        graphOptions=QGridLayout()
        graphOptions.addWidget(lctime,                  0, 0)
        graphOptions.addWidget(self.ctime,              0, 1)

        graphOptionsGroup = QGroupBox()
        graphOptionsGroup.setLayout(graphOptions)

        d = QDialog(self) # set parent self to popup in center of geigerlog window
        d.setWindowIcon(self.iconGeigerLog)
        d.setFont(self.fontstd)
        d.setWindowTitle("Set Log Timings")
        d.setWindowModality(Qt.ApplicationModal)
        #d.setWindowModality(Qt.NonModal)
        #d.setWindowModality(Qt.WindowModal)

        self.bbox = QDialogButtonBox()
        self.bbox.setStandardButtons(QDialogButtonBox.Cancel | QDialogButtonBox.Ok )
        self.bbox.accepted.connect(lambda: d.done(0))
        self.bbox.rejected.connect(lambda: d.done(99))

        gglobs.btn = self.bbox.button(QDialogButtonBox.Ok)
        gglobs.btn.setEnabled(True)

        layoutV = QVBoxLayout(d)
        layoutV.addWidget(graphOptionsGroup)
        layoutV.addWidget(self.bbox)

        self.ctime.textChanged.connect(self.check_state) # last chance
        self.ctime.textChanged.emit   (self.ctime.text())

        if gglobs.logging:
            gglobs.btn.setEnabled(False)
            self.ctime.setEnabled(False)
            self.ctime.setStyleSheet('QLineEdit { background-color: %s;  }' % ("#e0e0e0",))

        retval = d.exec_()
        #print("reval:", retval)

        if retval == 99:
            dprint("setLogTimings: Escape, cycle time unchanged: ", gglobs.logcycle)
        else:
            # change the cycle time
            oldlogcycle = gglobs.logcycle
            logcycle    = self.ctime.text().replace(",", ".")  #replace comma with dot
            try:    lc  = round(float(logcycle), 1)
            except: lc  = oldlogcycle

            gglobs.logcycle = lc
            self.showTimingSetting(gglobs.logcycle)
            dprint("setLogTimings: ok, new cycle time: ", gglobs.logcycle)

            # update database with logcyle
            if gglobs.logConn != None:
                gsql.DB_updateLogcycle(gglobs.logConn, gglobs.logcycle)

        debugIndent(0)


    def check_state(self, *args, **kwargs):
        sender = self.sender()

        #print("sender.text():", sender.text())
        #print("args:", args)
        #print("kwargs:", kwargs)

        try:
            v = float(sender.text().replace(",", "."))
            if v < 0.1:
                state = 0       # too low
            else:
                state = 2       # ok
        except:
            state = 0           # wrong

        #print("QValidator.Acceptable:", QValidator.Acceptable)

        # Value: QValidator.Acceptable == 2
        if state == QValidator.Acceptable:
            #bgcolor = '#c4df9b' # green
            bgcolor = 'white' # white
            color   = 'black'
            gglobs.btn.setEnabled(True)
        #elif state == QValidator.Intermediate:
        #    color = '#fff79a' # yellow
        else:
            bgcolor = '#f6989d' # red
            bgcolor = '#fff79a' # yellow
            color   = 'red'
            self.ctime.setFocus()
            gglobs.btn.setEnabled(False)

        sender.setStyleSheet('QLineEdit { background-color: %s; color: %s }' % (bgcolor, color))


#logging
    def startLogging(self):
        """Starts the logging"""

        dprint("startLogging:")
        debugIndent(1)

        fprint(header("Start Logging"))

        while True:

            # A logfile is not loaded
            # should never happen as the start button should be inactive
            if gglobs.logDBPath == None:
                efprint("ALERT: Cannot log; Logfile is not loaded")
                break

            # Logfile is read-only, not writeable
            if not os.access(gglobs.logDBPath, os.W_OK):
                efprint("ALERT: Cannot log; Logfile is read-only, not available for writing!")
                break

            # No loggable variables
            if gglobs.activeVariables == 0:
                fprint("ALERT: No variables for logging available; Logging is not possible!", error=True)
                fprint("ALERT: please check configuration!", error=True)
                break

            # all clear, go for it
            gglobs.logging              = True          # set early, to alloww threads to get data
            gglobs.cpm_counter          = 0
            gglobs.currentDBPath        = gglobs.logDBPath

            w1  = "#DEVICES, {}, Connected: {}"           .format(stime(), gglobs.textDevVars)
            w2  = "#LOGGING, {}, Start: Cycle: {} sec"    .format(stime(), gglobs.logcycle)
            for a in (w1, w2):
                logPrint(a)
                fprint  (a)

            comments    = [None] * 2
            cinfo       = "Connected: {}"              .format(gglobs.textDevVars)
            comments[0] = ["DEVICES", "NOW", "localtime", cinfo]

            cinfo       = "Start: Cycle: {} sec"       .format(gglobs.logcycle)
            comments[1] = ["LOGGING", "NOW", "localtime", cinfo]
            gsql.DB_insertComments(gglobs.logConn, comments)

            self.cleanupDevices("before")

            # a loaded file may contain variables, which are currently not loggable
            # but should be displayed. Make sure all old and all new vars can be displayed
            for vname in gglobs.varnames:
                gglobs.varcheckedLog[vname] = True if    gglobs.varcheckedLog[vname] \
                                                      or gglobs.loggableVars[vname] \
                                         else False

            self.timer.start(gglobs.logcycle * 1000.0) # timer time is in ms; logcycle in sec
            dprint("startLogging: Logging now; Timer is started with cycle {} sec.".format(gglobs.logcycle))

            self.checkLoggingState()
            self.plotGraph("Log")               # initialize graph settings; getLogValues calls makePlot directly
            self.getLogValues()                  # make first call now; timer fires only AFTER 1st period!

            break

        debugIndent(0)


    def stopLogging(self):
        """Stops the logging"""

        dprint("stopLogging:")
        debugIndent(1)

        fprint(header("Stop Logging"))
        self.timer.stop()
        gglobs.logging = False

        writestring  = "#LOGGING, {}, Stop".format(stime())
        logPrint(writestring)
        fprint(writestring)

        gsql.DB_insertComments(gglobs.logConn, [["LOGGING", "NOW", "localtime", "Stop"]])

        self.cleanupDevices("after")

        self.checkLoggingState()
        self.labelVar.setStyleSheet('color:darkgray;')
        self.updateDisplayVariableValue()

        dprint("stopLogging: Logging is stopped")
        debugIndent(0)


    def cleanupDevices(self, ctype="before"):       # ctype="before" or "after"
        """like getExtrabyte for GMC devices"""

        #if gglobs.ser    != None  :
        #if gglobs.RMConnection    :
        #if gglobs.AmbioConnection :
        #if gglobs.LJConnection    :
        #if gglobs.AudioConnection :
        #if gglobs.I2CConnection   :


        if   ctype == "before":
            #if gglobs.ser    != None  :
            if gglobs.GMCConnection:
                dprint("startLogging: Cleaning pipeline before logging")
                gcommands.getExtraByte()

        elif ctype == "after":
            #if gglobs.ser    != None  :
            if gglobs.GMCConnection:
                dprint("stopLogging: Cleaning pipeline after logging")
                gcommands.getExtraByte()

        else:
            #whatever; just as placeholder
            #if gglobs.ser    != None  :
            if gglobs.GMCConnection:
                dprint("stopLogging: Cleaning pipeline ...")
                gcommands.getExtraByte()



    def addComment(self, dataType):
        """Adds a comment to the current log"""


        if dataType == "Log":
            if gglobs.logConn is None:
                self.showStatusMessage("No LogFile available")
                return
            info        = "Enter your comment to the Log: " + " "*100
        else:
            if gglobs.hisConn is None:
                self.showStatusMessage("No HisFile available")
                return
            info        = "Enter your comment to the History: " + " "*97

        d           = QInputDialog()
        dtext, ok   = d.getText(self, 'Add a Comment', info)
        dtext       = str(dtext)

        if ok:
            ctype       = "COMMENT"
            cJulianday  = "NOW"
            cinfo       = dtext
            if dataType == "Log":
                fprint(header("Add Comment to Log"))
                logPrint("#COMMENT, {}, {}".format(stime(), dtext)) # to the LogPad
                fprint("#COMMENT, {}, {}".format(stime(), dtext))   # to the NotePad
                gsql.DB_insertComments(gglobs.logConn, [[ctype, cJulianday, "localtime", cinfo]]) # to the DB

            else: # dataType == "His"
                fprint(header("Add Comment to History"))
                fprint("#COMMENT, {}, {}".format(stime(), dtext))   # to the NotePad
                cJulianday  = None
                gsql.DB_insertComments(gglobs.hisConn, [[ctype, cJulianday, "localtime", cinfo]]) # to the db

        vprint("Add a Comment: text='{}', ok={}".format(dtext,ok))


    def addError(self, errtext):
        """Adds ERROR info from gcommands as comment to the current log"""

        logPrint("#COMMENT, {}, {}".format(stime(), errtext))   # to the LogPad

        if not gglobs.logConn is None:                          # to the DB
            gsql.DB_insertComments(gglobs.logConn, [["DevERROR", "NOW", "localtime", errtext]])


    def getLogValues(self):
        """
        Reads variables CPM, ... etc. from devices, saves it in log file, and
        prints record into LogPad.
        Called by the timer once the timer is started
        """

        if not gglobs.logging:      return    # currently not logging
        if gglobs.logConn == None:  return    # no connection defined

        start = time.time()
        vprint("getLogValues: saving to:", gglobs.logDBPath)
        debugIndent(1)

        timeJulian, timetag = gsql.DB_getLocaltime() # e.g.: 2458512.928904213, '2019-01-29 10:17:37'
        #print("timetag:", timetag, ",  timeJulian:",timeJulian)

    # Reset the logValues to NULL
        logValue = {}                              # logvalue dict
        for vname in gglobs.varnames:
            logValue[vname] = gglobs.NAN           # set all to NULL/NAN

    # get the new values for each device (if active)
        # gglobs.DevicesNames : ("GMC", "RadMon", "AmbioMon", "LabJack", "Audio")
        # e.g.: gglobs.DevicesVars['GMC']    : ['CPM', 'CPS']
        # e.g.: gglobs.DevicesVars['RadMon'] : ['T', 'P', 'H', 'R']
        for devname in gglobs.DevicesNames:
            #print("devname:", devname)
            if   devname == "GMC"      and gglobs.GMCConnection:
                logValue.update(gcommands.getGMCValues(gglobs.DevicesVars[devname]))

            elif devname == "RadMon"   and gglobs.RMConnection:
                logValue.update(gradmon.getRadMonValues(gglobs.DevicesVars[devname]))

            elif devname == "AmbioMon" and gglobs.AmbioConnection:
                logValue.update(gambiomon.getAmbioMonValues(gglobs.DevicesVars[devname]))

            elif devname == "LabJack"  and gglobs.LJConnection:
                logValue.update(glabjack.getLabJackValues(gglobs.DevicesVars[devname]))

            elif devname == "Audio"    and gglobs.AudioConnection:
                logValue.update(gaudio.getAudioValues(gglobs.DevicesVars[devname]))

            elif devname == "I2C"    and gglobs.I2CConnection:
                logValue.update(gi2c.getI2CValues(gglobs.DevicesVars[devname]))

        #print("------------getLogValues:  logValue:", logValue)

    # create the printstring and print to LogPad
        # Example: 1162 11:43:40   M=143  S=1  M1=  S1=  M2=128.0  S2=3.0  T=25.0  P=983.63  H=24.0  R=18.0
        # timetag: cut-off Date, use time only  '2018-07-14 12:00:52' --> '12:00:52'
        printstring = "{:2.7g} {:8s} " .format(gglobs.cpm_counter, timetag[11:])
        for vname in gglobs.varnames:
            if gglobs.varcheckedLog[vname]:
                printstring     += " {}=".format(gglobs.vardict[vname][1])
                if not np.isnan(logValue[vname]):
                    printstring += "{:<6.5g}".format(logValue[vname])
                else:
                    printstring += " " * 6
        logPrint(printstring)
        gglobs.lastRecord   = printstring    # needed when a record was snapped
        #print("----------------printstring:", printstring)

    # create the database insert and update in-memory data
        datalist     = [None] * (gglobs.datacolsDefault + 1) # (12 + 1) x None
        datalist[0]  = gglobs.cpm_counter
        datalist[1]  = "NOW"

        nanOnly      = True
        for i, vname in enumerate(gglobs.varnames):
            if not np.isnan(logValue[vname]):
                nanOnly         = False
                datalist[i + 2] = logValue[vname]
        #print("----------------datalist:", datalist)

        # save data, but only if at least one variable is not nan
        if not nanOnly:
            # Write to database
            gsql.DB_insertData(gglobs.logConn, [datalist[0:2] + ["localtime"] + datalist[2:]])

            # update the logDBData array; time is set to matplotlib time
            gglobs.logDBData = np.append(gglobs.logDBData, \
                                                        [[timeJulian - gglobs.JULIAN111, \
                                                          logValue["CPM"],    \
                                                          logValue["CPS"],    \
                                                          logValue["CPM1st"], \
                                                          logValue["CPS1st"], \
                                                          logValue["CPM2nd"], \
                                                          logValue["CPS2nd"], \
                                                          logValue["CPM3rd"], \
                                                          logValue["CPS3rd"], \
                                                          logValue["T"],      \
                                                          logValue["P"],      \
                                                          logValue["H"],      \
                                                          logValue["X"]]],    \
                                                          axis=0)

    # update index (=cpm_counter)
        gglobs.cpm_counter   += 1

    # update the lastValues
        if gglobs.lastValues == None:                     # occurs only right after start
            gglobs.lastValues = logValue
        else:
            for vname in gglobs.varnames:
                if not np.isnan(logValue[vname]):   # update only if not nan
                    gglobs.lastValues[vname] = logValue[vname]
        #print("gglobs.lastValues:",gglobs.lastValues)

    # update Value Displays
        self.updateDisplayVariableValue()   # getLogValues

        #before = time.time()

    # update graph, only if graph is the current one!
        if gglobs.activeDataSource == "Log":
            gglobs.currentDBData = gglobs.logDBData       # the data!
            gplot.makePlot()                              # direct plot; slightly quicker than PlotGraph

    # before graph: about 20ms with this: Connected: GMC( CPM CPS ); RadMon( T P H R ); Audio( CPM2nd CPS2nd );
    # after  graph: about 90...140ms with this: Connected: GMC( CPM CPS ); RadMon( T P H R ); Audio( CPM2nd CPS2nd );
        #print("getLogValues: duration before graph: {:3.3f} ms".format((before -start)*1000))
        #print("getLogValues: duration after graph:  {:3.3f} ms".format((time.time() -start)*1000))

    # relevant only when ESP32 is connected (maybe in conflict with other USB-To Serial devices!)
        readSerialConsole()

        debugIndent(0)
# end getLogValues##############################################################


#
# Update the display
#
    def showTimingSetting(self, logcycle):
        """update the Timings shown under Data"""

        self.dcycl.setText("Cycle: {:0.3g} s".format(logcycle))


    def updateDisplayVariableValue(self):
        """update the variable value displayed in the Graph area"""

        #print("-------------updateDisplayVariableValue: ")

        if gglobs.lastValues == None:
            self.labelVar.setText(" --- ")
            self.labelVar.setToolTip("Shows Last Values when logging")
            self.labelVar.setStatusTip("Shows Last Values when logging")
            return

        # updates the variables shown in the DisplayVariables Window
        try:
            for i, vname in enumerate(gglobs.varnames):
                if self.vlabels[i] is None: continue

                if not gglobs.varcheckedLog[vname]:
                    val = "{:>16s}".format("not mapped")
                else:
                    #if not np.isnan(gglobs.lastValues[vname][0]):
                    if not np.isnan(gglobs.lastValues[vname]):
                        #val = "{:>8.2f}".format(gglobs.lastValues[vname][0])
                        val = "{:>8.2f}".format(gglobs.lastValues[vname])
                    else:
                        val = "{:>8s}".format("  --- ")
                self.vlabels[i].setText(val)

                if gglobs.logging and gglobs.varcheckedLog[vname]:
                    self.vlabels[i].setStyleSheet("QLabel { background-color : #F4D345; color : black; }")
                elif not gglobs.logging and gglobs.varcheckedLog[vname]:
                    self.vlabels[i].setStyleSheet("QLabel {color:darkgray; }")
                else:
                    self.vlabels[i].setStyleSheet("QLabel {color:darkgray; font-size:14px;}")

        except Exception as e:
            wprint("------------updateDisplayVariableValue: 1st Exception:", e)
            pass

       # when logging with black on yellow background, else with dark.grey on grey
        if gglobs.logging and gglobs.activeDataSource == "Log":
            self.labelVar.setStyleSheet('color: black; background-color: #F4D345;')

        elif gglobs.activeDataSource == "His":
            self.labelVar.setText(" --- ")
            self.labelVar.setToolTip("Shows Last Values when logging")
            self.labelVar.setStatusTip("Shows Last Values when logging")
            self.labelVar.setStyleSheet('color:darkgray;')
            return

        selVar    = self.select.currentText()         # selected variable
        selUnit1  = self.yunit .currentText()
        selUnit2  = self.y2unit.currentText()
        varText   = " --- "
        statusTip = ""

        if gglobs.calibration    == "auto":  scale1st = gglobs.DefaultCalibration1st
        else:                                scale1st = gglobs.calibration

        if gglobs.calibration2nd == "auto":  scale2nd = gglobs.DefaultCalibration2nd
        else:                                scale2nd = gglobs.calibration2nd

        if gglobs.Calibration3rd  == "auto":  scaleRM  = gglobs.DefaultCalibration3rd
        else:                                scaleRM  = gglobs.Calibration3rd
        #print("scale1st:", scale1st)
        #print("scale2nd:", scale2nd)
        #print("scaleRM:" , scaleRM)

        while True:

            if   selVar == "CPM":
                #value    = gglobs.lastValues["CPM"][0]
                value    = gglobs.lastValues["CPM"]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText ="{:0.2f} CPM".format(value)
                else:
                    varText = "{:0.2f} µSv/h".format(value * scale1st)

                statusTip  = "{:0.2f} CPM"     .format(value)
                statusTip += " = {:0.2f} CPS"  .format(value / 60)
                statusTip += " = {:0.2f} µSv/h".format(value * scale1st)
                statusTip += " = {:0.2f} mSv/a".format(value * scale1st / 1000 * 24 * 365.25)

            elif selVar == "CPS":
                #value    = gglobs.lastValues["CPS"][0]
                value    = gglobs.lastValues["CPS"]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.2f} CPS".format(value)
                else:
                    varText = "{:0.2f} µSv/h".format(value * 60 * scale1st)

                statusTip  = "{:0.2f} CPS"     .format(value)
                statusTip += " = {:0.2f} CPM"  .format(value * 60)
                statusTip += " = {:0.2f} µSv/h".format(value * 60 * scale1st)
                statusTip += " = {:0.2f} mSv/a".format(value * 60 * scale1st / 1000 * 24 * 365.25)



            elif selVar == "CPM1st":
                #value    = gglobs.lastValues["CPM1st"][0]
                value    = gglobs.lastValues["CPM1st"]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.2f} CPM".format(value)
                else:
                    varText = "{:0.2f} µSv/h".format(value * scale1st)

                statusTip  = "{:0.2f} CPM"     .format(value)
                statusTip += " = {:0.2f} CPS"  .format(value / 60)
                statusTip += " = {:0.2f} µSv/h".format(value * scale1st)
                statusTip += " = {:0.2f} mSv/a".format(value * scale1st / 1000 * 24 * 365.25)

            elif selVar == "CPS1st":
                #value    = gglobs.lastValues["CPS1st"][0]
                value    = gglobs.lastValues["CPS1st"]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.2f} CPS".format(value)
                else:
                    varText = "{:0.2f} µSv/h".format(value * scale1st)

                statusTip  = "{:0.2f} CPS"     .format(value)
                statusTip += " = {:0.2f} CPM"  .format(value * 60)
                statusTip += " = {:0.2f} µSv/h".format(value * 60 * scale1st)
                statusTip += " = {:0.2f} mSv/a".format(value * 60 * scale1st / 1000 * 24 * 365.25)



            elif selVar == "CPM2nd":
                #value    = gglobs.lastValues["CPM2nd"][0]
                value    = gglobs.lastValues["CPM2nd"]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.2f} CPM".format(value)
                else:
                    varText = "{:0.2f} µSv/h".format(value * scale2nd)

                statusTip  = "{:0.2f} CPM"     .format(value)
                statusTip += " = {:0.2f} CPS"  .format(value / 60)
                statusTip += " = {:0.2f} µSv/h".format(value * scale2nd)
                statusTip += " = {:0.2f} mSv/a".format(value * scale2nd / 1000 * 24 * 365.25)


            elif selVar == "CPS2nd":
                #value    = gglobs.lastValues["CPS2nd"][0]
                value    = gglobs.lastValues["CPS2nd"]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.2f} CPM".format(value)
                else:
                    varText = "{:0.2f} µSv/h".format(value * scale2nd)

                statusTip  = "{:0.2f} CPS"     .format(value)
                statusTip += " = {:0.2f} CPM"  .format(value * 60)
                statusTip += " = {:0.2f} µSv/h".format(value * 60 * scale2nd)
                statusTip += " = {:0.2f} mSv/a".format(value * 60 * scale2nd / 1000 * 24 * 365.25)



            elif selVar == "CPM3rd":
                #value    = gglobs.lastValues["CPM3rd"][0]
                value    = gglobs.lastValues["CPM3rd"]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.2f} CPM".format(value)
                else:
                    varText = "{:0.2f} µSv/h".format(value * scale2nd)

                statusTip  = "{:0.2f} CPM"     .format(value)
                statusTip += " = {:0.2f} CPS"  .format(value / 60)
                statusTip += " = {:0.2f} µSv/h".format(value * scale2nd)
                statusTip += " = {:0.2f} mSv/a".format(value * scale2nd / 1000 * 24 * 365.25)

            elif selVar == "CPS3rd":
                #value    = gglobs.lastValues["CPS3rd"][0]
                value    = gglobs.lastValues["CPS3rd"]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.2f} CPM".format(value)
                else:
                    varText = "{:0.2f} µSv/h".format(value * scale2nd)

                statusTip  = "{:0.2f} CPS"     .format(value)
                statusTip += " = {:0.2f} CPM"  .format(value * 60)
                statusTip += " = {:0.2f} µSv/h".format(value * 60 * scale2nd)
                statusTip += " = {:0.2f} mSv/a".format(value * 60 * scale2nd / 1000 * 24 * 365.25)


            elif selVar == "Temperature":
                #value    = gglobs.lastValues["T"][0]
                value    = gglobs.lastValues["T"]
                if np.isnan(value):   break

                if selUnit2 == "°C":
                    varText = "{:0.2f} °C".format(value)
                else:
                    varText = "{:0.2f} °F".format(value / 5 * 9 + 32)

                statusTip  = "{:0.2f} °C"     .format(value)
                statusTip += " = {:0.2f} °F"  .format(value / 5 * 9 + 32)

            elif selVar == "Pressure":
                #value    = gglobs.lastValues["P"][0]
                value    = gglobs.lastValues["P"]
                if np.isnan(value):   break

                varText = "{:0.2f} hPa".format(value)

                statusTip  = "{:0.2f} hPa"      .format(value)
                statusTip += " = {:0.2f} mbar"  .format(value)

            elif selVar == "Humidity":
                #value       = gglobs.lastValues["H"][0]
                value       = gglobs.lastValues["H"]
                if np.isnan(value):   break
                varText    = "{:0.2f} %".format(value)
                statusTip  = "{:0.2f} %".format(value)

            elif selVar == "Xtra":
                #value    = gglobs.lastValues["X"][0]
                value    = gglobs.lastValues["X"]
                if np.isnan(value):   break

                varText    = "{:0.2f}".format(value)
                statusTip  = "{:0.2f}".format(value)

            break

        self.labelVar.setText(varText)
        self.labelVar.setToolTip(statusTip)
        self.labelVar.setStatusTip(statusTip)


#
# Get Log file
#
    def quickLog(self):
        """Starts logging with empty default log file 'default.log'"""

        fprint(header("Quick Log"))
        fprint("Start logging using Quick Log database 'default.logdb'")
        dprint("quickLog: using Quick Log database 'default.logdb'")
        debugIndent(1)

        gglobs.logDBPath   = os.path.join(gglobs.dataPath, "default.logdb")

        gsql.DB_deleteDatabase(gglobs.logConn, gglobs.logDBPath)

        self.getLogFile(defaultLogDBPath = gglobs.logDBPath) # get default.logdb

        self.startLogging()

        debugIndent(0)


    def getLogFile(self, defaultLogDBPath = False, source="Database"):
        """Load existing file for logging, or create new one.
        source can be:
        - "Database" (which is *.logdb file )
        - "CSV File" (which is *.log or *.csv file)
        """

        #
        # Get logfile filename/path
        #
        # A default logfile is given; use it
        if defaultLogDBPath != False:
            gglobs.logFilePath      = None
            gglobs.logDBPath        = defaultLogDBPath
            #dprint("getLogFile: using defaultLogDBPath: ", gglobs.logDBPath)

        # A default logfile is NOT given; run dialog to get one
        else:
            if   source == "Database":
                # may use existing or new .logdb file, but must be allowed to overwrite this file
                # an existing logdb file will be appended with new data
                dlg=QFileDialog(caption= "Get LogFile - Enter New Filename or Select from Existing", options=QFileDialog.DontUseNativeDialog)
                dlg.setFileMode(QFileDialog.AnyFile)

                dlg.setNameFilter("Logging Files (*.logdb)")

            elif source == "CSV File":
                # there must be an existing, readable '*.log' or '*.csv' file
                # and it must be allowed to write .hisdb files
                # the log/csv file will remain unchanged

                dlg=QFileDialog(caption = "Get LogFile from Existing File", options=QFileDialog.DontUseNativeDialog)
                dlg.setFileMode(QFileDialog.ExistingFile)
                dlg.setNameFilter("Logging Files (*.log *.csv)")

            else:
                dprint("getLogFile: Programming ERROR: undefined source:", source)
                sys.exit(1)

            dlg.setViewMode(QFileDialog.Detail)
            dlg.setWindowIcon(self.iconGeigerLog)
            dlg.setDirectory(gglobs.fileDialogDir)

            # Execute dialog
            if dlg.exec_() == QDialog.Accepted:  pass     # QDialog Accepted
            else:                                return   # QDialog Rejected
            ### end filedialog -  a file was selected

            gglobs.fileDialogDir = dlg.directory().path()
            #print("dlg.directory().path():", dlg.directory().path())

            fnames  = dlg.selectedFiles()
            fname   = str(fnames[0])                    # file path
            fext    = os.path.splitext(fname)[1]        # file extension
            fname_base  = os.path.splitext(fname)[0]    # file basename with path w/o ext

            if   source == "Database":  # extension is .logdb
                gglobs.logFilePath = None
                if fext != ".logdb":
                    gglobs.logDBPath   = fname + ".logdb" # file has any extension or none
                else:
                    gglobs.logDBPath   = fname            # file already has .hisdb extension

            elif source == "CSV File":  # extension is .log
                gglobs.logFilePath = fname
                gglobs.logDBPath   = fname_base + ".logdb"
                if not isFileReadable (gglobs.logFilePath):   return

            if source == "Database":
                if os.path.isfile(gglobs.logDBPath):
                    msg = QMessageBox()
                    msg.setIcon(QMessageBox.Warning)
                    msg.setWindowTitle("CAUTION")
                    critical  = """You selected an existing file, which will be modified \
        when logging by <b>APPENDING</b> new data to it. Please confirm with OK.
        <br><br>Otherwise click Cancel and enter a new filename in the Get Log File dialog."""
                    msg.setText(critical)
                    msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
                    msg.setDefaultButton(QMessageBox.Cancel)

                    msg.setEscapeButton(QMessageBox.Cancel)
                    retval = msg.exec_()

                    if retval != 1024:
                        return

        # Done getting LogFile   ##############################################

        self.setBusyCursor()

        gglobs.currentDBPath   = gglobs.logDBPath

        fprint(header("Get Log"))
        fprint("Log database: {}".                               format(gglobs.logDBPath))
        if defaultLogDBPath == False:
            dprint("getLogFile: use selected Log DB file: '{}'". format(gglobs.logDBPath))
        else:
            dprint("getLogFile: use default Log DB file: '{}'".  format(defaultLogDBPath))
        debugIndent(1)

        #dprint("getLogFile: gglobs.logFilePath:     ", gglobs.logFilePath)
        #dprint("getLogFile: gglobs.logDBPath:       ", gglobs.logDBPath)
        #dprint("getLogFile: gglobs.currentDBPath:   ", gglobs.currentDBPath)

        if gglobs.logging:   self.stopLogging()
        self.dcfLog.setText(gglobs.logDBPath)
        self.clearLogPad()

        # an existing classic log was selected. It will be converted to a database;
        # any previous conversion will be deleted first
        if gglobs.logFilePath != None:
            fprint("Created from file {}".format(gglobs.logFilePath))
            # delete old database
            gsql.DB_deleteDatabase(gglobs.logConn, gglobs.logDBPath)

            # open new database
            gglobs.logConn      = gsql.DB_openDatabase(gglobs.logConn, gglobs.logDBPath)

            # read data from CSV file into database
            self.setNormalCursor()

            if self.getCSV(gglobs.logFilePath):
                self.setBusyCursor()
                gsql.DB_convertCSVtoDB(gglobs.logConn, gglobs.logFilePath)
            else:
                efprint("Database creation was cancelled")
                return


        # a database file was selected
        else:
            # Database File does NOT exist; create new one
            if not os.path.isfile(gglobs.logDBPath):
                fprint("LogFile newly created - available for writing")

                linfo = "LogFile newly created as '{}'".format(os.path.basename(gglobs.logDBPath))
                logPrint("#HEADER , {}, ".format(stime()) + linfo)

                # open new database
                gglobs.logConn      = gsql.DB_openDatabase(gglobs.logConn, gglobs.logDBPath)

                ctype       = "HEADER"
                cJulianday  = 'NOW'
                cinfo       = linfo
                gsql.DB_insertComments(gglobs.logConn, [[ctype, cJulianday, "localtime", cinfo]])

                # data array for the variables
                gglobs.logDBData = np.empty([0, gglobs.datacolsDefault])

            # Database File does exist
            else:
                # Database File does exist and can read and write
                if os.access(gglobs.logDBPath, os.W_OK):
                    fprint("LogFile opened - available for writing")

                # DB File does exist but can read only
                elif os.access(gglobs.logDBPath, os.R_OK):
                    fprint("LogFile opened - ALERT: available ONLY FOR READING", error=True)

                gglobs.logConn    = gsql.DB_openDatabase  (gglobs.logConn, gglobs.logDBPath)

# keep! gglobs.logDBData                       = self.getDataFromFile()       # via numpy
        gglobs.logDBData, gglobs.varcheckedLog = self.getDataFromDatabase()
        gglobs.lastValues                      = None


        # add the default logcycle as read from the database
        testcycle = gsql.DB_readLogcycle(gglobs.logConn)    # testcycle is type float
        #print("testcycle:",testcycle, type(testcycle))
        if testcycle is None:       # old DB, may not have one
            gsql.DB_insertLogcycle(gglobs.logConn, gglobs.logcycle)
        else:
            gglobs.logcycle = testcycle
            self.showTimingSetting(gglobs.logcycle)

        self.plotGraph("Log")
        self.checkLoggingState()
        QApplication.processEvents() # to make Normal Cursor appear only after graph shown
        self.setNormalCursor()

        debugIndent(0)


    def getCSV(self, CSV_FilePath):
        """get a csv file with option to reorder columns"""

        # colCountCSV = count(varnames) = 12 + 1 (datetime) + 1 (index) = 14
        colCountCSV = gglobs.datacolsDefault + 1            # +1 = + index

        with open(CSV_FilePath, "r") as cfghandle: # read CSV file as long str
            rlines = cfghandle.read()
            #print("rlines:", rlines)

        yourfile = QLabel("Your CSV file:")
        yourfile.setFont(QFont("Sans",14,weight=QFont.Bold))

        csv_text = QPlainTextEdit()
        csv_text.setLineWrapMode(QPlainTextEdit.NoWrap)
        csv_text.setReadOnly(True)
        csv_text.appendPlainText(rlines)
        csv_text.moveCursor(QTextCursor.Start)

        demo = \
"""
#  Index,            DateTime,      CPM,      CPS,   CPM1st,   CPS1st,   CPM2nd,   CPS2nd,   CPM3rd,   CPS3rd,     Temp,    Press,    Humid,        X
       0, 2019-01-11 19:32:14,      181,        6,      168,        5,       13,        1,       77,        3,         ,         ,         ,
       1, 2019-01-11 19:32:18,      197,        3,      172,        2,       25,        1,       64,        4,     22.3,  1014.64,     45.7,       17
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Column0,             Column1,  Column2,  Column3,  Column4,  Column5,  Column6,  Column7,  Column8,  Column9, Column10, Column11, Column12, Column13"""


        demofile = QLabel("Default Association of Column Number and Data (Example Data)")
        demofile.setFont(QFont("Sans",14,weight=QFont.Bold))

        demo_text = QPlainTextEdit()
        demo_text.setLineWrapMode(QPlainTextEdit.NoWrap)
        demo_text.setReadOnly(True)
        demo_text.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        demo_text.setVerticalScrollBarPolicy  (Qt.ScrollBarAlwaysOff)
        demo_text.setMaximumHeight(120)
        demo_text.appendPlainText(demo)
        demo_text.moveCursor(QTextCursor.Start)

        # maxCols defines how many columns the CSV file is allowed to have
        maxCols         =  22              # all cols(=14) + None + 4 spare
        selectorList    = [""]* maxCols
        selectorList[0] = "None"           #  the None column: ignore the CSV data column
        for i in range(1, maxCols):
            selectorList[i] = "CSV Column "+str(i - 1)
        #print("selectorList:", selectorList) # =['None', 'Column 0', 'Column 1', 'Column 2', ...]

        # only as may col_selectors as there are columns finally; presently = 0...13 = 14
        col_selectors = [""]* colCountCSV
        for i in range(colCountCSV):
            col_selectors[i] = QComboBox()
            col_selectors[i].setMaxVisibleItems(25)
            col_selectors[i].addItems(selectorList)
            col_selectors[i].setCurrentIndex(i + 1)
        col_selectors[1].model().item(0) .setEnabled(False)


        # layout grid
        dataOptions=QGridLayout()
        dataOptions.setColumnStretch(1,10)          # the drop-down box cols
        dataOptions.setColumnStretch(3,10)          # the drop-down box cols
        dataOptions.setContentsMargins(5,5,5,5)     # spacing around the grid
        dataOptions.setVerticalSpacing(0)           # inner spacing

        #                                                          row, col
        dataOptions.addWidget(QLabel("Index:"),                     0,   0)
        dataOptions.addWidget(col_selectors[0],                     0,   1)
        dataOptions.addWidget(QLabel("DateTime:"),                  1,   0)
        dataOptions.addWidget(col_selectors[1],                     1,   1)

        for i, vname in enumerate(gglobs.varnames):
            dataOptions.addWidget(QLabel(gglobs.vardict[vname][0] + ":"),  i+2, 0)
            dataOptions.addWidget(col_selectors[i+2],                      i+2, 1)
            if i >=5: break

        for i, vname in enumerate(gglobs.varnames):
            if i <= 5: continue
            dataOptions.addWidget(QLabel(gglobs.vardict[vname][0] + ":"),  i-6, 2)
            dataOptions.addWidget(col_selectors[i+2],                      i-6, 3)

        L0 = QLabel("Guidance:")
        L0.setFont((QFont("Sans",14,weight=QFont.Bold)))

        L5text = \
"""
- CSV file columns MUST be separated by comma
- A DateTime column MUST exist
- It is the order of the columns, which matters
- Set columns to 'None' to ignore
- Columns may be used multiple times
- Non-existing columns become 'Missing Values'
"""
        L5 = QLabel(L5text)
        L5.setFont((QFont("Sans",10,weight=QFont.Bold)))

        dial = QDialog()
        dial.setWindowIcon(self.iconGeigerLog)
        dial.setFont(self.fontstd)
        dial.setWindowTitle("Get Data from CSV File" )
        #dial.setWindowModality(Qt.ApplicationModal)
        #dial.setWindowModality(Qt.NonModal)
        dial.setWindowModality(Qt.WindowModal)
        dial.setMinimumWidth(1300)
        dial.setMinimumHeight(750)

        bbox    = QDialogButtonBox()
        bbox.setStandardButtons(QDialogButtonBox.Ok|QDialogButtonBox.Cancel)
        bbox.accepted.connect(lambda: dial.done(0))
        bbox.rejected.connect(lambda: dial.done(-1))

        layoutV2 = QVBoxLayout()
        layoutV2.addWidget(L0)
        layoutV2.addWidget(L5)
        layoutV2.addStretch()

        layoutH1 = QHBoxLayout()
        layoutH1.addLayout(layoutV2)
        layoutH1.addLayout(dataOptions)

        layoutV = QVBoxLayout(dial)            # uses dial as parent!
        layoutV.addWidget(yourfile)
        layoutV.addWidget(csv_text)
        layoutV.addWidget(demofile)
        layoutV.addWidget(demo_text)
        layoutV.addLayout(layoutH1)
        layoutV.addWidget(bbox)

        dexec = dial.exec_()
        if dexec == 0:
            gglobs.pointer = []
            for i in range(0, colCountCSV):
                gglobs.pointer.append(col_selectors[i].currentIndex() - 1) # -1 !
            return True
        else:
            gglobs.pointer = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13] # ????
            return False


#
# Show data from Log, His, and Bin files ######################################
#
    def showData(self, dataSource=None, full=True):
        """Print Log or His Data to notepad, as full file or excerpt.
        dataSource can be 'Log' or 'His' or 'HisBin' (for binary data)"""

        #print("showData start, full: ", dataSource, full)

        if gglobs.activeDataSource == None:
            self.showStatusMessage("No data available")
            return

        textprintButtonOff = "DataExcerpt"
        textprintButtonOn  = "STOP"

        # stop printing
        if self.printbutton.text() == textprintButtonOn:
            gglobs.stopPrinting = True
            return

        # switch button mode to "STOP"
        self.printbutton.setStyleSheet('QPushButton {color: blue; background-color:white; font:bold;}')
        self.printbutton.setText(textprintButtonOn)

        if   dataSource == None:
            if    gglobs.activeDataSource == "Log": dataSource = "Log"
            else:                                   dataSource = "His"

        if   dataSource == "Log":                   self.showLogData(full=full)
        elif dataSource == "His":                   self.showHisData(full=full)
        elif dataSource == "HisBin":                gsql.createLstFromDB(full=full)

        # reset button mode to "DataExcerpt"
        self.printbutton.setStyleSheet('QPushButton {}')
        self.printbutton.setText(textprintButtonOff)


    def showLogData(self, full=True):
        """ print logged data to notepad"""

        if gglobs.logConn == None:
            self.showStatusMessage("No data available")
            return

        self.setBusyCursor()

        if full:
            addp = ""
        else:
            addp = " Excerpt"
        fprint(header("Show Log Data" + addp))
        fprint("from: {}\n".format(gglobs.logDBPath))

        sql, ruler = gsql.getShowCompactDataSql(gglobs.varcheckedLog)

        fprint(ruler)

        if full:
            data = gsql.DB_readData(gglobs.logConn, sql, limit=0)
            #print("showLogData data:", data)

            counter     = 0
            batch       = 50
            printstring = ""
            gglobs.stopPrinting = False
            for a in data:
                #print("showLogData a[1]:", a[1])
                if counter == batch:
                    fprint(printstring[:-1])
                    fprint(ruler)
                    printstring = ""
                    counter     = 0
                printstring += a + "\n"
                counter     += 1
                if gglobs.stopPrinting: break
            gglobs.stopPrinting = False
            fprint(printstring[:-1])
        else:
            fprint(self.getExcerptLines(sql, gglobs.logConn))

    #        fprint(self.OLDgetExcerptLines(sql, gglobs.logConn))

        fprint(ruler)

        self.setNormalCursor()


    def showLogTags(self):
        """print comments only from log data"""

        if gglobs.logConn == None:
            self.showStatusMessage("No data available")
            return

        self.setBusyCursor()

        fprint(header("Show Log Tags and Comments"))
        fprint("from: {}\n".format(gglobs.logDBPath))

        rows = gsql.DB_readComments(gglobs.logConn)
        fprint("\n".join(rows))

        self.setNormalCursor()


    def showHisData(self, full=True):
        """print HIST parsed data"""

        if gglobs.hisConn == None:
            self.showStatusMessage("No data available")
            return

        self.setBusyCursor()

        if full:
            addp = ""
        else:
            addp = " Excerpt"
        fprint(header("Show History Data" + addp))
        fprint("from: {}\n".format(gglobs.hisDBPath))

        sql, ruler = gsql.getShowCompactDataSql(gglobs.varcheckedHis)

        fprint(ruler)

        if full:
            data = gsql.DB_readData(gglobs.hisConn, sql, limit=0)
            #print("showHisData data:", data)
            counter     = 0
            batch       = 50
            printstring = ""
            gglobs.stopPrinting = False
            for a in data:
                #print("showHisData a:", a)
                if counter == batch:
                    fprint(printstring[:-1])
                    printstring = ""
                    counter     = 0
                    fprint(ruler)
                printstring += a + "\n"
                counter     += 1
                if gglobs.stopPrinting: break
            gglobs.stopPrinting = False
            fprint(printstring[:-1])
        else:
            fprint(self.getExcerptLines(sql, gglobs.hisConn))

        fprint(ruler)

        self.setNormalCursor()


    def showHisTags(self):
        """print comments only from his data"""

        if gglobs.hisConn == None:
            self.showStatusMessage("No data available")
            return

        self.setBusyCursor()

        fprint(header("Show History Tags and Comments"))
        fprint("from: {}\n".format(gglobs.hisDBPath))

        rows = gsql.DB_readComments(gglobs.hisConn)
        fprint("\n".join(rows))

        self.setNormalCursor()


    def getExcerptLines(self, sql, DB_Conn, lmax=12):
        """get first and last lines from the db"""

        if DB_Conn == None:  return ""

        #start=time.time()

        excLines  = gsql.DB_readData(DB_Conn, sql, limit=lmax)
        lenall    = len(excLines)
        if lenall == 0:      return ""      # no data

        plines = ""
        if lenall < lmax * 2:
            for i in range(0, int(lenall/2)):   plines += excLines[i] + "\n"

        else:
            for a in excLines[0:lmax]:          plines += a + "\n"
            plines +=                                     "     ...\n"
            for a in excLines[-lmax:]:          plines += a + "\n"

        #print("new getExcerptLines:", (time.time()-start)*1000)

        return plines[:-1] # remove "\n"


    def OLDgetExcerptLines(self, sql, DB_Conn, lmax=12):
        """get first and last lines from the db"""

        if DB_Conn == None:  return ""


        start=time.time()

        if lmax == 0:
            excLines  = gsql.oldDB_readData(DB_Conn, sql)
        else:
            excLines  = gsql.oldDB_readData(DB_Conn, sql, limit = lmax)
            excLines += gsql.oldDB_readData(DB_Conn, sql, limit = -lmax)
        #print("excLines:", excLines)
        lenall    = len(excLines)

        if lenall == 0:      return ""

        plines = ""
        if lenall < lmax * 2:
            for i in range(0, int(lenall/2)):   plines += excLines[i] + "\n"

        else:
            for a in excLines[0:lmax]:          plines += a + "\n"
            plines +=                                     "     ...\n"
            for a in excLines[-lmax:]:          plines += a + "\n"

        print("old getExcerptLines:", (time.time()-start)*1000)

        return plines[:-1] # remove "\n"


#device
    def doREBOOT(self):
        """reboot the GMC device"""

        msg = QMessageBox()
        msg.setWindowIcon(self.iconGeigerLog)
        msg.setIcon(QMessageBox.Warning)
        msg.setWindowTitle("Reboot GMC Device")
        msg.setText("Rebooting your GMC device.\nPlease confirm with OK, or Cancel")
        msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Cancel)
        msg.setEscapeButton(QMessageBox.Cancel)
        retval = msg.exec_()

        if retval != 1024:   return

        fprint(header("GMC Device Reboot"))
        rec, err, errmessage = gcommands.setREBOOT()
        if err == 0 or err == 1:
            fprint("REBOOT completed")
        else:
            fprint("ERROR in doREBOOT: " + errmessage)


    def doFACTORYRESET(self):
        """Does a FACTORYRESET of the GMC device"""

        d = QInputDialog()
        d.setWindowIcon(self.iconGeigerLog)
        warning ="""
CAUTION - You are about to reset the GMC device to factory condition!
All data and your changes of settings will be lost. \n
If you want to proceed, enter the word 'FACTORYRESET' (in all capital)
and press OK"""

        text, ok = d.getText(self, 'FACTORYRESET', warning)

        vprint("Factory Reset:", "text=", text, ",  ok=", ok)
        if ok:
            fprint(header("GMC Device FACTORYRESET"))
            if text == "FACTORYRESET":
                rec, err, errmessage = gcommands.setFACTORYRESET()
                if err == 0 or err == 1: fprint("FACTORYRESET completed")
                else:                    fprint("ERROR in doFACTORYRESET: " + message)
            else:
                fprint("Entry '{}' not matching 'FACTORYRESET' - Reset NOT done".format(text))


    def setCalibrationFactors(self):
        """Set calibrations for all tubes temporarily"""

        #
        # setting the scaling factor (needed if no device connected)
        #
        if gglobs.calibration    == "auto":  scale1st = gglobs.DefaultCalibration1st
        else:                                scale1st = gglobs.calibration

        if gglobs.calibration2nd == "auto":  scale2nd = gglobs.DefaultCalibration2nd
        else:                                scale2nd = gglobs.calibration2nd

        if gglobs.Calibration3rd  == "auto":  scaleRM  = gglobs.DefaultCalibration3rd
        else:                                scaleRM  = gglobs.Calibration3rd

        dprint("setCalibrationFactors:")
        debugIndent(1)

        # Comment
        c = """Allows to set the Calibrations
for all tubes temporarily for this program
run. For permanent change edit the GeigerLog
configuration file geigerlog.cfg.\n
Numbers are in units of µSv/h/CPM.\n"""
        lcomment        = QLabel(c)

        # GMC 1st tube
        ltubeGMC1st     = QLabel("1st tube")
        ltubeGMC1st.setAlignment(Qt.AlignLeft)
        self.tubeGMC1st  = QLineEdit()
        #validator = QDoubleValidator(0, 999, 1, self.tubeGMC1st)
        #self.tubeGMC1st.setValidator(validator)
        self.tubeGMC1st.setToolTip('Code: M1')
        self.tubeGMC1st.setText("{:0.6g}".format(scale1st))

        # GMC 2nd tube
        ltubeGMC2nd     = QLabel("2nd tube")
        ltubeGMC2nd.setAlignment(Qt.AlignLeft)
        self.tubeGMC2nd  = QLineEdit()
        #validator = QDoubleValidator(0, 999, 1, self.tubeGMC2nd)
        #self.tubeGMC2nd.setValidator(validator)
        self.tubeGMC2nd.setToolTip('Code: M2')
        self.tubeGMC2nd.setText("{:0.6g}".format(scale2nd))

        # RM tube
        ltubeRM     = QLabel("R tube")
        ltubeRM.setAlignment(Qt.AlignLeft)
        self.tubeRM  = QLineEdit()
        #validator = QDoubleValidator(0, 99999, 1, self.tubeRM)
        #self.tubeRM.setValidator(validator)
        self.tubeRM.setToolTip('Code: R')
        self.tubeRM.setText("{:0.6g}".format(scaleRM))

        graphOptions=QGridLayout()
        graphOptions.addWidget(lcomment,              0, 0, 1, 2)
        graphOptions.addWidget(ltubeGMC1st,           1, 0)
        graphOptions.addWidget(self.tubeGMC1st,       1, 1)
        graphOptions.addWidget(ltubeGMC2nd,           2, 0)
        graphOptions.addWidget(self.tubeGMC2nd,       2, 1)
        graphOptions.addWidget(ltubeRM,               3, 0)
        graphOptions.addWidget(self.tubeRM,           3, 1)

        graphOptionsGroup = QGroupBox()
        graphOptionsGroup.setLayout(graphOptions)

        # Dialog box
        d = QDialog(self) # set parent self to popup in center of geigerlog window
        d.setWindowIcon(self.iconGeigerLog)
        d.setFont(self.fontstd)
        d.setWindowTitle("Set Calibrations")
        #d.setWindowModality(Qt.ApplicationModal)   #all of them block other actions???
        #d.setWindowModality(Qt.NonModal)
        #d.setWindowModality(Qt.WindowModal)
        #d.setModal(False)

        # Buttons
        self.bbox = QDialogButtonBox()
        self.bbox.setStandardButtons(QDialogButtonBox.Cancel | QDialogButtonBox.Ok )
        self.bbox.accepted.connect(lambda: d.done(0))
        self.bbox.rejected.connect(lambda: d.done(99))

        gglobs.btn = self.bbox.button(QDialogButtonBox.Ok)
        gglobs.btn.setEnabled(True)

        layoutV = QVBoxLayout(d)
        layoutV.addWidget(graphOptionsGroup)
        layoutV.addWidget(self.bbox)


        retval = d.exec_()
        #print("reval:", retval)

        if retval == 99:
            # ESCAPE pressed
            dprint("setCalibrationFactors: ESCAPE pressed, Calibrations unchanged: ")

        else:
            # OK pressed

            # change the calibration 1st tube
            gglobs.calibration    = float(self.tubeGMC1st.text().replace(",", ".")) #replace comma with dot
            # change the calibration 2nd tube
            gglobs.calibration2nd = float(self.tubeGMC2nd.text().replace(",", ".")) #replace comma with dot
            # change the calibration R tube
            gglobs.Calibration3rd  = float(self.tubeRM.text().replace(",", "."))     #replace comma with dot

            gplot.makePlot()

            dprint("setCalibrationFactors: GMC Devise 1st tube: "    , gglobs.calibration)
            dprint("setCalibrationFactors: GMC Devise 2nd tube: "    , gglobs.calibration2nd)
            dprint("setCalibrationFactors: RadMon+ Device tube: "    , gglobs.Calibration3rd)

            fprint(header("Set Calibrations"))
            fprint("GMC Devise 1st tube:", "{}" .format(gglobs.calibration))
            fprint("GMC Devise 2nd tube:", "{}" .format(gglobs.calibration2nd))
            fprint("RadMon+ Device tube:", "{}" .format(gglobs.Calibration3rd))

        debugIndent(0)


    def doI2CReset(self):
        """Reset the ELV dongle and sensors"""

        fprint(header("Resetting I2C System"))
        self.setBusyCursor()
        fprint("Waiting ...")
        QApplication.processEvents()

        gi2c.resetI2C()
        self.setNormalCursor()


    def showDeviceMappings(self):
        """Shows active devices and variables mapped to them and alerts on
        variables being mapped to more than one device"""

        fprint(header("Device Mappings"))

        if gglobs.DevicesConnected == 0:
            fprint("Unknown until a connection is made. Use menu: Device -> Connect Devices")
            return

        fprint("The configuration is determined in the configuration file geigerlog.cfg. ")

        mapflag = False
        for vname in gglobs.varnames:
            if gglobs.varMap[vname] > 1:
                if mapflag == False:    # print only on first occurence
                    efprint("ALERT: Mapping problem of Variables")
                qefprint("Variable {} is mapped to more than one device".format(vname))
                mapflag = True

        dline = "{:9s}:  {:3s} {:3s} {:6s} {:6s} {:6s} {:6s} {:6s} {:6s} {:3s} {:3s} {:3s} {:3s}"
        fprint("\n" + dline.format("Device", *gglobs.varnames))
        fprint("-" * 76)
        for devname in gglobs.DevicesNames:
            checks = []
            if gglobs.DevicesVars[devname] != None:
                checks.append(devname)
                for vname in gglobs.varnames:
                    if vname in gglobs.DevicesVars[devname]:
                        checks.append("X")
                    else:
                        checks.append("-")
                fprint(dline.format(*checks))

        if mapflag:
            qefprint("Measurements are made on devices from top to bottom, and for each from left to ")
            qefprint("right. If double-mapping of variables occurs, then the last measured variable")
            qefprint(" will overwrite the previous one, almost always resulting in useless data.")
        else:
            fprint("Mapping is valid; no problems found")


    def toggleDeviceConnection(self):
        """if no connection exists, then make connection else disconnect"""

        if gglobs.logging:
            self.showStatusMessage("Cannot change when logging! Stop logging first")
            return

        if gglobs.DevicesConnected == 0:
        #if gglobs.ser == None and gglobs.rm_client == None and gglobs.LJConnection == False:
            self.switchConnections(new_connection = "ON")
        else:
            self.switchConnections(new_connection = "OFF")


    def switchConnections(self, new_connection = "ON"):
        """
        if new_connection = ON and no connection exists, then try to make
        connection (with verification of communication with device)
        else disconnect (unless already disconnected)
        """

        if gglobs.logging:
            self.showStatusMessage("Cannot change when logging! Stop logging first")
            return

        dprint("switchConnections: --> {}. ".format(new_connection))
        debugIndent(1)
        self.setBusyCursor()

        # try so make all connections or disconnections
        self.switchGMC_Connection    (new_connection=new_connection)    # GMC
        self.switchAudio_Connection  (new_connection=new_connection)    # Audio
        self.switchI2C_Connection    (new_connection=new_connection)    # I2C
        self.switchRM_Connection     (new_connection=new_connection)    # RadMon
        self.switchAmbio_Connection  (new_connection=new_connection)    # AmbioMon
        self.switchLJ_Connection     (new_connection=new_connection)    # LabJack

        # count the connected (not just activated!) devices;
        # after disconnections, all should be false
        gglobs.DevicesConnected = 0
        if gglobs.GMCConnection   :      gglobs.DevicesConnected += 1
        if gglobs.AudioConnection :      gglobs.DevicesConnected += 1
        if gglobs.I2CConnection   :      gglobs.DevicesConnected += 1
        if gglobs.RMConnection    :      gglobs.DevicesConnected += 1
        if gglobs.AmbioConnection :      gglobs.DevicesConnected += 1
        if gglobs.LJConnection    :      gglobs.DevicesConnected += 1

        if gglobs.DevicesConnected > 0: # at least 1 needed to show a closed plug
            self.toggleDeviceConnectionAction.setIcon(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_closed.png'))))
        else:
            self.toggleDeviceConnectionAction.setIcon(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_open.png'))))

        if gglobs.werbose:
            print("switchConnections:", "Connection Status:" )
            print("- gglobs.GMCConnection:    ", gglobs.GMCConnection)
            print("- gglobs.AudioConnection:  ", gglobs.AudioConnection)
            print("- gglobs.I2CConnection     ", gglobs.I2CConnection)
            print("- gglobs.RMConnection:     ", gglobs.RMConnection)
            print("- gglobs.AmbioConnection:  ", gglobs.AmbioConnection)
            print("- gglobs.LJConnection:     ", gglobs.LJConnection)
            print("- gglobs.DevicesConnected: ", gglobs.DevicesConnected)


        if new_connection == "ON":
            gglobs.textDevVars     = ""
            gglobs.activeVariables = 0
            gglobs.varMap          = {}      # holds the mapping of variables
            for vname in gglobs.varnames:    gglobs.varMap[vname] = 0

            for devname in gglobs.DevicesNames:
                #print("switchConnections: devname:", devname)
                if gglobs.DevicesVars[devname] != None:
                    gglobs.textDevVars              += "{}(".format(devname)
                    for vname in gglobs.DevicesVars[devname]:
                        #print("                  : vname:", vname)
                        gglobs.varMap[vname]        += 1
                        gglobs.activeVariables      += 1
                        gglobs.textDevVars          += " {}".format(vname)
                        gglobs.loggableVars[vname]   = True
                    gglobs.textDevVars += " ); "

            if gglobs.werbose:
                print("- activeVariables:         ", gglobs.activeVariables)
                print("- textDevVars:             ", gglobs.textDevVars)
                print("- gglobs.loggableVars:", getOrderedVars(gglobs.loggableVars))

            if gglobs.activeVariables == 0:
                qefprint("<br>ALERT: No variables for logging available; Logging will not be possible!")
                efprint("Please check configuration!")

            self.showDeviceMappings()

        self.checkLoggingState()
        self.notePad.setFocus() # to avoid having any device buttons in blue
        debugIndent(0)
        self.setNormalCursor()


    def switchGMC_Connection(self, new_connection = "ON"):
        """GMC connections"""

        if not gglobs.GMCActivation: return

        fncname = "switchGMC_Connection: "

        dprint(fncname + "--> {}. ".format(new_connection))
        debugIndent(1)

        self.setBusyCursor()

        if new_connection == "ON":
            if gglobs.GMCConnection:
                fprint(header("Connect GMC Device"), debug=True)
                fprint("GMC Device is already connected")
            else:
                quickbaudrate = gcommands.GMCquickPortTest(gglobs.usbport)
                #print("quickbaudrate:", quickbaudrate, type(quickbaudrate))
                #print("gglobs.baudrate:", gglobs.baudrate, type(gglobs.baudrate))
                if quickbaudrate > 0:
                    if int(gglobs.baudrate) != int(quickbaudrate):
                        efprint(header("Connect GMC Device"))
                        qefprint("The configured baudrate {} does not match the detected baudrate {}.".format(gglobs.baudrate, quickbaudrate))
                        qefprint("Now switching configuration temporarily to detected baudrate {}.".format(quickbaudrate))
                        qefprint("It is recommended to change the baudrate in the configuration file accordingly")
                        gglobs.baudrate = quickbaudrate
                else:
                    dprint(fncname + "Failure with GMCquickPortTest, got quickbaudrate={} ".format(quickbaudrate))

                # try to open the port; this is the ONLY place calling initGMC!
                # on errors gglobs.ser is None and gglobs.GMCConnection is false
                # otherwise, device is connected, and communication had been verified with getVER()
                errmessage = gcommands.initGMC()
                if gglobs.GMCConnection:
                    self.dbtnGMC.setStyleSheet(self.dbtnStyleSheetON)
                    self.setEnableDeviceActions(new_enable = True)
                    self.dbtnGMCPower.setEnabled(True)
                    gcommands.getDeviceProperties()
                    self.printGMCDevInfo()

                    if gglobs.cfg == None or len(gglobs.cfg) != gglobs.configsize:
                        efprint("Could not read device configuration correctly")
                        efprint("Configuration dependent commands in menu Device are being inactivated!")
                        self.setDisableDeviceActions()

                    PowerState = gcommands.isPowerOn()
                    if PowerState == "ON":
                        self.dbtnGMCPower.setIcon(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_power-round_on.png'))))
                    elif PowerState == "OFF":
                        self.dbtnGMCPower.setIcon(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_power-round_off.png'))))
                    else:
                        self.dbtnGMCPower.setEnabled(False)
                    dprint(fncname + "ON: for device: {}".format(gglobs.deviceDetected))

                else:
                    efprint(header("Connect GMC Device"))
                    qefprint("Failure to connect with device: ", "{} with message:<br>{}".format(gglobs.GMCDeviceName, errmessage))
                    self.dbtnGMC.setText(self.connectTextGMC)
                    self.dbtnGMC.setStyleSheet(self.dbtnStyleSheetError)
                    fprint("<br>If you know that a GMC device is connected:<br>\
                            - Run 'Help'->'Show & Select USB Port and Baudrate', identify and select settings<br>\
                            - or: Run 'USB Autodiscovery' from menu Help and check for proper port and baudrate<br>\
                            - Look into topic: 'Help'->'Devices` Firmware Bugs' for bugs and workarounds.", error=True, errsound=False)

                dprint(fncname + str(self.getGMCDeviceHistSaveMode()))

        else: # new_connection == OFF
            fprint(header("Disconnect GMC Device"))
            if not gglobs.GMCConnection:
                fprint("No connected GMC Device")
                self.dbtnGMC.setStyleSheet(self.dbtnStyleSheetOFF)
                PowerState = gcommands.isPowerOn()
            else:
                gcommands.terminateGMC()
                gglobs.cfg = None
                self.setEnableDeviceActions(new_enable = False)
                fprint("Disconnected successfully:", "{}".format(gglobs.deviceDetected), debug=True)

            self.dbtnGMCPower.setEnabled(False)
            self.dbtnGMC.setStyleSheet(self.dbtnStyleSheetOFF)
            dprint(fncname + self.getGMCDeviceHistSaveMode())

        debugIndent(0)
        self.setNormalCursor()


    def switchAudio_Connection(self, new_connection = "ON"):
        """AudioCounter connections"""

        if not gglobs.AudioActivation:  return

        fncname = "switchAudio_Connection: "

        dprint(fncname + "--> {}. ".format(new_connection))
        debugIndent(1)

        self.setBusyCursor()

        if new_connection == "ON":
            errmsg = gaudio.initAudio() # so far there is never an error in audio
            if gglobs.AudioConnection:
                # successful connect
                self.dbtnAudio.setStyleSheet(self.dbtnStyleSheetON)
                self.printAudioDevInfo()
                dprint(fncname + "ON: for device: {}".format(gglobs.AudioDeviceName))
                self.AudioInfoActionExt.setEnabled(True)      # enable extended info
                self.AudioSwitchAction.setEnabled(True)       # enable audio toggle
                #self.AudioPulseDirAction.setEnabled(True)     # enable pulse direction toggle
                self.AudioPlotAction.setEnabled(True)         # enable audio plotting
            else:
                # failure in connection
                efprint(header("Connect AudioCounter Device"))
                qefprint("Failure to connect with Device:", "{}".format(gglobs.AudioDeviceName))
                self.dbtnGMC.setStyleSheet(self.dbtnStyleSheetError)

        else: # new_connection == OFF
            fprint(header("Disconnect AudioCounter Device"))
            if gglobs.AudioConnection:
                gaudio.terminateAudio()
                if not gglobs.AudioConnection:
                    # successful dis-connect
                    self.AudioInfoActionExt.setEnabled(False)    # disable extended info
                    self.AudioSwitchAction.setEnabled(False)     # disable audio on/off
                    #self.AudioPulseDirAction.setEnabled(False)   # enable pulse direction toggle
                    self.AudioPlotAction.setEnabled(False)       # disable audio plotting
                    fprint("Disconnected successfully:", "{}".format(gglobs.AudioDeviceName), debug=True)
                else:
                    fprint("Disconnection Error with Device:", gglobs.AudioDeviceName)
            else:
                fprint("No connected device")
            self.dbtnAudio.setStyleSheet(self.dbtnStyleSheetOFF)

        self.setNormalCursor()
        debugIndent(0)


    def switchI2C_Connection(self, new_connection = "ON"):
        """I2C connections"""

        if not gglobs.I2CActivation:  return

        fncname = "switchI2C_Connection: "

        dprint(fncname + "--> {}. ".format(new_connection))
        debugIndent(1)

        self.setBusyCursor()

        if new_connection == "ON":
            errmsg = gi2c.initI2C()
            if gglobs.I2CConnection:
                # successful connect
                self.dbtnI2C.setStyleSheet(self.dbtnStyleSheetON)
                self.printI2CDevInfo()
                dprint(fncname + "ON: for device: {}".format(gglobs.I2CDeviceName))
                self.I2CInfoActionExt.setEnabled(True)      # enable extended info
                self.I2CResetAction.setEnabled(True)        # enable reset
            else:
                # failure in connection
                efprint(header("Connect I2C Device"))
                qefprint("Failure to connect with device: ", "{} with message:<br>{}".format(gglobs.I2CDeviceName, errmsg))
                self.dbtnI2C.setStyleSheet(self.dbtnStyleSheetError)

        else: # new_connection == OFF
            fprint(header("Disconnect I2C Device"))
            if gglobs.I2CConnection:
                errmsg = gi2c.terminateI2C()
                if not gglobs.I2CConnection:
                    # successful dis-connect
                    self.I2CInfoActionExt.setEnabled(False)    # disable extended info
                    self.I2CResetAction.setEnabled(False)      # disable reset
                    fprint("Disconnected successfully:", "{}".format(gglobs.I2CDeviceName), debug=True)
                else:
                    efprint("Disconnection Error with Device: {} with message:<br>{}".format(gglobs.I2CDeviceName, errmsg))
            else:
                fprint("No connected device")
            self.dbtnI2C.setStyleSheet(self.dbtnStyleSheetOFF)

        self.setNormalCursor()
        debugIndent(0)


    def switchRM_Connection(self, new_connection = "ON"):
        """RadMon connections"""

        if not gglobs.RMActivation: return

        fncname = "switchRM_Connection: "

        dprint(fncname + "--> {}. ".format(new_connection))
        debugIndent(1)

        self.setBusyCursor()

        if new_connection == "ON":
            #fprint(header("Connect RadMon Device"))
            errmsg = gradmon.initRadMon()
            if gglobs.RMConnection:
                # successful connect
                self.dbtnRM.setStyleSheet(self.dbtnStyleSheetON)
                self.printRMDevInfo()
                dprint(fncname + "ON: for device: {} with message: {}".format("RadMon+", gglobs.RMconnect[1]))
                self.RMInfoActionExt.setEnabled(True)       # enable extended info
            else:
                # failure in connection
                efprint(header("Connect RadMon Device"))
                qefprint("Failure to connect with device: {} {}".format(gglobs.RMDeviceName, errmsg))
                self.dbtnRM.setStyleSheet(self.dbtnStyleSheetError)

        else: # new_connection == OFF
            fprint(header("Disconnect RadMon Device"))
            if gglobs.RMConnection:
                gradmon.terminateRadMon()
                if not gglobs.RMConnection:
                    # successful dis-connect
                    self.RMInfoActionExt.setEnabled(False)       # disable extended info
                    fprint("Disconnected successfully:", "{}".format(gglobs.RMDeviceName), debug=True)
                else:
                    # failure in disconnect
                    fprint("Disconnection Error with Device:", gglobs.RMDeviceName)
                    fprint("", gglobs.RMdisconnect[1])
            else:
                fprint("No connected device")
            self.dbtnRM.setStyleSheet(self.dbtnStyleSheetOFF)

        self.setNormalCursor()
        debugIndent(0)


    def switchAmbio_Connection(self, new_connection = "ON"):
        """AmbioMon connections"""

        if not gglobs.AmbioActivation: return

        fncname = "switchAmbio_Connection: "

        dprint(fncname + "--> {}. ".format(new_connection))
        debugIndent(1)

        self.setBusyCursor()

        if new_connection == "ON":
            #fprint(header("Connect AmbioMon Device"))
            errmsg = gambiomon.initAmbioMon()
            if gglobs.AmbioConnection:
                # successful connect
                self.dbtnAmbio.setStyleSheet(self.dbtnStyleSheetON)
                self.printAmbioDevInfo()
                dprint(fncname + "ON: for device: {} with message: {}".format("AmbioMon", gglobs.AmbioConnect[1]))
                self.AmbioInfoActionExt.setEnabled(True)       # enable extended info
            else:
                # failure in connection
                efprint(header("Connect AmbioMon Device"))
                qefprint("Failure to connect with device: {} {}".format(gglobs.AmbioDeviceName, errmsg))
                self.dbtnAmbio.setStyleSheet(self.dbtnStyleSheetError)

        else: # new_connection == OFF
            fprint(header("Disconnect AmbioMon Device"))
            if gglobs.AmbioConnection:
                gambiomon.terminateAmbioMon()
                if not gglobs.AmbioConnection:
                    # successful dis-connect
                    self.AmbioInfoActionExt.setEnabled(False)       # enable extended info
                    fprint("Disconnected successfully:", "{}".format(gglobs.AmbioDeviceName), debug=True)
                else:
                    fprint("Disconnection Error with Device:", "AmbioMon+")
                    fprint("", gglobs.AmbioDisconnect[1])
            else:
                fprint("No connected device")
            self.dbtnAmbio.setStyleSheet(self.dbtnStyleSheetOFF)

        self.setNormalCursor()
        debugIndent(0)


    def switchLJ_Connection(self, new_connection = "ON"):
        """LabJack connections"""

        if not gglobs.LJActivation:  return

        fncname = "switchLJ_Connection: "

        dprint(fncname + "--> {}. ".format(new_connection))
        debugIndent(1)

        self.setBusyCursor()

        if new_connection == "ON":
            errmsg = glabjack.initLabJack()
            if gglobs.LJConnection:
                # successful connect
                self.dbtnLJ.setStyleSheet(self.dbtnStyleSheetON)
                self.printLJDevInfo()
                dprint(fncname + "ON: for device: {}".format(gglobs.LJDeviceName))
                self.LJInfoActionExt.setEnabled(True)       # enable extended info
            else:
                # failure in connection
                efprint(header("Connect LabJack Device"))
                qefprint("Failure to connect with device: {} with message:<br>{}".format(gglobs.LJDeviceName, errmsg))
                self.dbtnLJ.setStyleSheet(self.dbtnStyleSheetError)

        else: # new_connection == OFF
            fprint(header("Disconnect LabJack Device"))
            if gglobs.LJConnection:
                glabjack.terminateLabJack()
                if not gglobs.LJConnection:
                    # successful dis-connect
                    fprint("Disconnected successfully:", "{}".format(gglobs.LJDeviceName), debug=True)
                else:
                    # failure in dis-connection
                    fprint("Disconnection error with device:", gglobs.LJDeviceName)
            else:
                fprint("No connected device")
            self.dbtnLJ.setStyleSheet(self.dbtnStyleSheetOFF)

        self.setNormalCursor()
        debugIndent(0)


    def checkLoggingState(self):
        """some cleanup of status"""

        # GMC Device
        if not gglobs.GMCConnection:
            self.startloggingAction.    setEnabled(False)
            self.stoploggingAction.     setEnabled(False)
            self.quickLogAction.        setEnabled(False)
            self.histDeviceAction.      setEnabled(False)
            self.logSnapAction.         setEnabled(False)

        else:
            if gcommands.isPowerOn() != "OFF": # is ON or undefined
                self.quickLogAction.    setEnabled(True)
                if gglobs.logDBPath != None : self.startloggingAction.setEnabled(True)
            else:
                self.quickLogAction.    setEnabled(False)
                self.startloggingAction.setEnabled(False)
            self.histDeviceAction.      setEnabled(True)


        if gglobs.DevicesConnected > 0: # at least 1 device is available
            self.quickLogAction.        setEnabled(True)
            if gglobs.logDBPath != None : self.startloggingAction.setEnabled(True)

        # Logging
        if gglobs.logging:
            self.histDeviceAction.      setEnabled(False)
            self.logLoadFileAction.     setEnabled(False)
            self.startloggingAction.    setEnabled(False)
            self.quickLogAction.        setEnabled(False)

            self.stoploggingAction.     setEnabled(True)
            self.WebAction.             setEnabled(True)
            self.logSnapAction.         setEnabled(True)
        else:
            self.stoploggingAction.     setEnabled(False)
            self.WebAction.             setEnabled(False)
            self.logSnapAction.         setEnabled(False)
            self.logLoadFileAction.     setEnabled(True)

        if gglobs.logDBPath != None:
            self.addCommentAction.      setEnabled(True)
        else:
            self.addCommentAction.      setEnabled(False)

        if gglobs.hisDBPath != None:
            self.addHisCommentAction.   setEnabled(True)
        else:
            self.addHisCommentAction.   setEnabled(False)


    def setEnableDeviceActions(self, new_enable = True):

        # Device
        self.DeviceConnectAction.       setEnabled(not new_enable)
        self.DeviceDisconnectAction.    setEnabled(new_enable)
        self.setLogTimingAction.        setEnabled(new_enable)

        # submenu GMC
        self.DeviceInfoAction.          setEnabled(new_enable)
        self.DeviceConfigAction.        setEnabled(new_enable)
        self.DeviceONAction.            setEnabled(new_enable)
        self.DeviceOFFAction.           setEnabled(new_enable)
        self.DeviceSetTimeAction.       setEnabled(new_enable)
        self.DeviceREBOOTAction.        setEnabled(new_enable)
        self.DeviceFACTORYRESETAction.  setEnabled(new_enable)

        # GMC Device functions using the config
        self.DeviceSpeakerONAction.     setEnabled(new_enable)
        self.DeviceSpeakerOFFAction.    setEnabled(new_enable)
        self.DeviceAlarmONAction.       setEnabled(new_enable)
        self.DeviceAlarmOFFAction.      setEnabled(new_enable)
        self.DeviceSavingStateAction.   setEnabled(new_enable)
        self.btnHistSaveMode.           setEnabled(new_enable)

        # submenu RadMon
        #self.RMConfigAction.            setEnabled(new_enable)

        # submenu AmbioMon
        self.AmbioConfigAction.         setEnabled(new_enable)

        #toolbar GMC Power Toggle
        self.dbtnGMCPower.              setEnabled(False)

        # History
        self.histDeviceAction.          setEnabled(new_enable)


    def setDisableDeviceActions(self):

        # when config is not usable
        self.DeviceSpeakerONAction.     setEnabled(False)
        self.DeviceSpeakerOFFAction.    setEnabled(False)
        self.DeviceAlarmONAction.       setEnabled(False)
        self.DeviceAlarmOFFAction.      setEnabled(False)
        self.DeviceSavingStateAction.   setEnabled(False)


    def toggleGMCPower(self):
        """Toggle GMC device Power ON / OFF"""

        if gglobs.logging:
            self.showStatusMessage("Cannot change when logging! Stop logging first")
            return

        if gcommands.isPowerOn() == "ON": self.switchGMCPower("OFF")
        else:                             self.switchGMCPower("ON")


    def switchGMCPower(self, newstate = "ON"):
        """Switch power of GMC device to ON or OFF"""

        debugIndent(1)

        fprint(header("Switch GMC Device Power {}".format(newstate)), debug=True)

        self.setBusyCursor()
        if newstate == "ON":
            if gcommands.isPowerOn() != "ON":
                gcommands.setPOWERON()
                time.sleep(3) # takes some time to settle!
        else:
            if gcommands.isPowerOn() == "ON":
                if gglobs.logging: self.stopLogging()
                gcommands.setPOWEROFF()
                time.sleep(3) # takes some time to settle!

        cfg, error, errmessage     = gcommands.getCFG()     # read config after power change
        gglobs.cfg = cfg

        ipo = gcommands.isPowerOn()
        fprint("Power State of GMC device is: ",  ipo)

        if   ipo == "ON":
            self.dbtnGMCPower.setIcon(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_power-round_on.png'))))
        elif ipo == "OFF":
            self.dbtnGMCPower.setIcon(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_power-round_off.png'))))
        else:
            self.dbtnGMCPower.setIcon(QIcon(QPixmap(os.path.join(gglobs.gresPath, 'icon_power-round_on.png'))))

        self.checkLoggingState()
        self.setNormalCursor()
        debugIndent(0)


    def printGMCDevInfo(self, extended = False):
        """prints basic or extended info on the GMC device"""

        self.setBusyCursor()

        txt = "GMC Device Info"
        if extended:  txt += " Extended"
        fprint(header(txt))

        fprint("Configured Connection:", "port:'{}' baudrate:{} timeout:{}s timeoutWrite:{}s".\
                         format(gglobs.usbport, gglobs.baudrate, gglobs.timeout, gglobs.timeout_write))

        gcommands.fprintDeviceInfo(extended = extended)

        self.setNormalCursor()


    def printRMDevInfo(self, extended=False):
        """prints basic info on the RadMon device"""

        self.setBusyCursor()

        txt = "RadMon Device Info"
        if extended:  txt += " Extended"
        fprint(header(txt))
        fprint("Configured Connection:", "MQTT on {}:{} topic:{}".format(gglobs.RMServerIP, gglobs.RMServerPort, gglobs.RMServerFolder))
        fprint(gradmon.getRadMonInfo(extended=extended))

        self.setNormalCursor()


    def printAmbioDevInfo(self, extended=False):
        """prints basic info on the AmbioMon device"""

        self.setBusyCursor()

        txt = "AmbioMon Device Info"
        if extended:  txt += " Extended"
        fprint(header(txt))
        fprint("Configured Connection:", "MQTT on {}:{} topic:{}".format(gglobs.AmbioServerIP, gglobs.AmbioServerPort, gglobs.AmbioServerFolder))
        fprint(gambiomon.getAmbioMonInfo(extended=extended))

        self.setNormalCursor()


    def printLJDevInfo(self, extended=False):
        """prints basic info on the LabJack device"""

        self.setBusyCursor()

        txt = "LabJack Device Info"
        if extended:  txt += " Extended"
        fprint(header(txt))
        fprint("Configured Connection:", "USB (auto-configuration)")
        fprint(glabjack.getLabJackInfo(extended=extended))

        self.setNormalCursor()


    def printAudioDevInfo(self, extended=False):
        """prints basic info on the AudioCounter device"""

        self.setBusyCursor()

        txt = "AudioCounter Device Info"
        if extended:  txt += " Extended"
        fprint(header(txt))

        fprint("Configured Connection:", "Default Audio Input")

        fprint(gaudio.getAudioInfo(extended=extended))

        self.setNormalCursor()


    def printI2CDevInfo(self, extended=False):
        """prints basic info on the I2C device"""

        self.setBusyCursor()

        txt = "I2CSensors Device Info"
        if extended:  txt += " Extended"
        fprint(header(txt))

        fprint("Configured Connection:", "port:'{}' baudrate:{} timeout:{}s timeoutWrite:{}s".\
                         format(gglobs.I2Cusbport, gglobs.I2Cbaudrate, gglobs.I2Ctimeout, gglobs.I2Ctimeout_write))

        rinfo = gi2c.getI2CInfo(extended=extended)
        #fprint(gi2c.getI2CInfo(extended=extended))
        #fprint("Connected Device ", rinfo)
        fprint(rinfo)
        self.setNormalCursor()


    def printGMCDevConfig(self):
        """prints the 256 or 512 bytes of device configuration"""

        dprint("printGMCDevConfig: ")
        debugIndent(1)

        self.setBusyCursor()

        fprint(header("GMC Device Configuration"))
        pdc = gcommands.ftextCFG()
        fprint(pdc)
        dprint("printGMCDevConfig:\n" + pdc)

        self.setNormalCursor()

        debugIndent(0)


    def setGMCDeviceDateTime(self):
        """ set date and time on GMC device to computer date and time"""

        dprint("setGMCDeviceDateTime:")
        debugIndent(1)

        fprint(header("Set Date&Time of GMC Device"))
        rec, error, errmessage = gcommands.getDATETIME()
        if error < 0:
            fprint("Communication problem with device:", errmessage)

            fprint("Trying to force setting Date&Time")
            gcommands.setDATETIME()

            rec, error, errmessage = gcommands.getDATETIME()
            deviceTime = str(rec)
            fprint("New Date and Time from device is:", str(deviceTime))

        else:
            computerTime = stime()
            deviceTime   = str(rec)
            deltat       = datestr2num(computerTime) - datestr2num(deviceTime)
            if deltat == 0:
                dtxt = "Device time is same as computer time"
            elif deltat > 0:
                dtxt = "Device is slower than computer by {:0.1f} sec".format(deltat)
            else:
                dtxt = "Device is faster than computer by {:0.1f} sec".format(abs(deltat))

            fprint("Date and Time from device is:", deviceTime)
            fprint("Date and Time from computer is:", "{}".format(computerTime))
            fprint("", "{}\n".format(dtxt))

            fprint("Setting device time to computer time")
            gcommands.setDATETIME()

            rec, error, errmessage = gcommands.getDATETIME()
            deviceTime = str(rec)
            fprint("New Date and Time from device is:", str(deviceTime))


        debugIndent(0)


    def setGMCDeviceHistSaveMode(self):
        """sets the History Saving Mode"""

        dprint("setGMCDeviceHistSaveMode:")
        debugIndent(1)

        while True:
            # get current config
            cfg, error, errmessage = gcommands.getCFG()
            gglobs.cfg = cfg
            if error < 0:
                fprint("Error:" + errmessage)
                break

            SDT, SDTtxt = gcommands.getSaveDataType()
            gglobs.savedatatype = SDTtxt

            # setup dialog and get new config setting
            selection   = gglobs.savedatatypes
            text, ok    = QInputDialog().getItem(self, 'Set History Saving Mode', "Select new history saving mode and press ok:   ", selection, SDT, False )
            vprint("Set History Saving Mode:", "text=", text, ",  ok=", ok)

            if not ok: break      # user has selected Cancel

            fprint(header("Set History Saving Mode"))

            newSDT = selection.index(text)
            #print "newSDT:", newSDT
            self.setBusyCursor()

            # write the new config data
            gcommands.writeConfigData(gglobs.cfgOffsetSDT, newSDT)

            self.setNormalCursor()

            # read the config to verify
            fprint(*self.getGMCDeviceHistSaveMode()) # getGMCDeviceHistSaveMode returns tuple

            break

        debugIndent(0)


    def getGMCDeviceHistSaveMode(self):
        """gets the History Saving Mode"""

        dprint("getGMCDeviceHistSaveMode:")
        debugIndent(1)

        self.setBusyCursor()

        HistSaveMode = "N.A."
        while True:
            # if no connection
            #if gglobs.ser == None:
            if not gglobs.GMCConnection:
                self.btnHistSaveMode.setText("Mode: ---")
                break

            # read the config
            cfg, error, errmessage = gcommands.getCFG()
            gglobs.cfg             = cfg
            if error < 0:
                efprint("Error:" + errmessage)
                break

            SDT, SDTtxt = gcommands.getSaveDataType()
            HistSaveMode = "Device History Saving Mode:", "{}".format(SDTtxt)
            gglobs.savedatatype = SDTtxt

            SMText = ("OFF", "CPS", "CPM", "CPMh", "CPSTh", "CPMTh")[SDT]
            self.btnHistSaveMode.setText("Mode: " + SMText)

            break

        self.setNormalCursor()
        debugIndent(0)

        return HistSaveMode # returns a tuple


    def switchGMCDeviceSpeaker(self, newstate = "ON"):
        """Switch Device Speaker to ON or OFF"""

        self.setBusyCursor()
        fprint(header("Switch Device Speaker {}".format(newstate)))

        while True: # to allow jumping to exit
            # get current config
            cfg, error, errmessage = gcommands.getCFG()
            if error < 0:
                efprint("Error:" + errmessage)
                break

            if newstate == "ON":
                st = 1
            else:
                st = 0

            # write the new config data
            gcommands.writeConfigData(gglobs.cfgOffsetSpeaker, st)

            # check config for success
            cfg, error, errmessage = gcommands.getCFG()
            if error < 0:
                efprint("Error:" + errmessage)
                break

            if cfg[gglobs.cfgOffsetSpeaker] == 1:
                ipo = "ON"
            else:
                ipo = "OFF"

            fprint("Device Speaker State is: ",  ipo)
            break

        self.setNormalCursor()


    def switchGMCDeviceAlarm(self, newstate = "ON"):
        """Switch Device Alarm to ON or OFF"""

        self.setBusyCursor()
        fprint(header("Switch Device Alarm {}".format(newstate)))

        while True: # to allow jumping to exit
            # get current config
            cfg, error, errmessage = gcommands.getCFG()
            if error < 0:
                efprint("Error:" + errmessage)
                break

            if newstate == "ON":
                st = 1
            else:
                st = 0

            # write the new config data
            gcommands.writeConfigData(gglobs.cfgOffsetAlarm, st)

            time.sleep(1.0)

            # check config for success
            cfg, error, errmessage = gcommands.getCFG()
            gglobs.cfg = cfg

            fprint("Device Alarm State is: ",  gcommands.isAlarmOn())
            break

        self.setNormalCursor()


#help
    def helpQuickStart(self):
        """Quickstart item on the Help menu"""

        msg = QMessageBox(self)
        msg.setWindowIcon(self.iconGeigerLog)
        msg.setWindowTitle("Help - Quickstart")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpQuickstart)
        msg.setStandardButtons(QMessageBox.Ok)
        msg.setDefaultButton(QMessageBox.Ok)
        msg.setEscapeButton(QMessageBox.Ok)
        msg.setWindowModality(Qt.WindowModal)

        btn = QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QMessageBox.YesRole)
        msg.exec_()


    def helpFirmwareBugs(self):
        """Geiger Counter Firmware Bugs info on the Help menu"""

        msg = QMessageBox(self)
        msg.setWindowIcon(self.iconGeigerLog)
        msg.setWindowTitle("Help - Firmware Bugs")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpFirmwareBugs)
        msg.setStandardButtons(QMessageBox.Ok)
        msg.setDefaultButton(QMessageBox.Ok)
        msg.setEscapeButton(QMessageBox.Ok)
        msg.setWindowModality(Qt.WindowModal)

        btn = QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QMessageBox.YesRole)
        msg.exec_()


    def helpWorldMaps(self):
        """Using the Radiation World Map"""

        msg = QMessageBox(self)
        msg.setWindowIcon(self.iconGeigerLog)
        msg.setWindowTitle("Help - Radiation World Maps")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpWorldMaps)
        msg.setStandardButtons(QMessageBox.Ok)
        msg.setDefaultButton(QMessageBox.Ok)
        msg.setEscapeButton(QMessageBox.Ok)
        msg.setWindowModality(Qt.WindowModal)

        btn = QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QMessageBox.YesRole)
        msg.exec_()


    def helpOccupationalRadiation(self):
        """Occupational Radiation Limits"""

        msg = QMessageBox(self)
        msg.setWindowIcon(self.iconGeigerLog)
        msg.setWindowTitle("Help - Occupational Radiation Limits")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpOccupationalRadiation)
        msg.setStandardButtons(QMessageBox.Ok)
        msg.setDefaultButton(QMessageBox.Ok)
        msg.setEscapeButton(QMessageBox.Ok)
        msg.setWindowModality(Qt.WindowModal)

        btn = QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QMessageBox.YesRole)
        msg.exec_()


    def helpOptions(self):
        """Options item on the Help menu"""

        msg = QMessageBox(self)
        msg.setWindowIcon(self.iconGeigerLog)
        msg.setWindowTitle("Help - Options")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpOptions)
        msg.setStandardButtons(QMessageBox.Ok)
        msg.setDefaultButton(QMessageBox.Ok)
        msg.setEscapeButton(QMessageBox.Ok)
        msg.setWindowModality(Qt.WindowModal)

        btn = QPushButton()         # invisible button
        btn.setMinimumWidth(450)    # determines width of box
        btn.setMaximumHeight(0)     # invisible at height zero!

        msg.addButton(btn, QMessageBox.YesRole)
        msg.exec_()


    def helpSetPort(self):
        """sets the Port and Baud rate"""

        dprint("helpSetPort:")
        debugIndent(1)
        title = "Help - Show & Select USB Port and Baudrate"

        # Dialog Box
        d = QDialog(self)
        d.setWindowIcon(self.iconGeigerLog)
        d.setFont(self.fontstd)
        d.setWindowTitle(title)
        #d.setWindowModality(Qt.ApplicationModal)
        d.setWindowModality(Qt.WindowModal)

        # set Introductory Text
        # https://github.com/pyserial/pyserial/blob/master/documentation/tools.rst
        hsp = "Available Ports:"
        hsp += "\n{:15s} {:38s}  {:14s}   {:s}\n{}\n".format("Port", "Name of USB-to-Serial Hardware", "Linked to Port", "VID :PID", "-"*82)

        selection_ports    = []
        selection_baud     = list(map(str,sorted(gglobs.baudrates, reverse=True)))
        selection_baudI2C  = list(map(str,sorted(gglobs.I2Cbaudrates, reverse=True)))
        lp                 = serial.tools.list_ports.comports(include_links=True)
        for p in lp:
            if "LINK=" in p.hwid:   link = p.hwid[p.hwid.find("LINK=") + 5:]
            else:                   link = "No Link"
            hsp += "{:15s} {:38s}  {:14s}   {:04X}:{:04X}\n".format(p.device, p.description, link, p.vid, p.pid)
            selection_ports.append(p.device)
        #print("selection_ports", selection_ports, ",  selection_baud", selection_baud)

        for p in lp:
            vprint("p:               ", p)
            vprint("p.name:          ", p.name)
            vprint("p.hwid:          ", p.hwid)
            vprint("p.device:        ", p.device)
            vprint("p.description:   ", p.description)
            vprint("p.serial_number: ", p.serial_number)
            vprint("p.location:      ", p.location)
            vprint("p.manufacturer:  ", p.manufacturer)
            vprint("p.product:       ", p.product)
            vprint("p.interface:     ", p.interface)
            vprint("p.vid:           {:04X}".format(p.vid))
            vprint("p.pid:           {:04X}".format( p.pid))
            vprint("")

        hsp += "\nSelect port and baudrate and press OK, or Cancel:\n"
        hsp += "(GeigerLog's current settings are preselected if available)\n"

        # Combo Box Ports for GMC
        portCbBox = QComboBox(self)
        portCbBox.addItems(selection_ports)
        portCbBox.setToolTip('Select the USB-to-Serial port')
        portCbBox.setCurrentIndex(portCbBox.findText(gglobs.usbport))

        # Combo Box Baudrates for GMC
        baudCbBox = QComboBox(self)
        baudCbBox.addItems(selection_baud)
        baudCbBox.setToolTip('Select the USB-to-Serial baudrate')
        baudCbBox.setCurrentIndex(baudCbBox.findText(str(gglobs.baudrate)))

        # Combo Box Ports for I2C
        portCbBoxI2C = QComboBox(self)
        portCbBoxI2C.addItems(selection_ports)
        portCbBoxI2C.setToolTip('Select the USB-to-Serial port')
        portCbBoxI2C.setCurrentIndex(portCbBoxI2C.findText(gglobs.I2Cusbport))

        # Combo Box Baudrates for I2C
        baudCbBoxI2C = QComboBox(self)
        baudCbBoxI2C.addItems(selection_baudI2C)
        baudCbBoxI2C.setToolTip('Select the USB-to-Serial baudrate')
        baudCbBoxI2C.setCurrentIndex(baudCbBoxI2C.findText(str(gglobs.I2Cbaudrate)))

        # H-Layout of Combo Boxes
        cblayout = QHBoxLayout()
        cblayout.addWidget(portCbBox)
        cblayout.addWidget(baudCbBox)

        # H-Layout of Combo Boxes for I2C
        cblayoutI2C = QHBoxLayout()
        cblayoutI2C.addWidget(portCbBoxI2C)
        cblayoutI2C.addWidget(baudCbBoxI2C)


        # Button Box
        bbox      = QDialogButtonBox()
        bbox.setStandardButtons(QDialogButtonBox.Ok| QDialogButtonBox.Cancel)
        bbox.accepted.connect(lambda: d.done(1))     # ok
        bbox.rejected.connect(lambda: d.done(-1))    # cancel

        layoutV = QVBoxLayout(d)
        layoutV.addWidget(QLabel(hsp))
        layoutV.addWidget(QLabel("GMC Device:"))
        layoutV.addLayout(cblayout)
        layoutV.addWidget(QLabel("I2C Device:"))
        layoutV.addLayout(cblayoutI2C)
        layoutV.addWidget(bbox)

        retval = d.exec_()
        #print("---retval=",retval)

        if retval != 1:      # user has selected Cancel or pressed ESC
            dprint("helpSetPort: was Cancelled")
        else:
            gglobs.usbport  = portCbBox.currentText()
            gglobs.baudrate = int(baudCbBox.currentText())

            gglobs.I2Cusbport  = portCbBoxI2C.currentText()
            gglobs.I2Cbaudrate = int(baudCbBoxI2C.currentText())

            dprint("helpSetPort: Selection: {} with Baudrate: {}".format(gglobs.usbport, gglobs.baudrate))
            fprint(header(title))
            fprint("GMC Device:")
            fprint("- USB-to-Serial Port:",   gglobs.usbport)
            fprint("- Baudrate:",             gglobs.baudrate)

            fprint("I2C Device:")
            fprint("- USB-to-Serial Port:",   gglobs.I2Cusbport)
            fprint("- Baudrate:",             gglobs.I2Cbaudrate)
        debugIndent(0)


    def changeOptions(self):
        """Switches State of some options"""

        options       = ("Verbose  = False",
                         "Verbose  = True",
                         "Debug    = False",
                         "Debug    = True",
                         "Redirect = False",
                         "Redirect = True",
                         "testing  = False",
                         "testing  = True",
                         )

        index         = 0
        text, ok      = QInputDialog().getItem(self, 'Switch Option', "Select new option setting and press ok:   ", options, index, False )
        vprint("changeOptions: text= '{}', ok={}".format( text, ok))

        if not ok: return      # user has selected Cancel

        newIndex    = options.index(text)

        fprint(header("Change Options"))
        fprint("New Option setting:", "{}".format(options[newIndex]))

        if   newIndex == 0:
            gglobs.verbose  = False
        elif newIndex == 1:
            gglobs.verbose  = True

        elif newIndex == 2:
            gglobs.debug    = False
        elif newIndex == 3:
            gglobs.debug    = True

        elif newIndex == 4:
            gglobs.redirect = False
        elif newIndex == 5:
            gglobs.redirect = True

        elif newIndex == 6:
            gglobs.testing  = False
        elif newIndex == 7:
            gglobs.testing  = True
        else:
            pass


    def showSystemInfo(self):
        """System Info on the Devel Menu"""

        screen           = QDesktopWidget().screenGeometry()
        screen_available = QDesktopWidget().availableGeometry()
        geom             = self.geometry()
        geom_frame       = self.frameGeometry()

        #fmt              = "\n{:33s}{}"
        fmt              = "{:33s}{}\n"
        si               = ""

        # user
        #print("os.environ.get('USER'):", os.environ.get('USER'))
        si += fmt.format("Username:",                         "{}".format(os.environ.get('USER')))

        # platform
        si += fmt.format("Platform:",                         "")
        si += fmt.format("  Operating System:",               "{}".format(platform.platform()))
        si += fmt.format("  Machine:",                        "{}, {}".format(platform.machine(), platform.architecture()[0]))

        # versions
        si += fmt.format("Version status:",                   "")
        for a in getVersionStatus():
            si += fmt.format( "  {:}:".format(a[0]),          "{}".format( a[1]))

        # runtime
        si += fmt.format("Runtime settings:",                 "")
        si += fmt.format("  Flag Debug:",                    str(gglobs.debug))
        si += fmt.format("  Flag Verbose:",                  str(gglobs.verbose))
        si += fmt.format("  Flag KeepFF:",                   str(gglobs.keepFF))
        si += fmt.format("  Flag Redirect:",                 str(gglobs.redirect))
        si += fmt.format("  Flag Development:",              str(gglobs.devel))
        si += fmt.format("  Flag Development #1:",           str(gglobs.devel1))
        si += fmt.format("  Flag Development #2:",           str(gglobs.devel2))
        si += fmt.format("  Flag Testing:",                  str(gglobs.testing))
        si += fmt.format("  GeigerLog Program Directory:",   str(getProgPath()))
        si += fmt.format("  GeigerLog Data Directory:",      str(gglobs.dataPath))
        si += fmt.format("  GeigerLog Resource Directory:",  str(gglobs.gresPath))
        si += fmt.format("  GeigerLog Manual:",              str(gglobs.manual_filename))

        # GUI
        si += fmt.format("GUI:",                              "")
        si += fmt.format("  Monitor:",                        "")
        si += fmt.format("   Screen size - Hardware:",        "{}x{}".format(screen.width(), screen.height()))
        si += fmt.format("   Screen size - Available:",       "{}x{}, at position: x={}, y={}".format(screen_available.width(), screen_available.height(), screen_available.x(), screen_available.y()))
        si += fmt.format("   Current window size:",           "{}x{} including window frame (w/o frame: {}x{})".format(geom_frame.width(), geom_frame.height(), geom.width(), geom.height()))
        si += fmt.format("  Styles:",                         "")
        si += fmt.format("   Styles available on System:",    styles)
        si += fmt.format("   Active Style (internal name):",  str(gglobs.style))
        si += fmt.format("  Fonts:",                          "")
        si += fmt.format("   Active Font - Application:",     strFontInfo("", app.font()))
        si += fmt.format("   Active Font - NotePad:",         strFontInfo("", self.notePad.fontInfo()))

        # GMC device
        si += fmt.format("GMC Device:",                           "")
        si += fmt.format("  Model connected:",                str(gglobs.deviceDetected))

        try: # the comma-separator fails if gglobs.memory is still 'auto'
            si += fmt.format("  Memory (bytes):",                "{:,}".format(gglobs.memory))
        except:
            si += fmt.format("  Memory (bytes):",                "{:}".format(gglobs.memory))

        try: # the comma-separator fails if gglobs.SPIRpage is still 'auto'
            si += fmt.format("  SPIRpage Size (bytes):",         "{:,}"    .format(gglobs.SPIRpage))
        except:
            si += fmt.format("  SPIRpage Size (bytes):",         "{:}"    .format(gglobs.SPIRpage))

        si += fmt.format("  SPIRbugfix:",                    "{:}"    .format(gglobs.SPIRbugfix))
        si += fmt.format("  configsize (bytes):",            "{:}"    .format(gglobs.configsize))
        si += fmt.format("  Calibration (µSv/h / CPM):",     str(gglobs.calibration))
        si += fmt.format("  Calibration 2nd (µSv/h / CPM):",     str(gglobs.calibration2nd))
        si += fmt.format("  voltagebytes (bytes):",         "{:}"    .format(gglobs.voltagebytes))
        si += fmt.format("  endianness:",                   "{:}"    .format(gglobs.endianness))
        si += fmt.format("  History Saving Mode:",           str(gglobs.savedatatype))

        # GMC USB port
        si += fmt.format("GMC Serial (USB) Port Settings:",  "")
        si += fmt.format("  Port:",                          str(gglobs.usbport))
        si += fmt.format("  Baudrate:",                      "{:,}".format(int(gglobs.baudrate)))
        si += fmt.format("  Timeout:",                       str(gglobs.timeout))
        si += fmt.format("  ttyS:",                          str(gglobs.ttyS))

        # worldmaps
        si += fmt.format("Worldmaps Settings:", "")
        for key in ("Website", "URL", "UserID", "CounterID", "SSID", "Password", "Period"):
            si += fmt.format("  " + key, gglobs.GMCmap[key])

        lsysinfo = QTextBrowser()                # label to hold the text
        lsysinfo.setLineWrapMode(QTextEdit.WidgetWidth)
        lsysinfo.setText(si)

        dlg = QDialog(self)
        dlg.setWindowIcon(self.iconGeigerLog)
        dlg.setWindowTitle("Help - System Info")
        dlg.setFont(self.fontstd)
        dlg.setWindowModality   (Qt.WindowModal)
        dlg.setMinimumWidth(1200)
        dlg.setMinimumHeight(1100)

        bbox = QDialogButtonBox()
        bbox.setStandardButtons(QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: dlg.done(0))

        layoutV = QVBoxLayout(dlg)
        layoutV.addWidget(lsysinfo)
        layoutV.addWidget(bbox)

        dlg.exec_()


    def openUrl(self):
        """Show the GeigerLog Manual, either the local version, or if not
        possble, then the version on SourceForge"""

        manual_file = None

        if gglobs.manual_filename != 'auto':
            # if filename defined in config file, use that name
            # but if file does not exist, it has already been overwritten with
            # None when reading the config
            manual_file = getProgPath() + "/" + gglobs.manual_filename
        else:
            # if NOT defined in config file, use first found file which begins
            # with 'GeigerLog-Manual'
            path = getProgPath() + "/"
            for filename in os.listdir(path):
                #print filename
                if re.match("GeigerLog-Manual", filename):
                    #print "filename", filename
                    manual_file = getProgPath() + "/" + filename
                    break
        #print "manual_file", manual_file

        if manual_file != None:

            try:
                #a = 1/0
                if sys.platform.startswith('linux'):
                    subprocess.call(["xdg-open", manual_file])
                    dprint("Showing '{}' via xdg-open on Linux".format(manual_file))
                else:
                    os.startfile(manual_file)
                    dprint("Showing '{}' via os.startfile on other OS".format(manual_file))

                return
            except:
                print(sys.exc_info())
                dprint("Failure Showing '{}' via xdg-open on Linux or via os.startfile on other OS".format(manual_file))

            try:
                #a=1/0
                if sys.platform.startswith('linux'):
                    subprocess.call(["firefox", manual_file])
                    dprint("Showing '{}' via firefox on Linux".format(manual_file))
                else:
                    os.startfile(manual_file)
                    dprint("Showing '{}' via os.startfile on other OS".format(manual_file))

                return
            except:
                print(sys.exc_info())
                dprint("Failure Showing '{}' via firefox on Linux or via os.startfile on other OS".format(manual_file))

            try:
                #a = 1/0
                import webbrowser
                webbrowser.open(manual_file)
                dprint("Showing '{}' via import webbrowser".format(manual_file))
                return
            except:
                print(sys.exc_info())
                dprint("Failure Showing '{}' via import webbrowser".format(manual_file))


        try:
            #a=1/0
            shortv = gglobs.__version__.split("_")[0]
            url = QUrl('https://sourceforge.net/projects/geigerlog/files/GeigerLog-Manual-v{}.pdf'.format(shortv))
            if not QDesktopServices.openUrl(url):
                QMessageBox.warning(self, 'GeigerLog Manual', 'Could not open GeigerLog Manual.pdf')
                dprint("Failure Showing manual with QUrl")
            else:
                dprint("Showing '{}' via QUrl".format(manual_file))
        except:
            print(sys.exc_info())
            dprint("Failure Showing manual with QUrl")

        efprint("WARNING: Could not find GeigerLog-Manual, neither locally nor online!")
        fprint("The file 'GeigerLog-Manual-xyz', with xyz being a version number, is missing")
        fprint("from the GeigerLog working directory 'geigerlog'.")


    def USBautoDiscovery(self):
        """USB Autodiscovery with option to select any found connection"""

        dprint("USBautoDiscovery:")
        debugIndent(1)

        if gglobs.GMCConnection:
            self.switchConnections(new_connection = "OFF")
            QApplication.processEvents()

        self.setBusyCursor()
        rec, errmessage = gcommands.autoPORT()
        self.setNormalCursor()

        msg = QMessageBox(self)
        msg.setWindowTitle("USB Autodiscovery")
        msg.setIcon(QMessageBox.Information)
        msg.setWindowIcon(self.iconGeigerLog)

        if rec == None:
            flag = "fail"
            txt1 = errmessage + "\n\nIs device connected? Check cable and plugs! Re-run in a few seconds."
        else:
            if len(rec) == 1:
                flag  = "success"
                txt1  = "A GMC-Device was found at:\n"
                txt1 += "     Port: " + str(rec[0][0]) + "              Baudrate: " + str(rec[0][1])
                txt1 += "\n\nPress OK to make this your new setting and connect, Cancel otherwise."
                txt1 += "\n\nTo make this permanent edit the configuration file geigerlog.cfg\nand enter above settings in Section 'Serial Port'."

            else:
                flag  = "fail"
                txt1  = "The following ports and baudrates have connected Geiger Counters:\n"
                for i in rec:
                    txt1 += "\n     Port: " + str(i[0]) + "              Baudrate: " + str(i[1])
                txt1 += "\n\nGeigerLog can handle only a single connected Geiger Counter."
                txt1 += "\n\nEither remove all counters except one now and re-run 'USB Autodiscovery', or "
                txt1 += "edit the configuration file geigerlog.cfg in Section 'Serial Port' to define your counter."

        msg.setText(txt1)

        txt1  = "-" * 100
        txt1 += "\nThe current settings of GeigerLog are:"
        txt1 += "\n     Port: " + gglobs.usbport + "                Baudrate: " + str(gglobs.baudrate)
        msg.setInformativeText(txt1)

        if flag == "fail":
            msg.setStandardButtons(QMessageBox.Cancel)
        else:
            msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        msg.setDefaultButton(QMessageBox.Cancel)
        msg.setEscapeButton(QMessageBox.Cancel)

        retval = msg.exec_()

        if retval == 1024:
            dprint("USBautoDiscovery: Accepting autodiscovered port settings; connecting now")
            gglobs.usbport = str(rec[0][0])
            gglobs.baudrate = str(rec[0][1])
            self.switchConnections(new_connection = "ON")
        else:
            dprint("USBautoDiscovery: Not accepting autodiscovered port settings; cancelling now")

        debugIndent(0)


    def helpAbout(self):
        """About item on the Help menu"""

        description = gglobs.helpAbout.format(__author__, gglobs.__version__, __copyright__, __license__)

        licon   = QLabel() # label to hold the geigerlog icon
        licon.setPixmap(QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png')))

        ltext   = QLabel() # label to hold the 'eigerlog' text as picture
        ltext.setPixmap(QPixmap(os.path.join(gglobs.gresPath, 'eigerlog.png')))

        labout  = QTextBrowser() # label to hold the description
        labout.setLineWrapMode(QTextEdit.WidgetWidth)
        labout.setText(description)
        labout.setOpenExternalLinks(True) # to open links in a browser
        labout.setTextInteractionFlags(Qt.LinksAccessibleByMouse|Qt.TextSelectableByMouse)
        labout.setMinimumWidth(750)

        d = QDialog(self)
        d.setWindowIcon(self.iconGeigerLog)
        d.setFont(self.fontstd)
        d.setWindowTitle("Help - About GeigerLog")
        #d.setWindowModality(Qt.ApplicationModal)
        d.setWindowModality(Qt.WindowModal)
        #d.setMinimumWidth(800)
        d.setMinimumHeight(gglobs.window_height + 50)

        bbox    = QDialogButtonBox()
        bbox.setStandardButtons(QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutTop = QHBoxLayout()
        layoutTop.addWidget(licon)
        layoutTop.addWidget(ltext)
        layoutTop.addStretch()      # to keep the icons on the left

        layoutV   = QVBoxLayout(d)
        layoutV.addLayout(layoutTop)
        layoutV.addWidget(labout)
        layoutV.addWidget(bbox)

        d.exec_()


#utilities in Class

    def clearNotePad(self):
        """Clear the notepad"""

        self.notePad.append("<span style='color:black;'>   </span>")
        self.notePad.setStyleSheet("color: rgb(60, 60, 60)")
        self.notePad.clear()


    def clearLogPad(self):
        """Clear the logpad"""

        self.logPad.clear()


    def setBusyCursor(self):

        QApplication.setOverrideCursor(Qt.WaitCursor)
        #QApplication.processEvents()


    def setNormalCursor(self):

        QApplication.restoreOverrideCursor()
        #QApplication.processEvents()


    def showStatusMessage(self, message, timing=0, error=True):
        """shows message by flashing the Status Bar red for 0.5 sec, then switches back to normal"""

        if error == False:
            self.statusBar.setStyleSheet("QStatusBar { }") # reset to default colors
            self.statusBar.showMessage(message, msecs=timing) # message remains until overwritten by next status
        else:
            playWav("error")
            self.statusBar.showMessage(message, msecs=timing) # message remains until overwritten by next status
            self.statusBar.setStyleSheet("QStatusBar { background-color:red; color:white; }")
            QApplication.processEvents()             # assure that things are visible
            QApplication.processEvents()             # assure that things are visible
        #    QApplication.processEvents()             # MUST do twice to make it work, strange! for PyQt4. Qt5 also?
            time.sleep(0.5)                                # stays red for 0.5 sec
            self.statusBar.setStyleSheet("QStatusBar { }") # reset to default colors


    def plotPoisson(self):
        """Plotting a Poisson Fit to a histogram of the data"""

        vindex      = gglobs.ex.select.currentIndex()
        vname       = gglobs.varnames[vindex]
        vnameFull   = gglobs.vardict[vname][0]


        if gglobs.logTimeDiffSlice is None:
            gglobs.ex.showStatusMessage("No data available")
            return

        try:
            t0 = gglobs.logTimeDiffSlice
            x0 = gglobs.logSliceMod[vname]
        except:
            gglobs.ex.showStatusMessage("No data available")
            return
        #print("t0, x0: len:", len(t0), len(x0))

        t = np.ndarray(0)
        x = np.ndarray(0)
        for i in range(0,len(t0)):
            #print("i, x0[i]:", i, x0[i])
            if np.isnan(x0[i]):
                continue
            else:
                t = np.append(t, t0[i])
                x = np.append(x, x0[i])
        #print("t, x: len:", len(t), len(x))

        DataSrc     = os.path.basename(gglobs.currentDBPath)
        cycletime   = (t[-1] - t[0]) / (t.size - 1)  # in minutes

        ######################################
        # to show histogram of delta between 2 consecutive counts
        if False:
        #if True:
            dx = x[:-1].copy()
            for i in range(0, len(dx)):
                dx[i] = abs(x[i+1] - x[i])
                #if dx[i] > 10: print i, dx[i]
            #print x, len(x)
            #print dx, len(dx)
            x = dx
            yunit = "Differences between 2 consecutive CPM!"
        #######################################

        yunit = vnameFull

        # switch off interactive mode
        #plt.ioff()

        fig2 = plt.figure(2, facecolor = "#E7F9C9")
        plt.clf()
        plt.title("Histogram with Poisson Fit\n", fontsize=12, loc='center')
        subTitle = DataSrc + "  Recs:" + str(x.size)
        plt.title(subTitle, fontsize=10, fontweight='normal', loc = 'right')

        plt.xlabel("Variable {}".format(yunit), fontsize=12)
        plt.ylabel("Frequency of Occurence", fontsize=12)
        plt.grid(True)
        plt.subplots_adjust(hspace=None, wspace=.2 , left=.17, top=0.85, bottom=0.15, right=.97)
        plt.ticklabel_format(useOffset=False)

        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        canvas2 = FigureCanvas(fig2)
        canvas2.setFixedSize(550,400)
        navtoolbar = NavigationToolbar(canvas2, self)

        labout  = QTextBrowser() # label to hold the description
        labout.setLineWrapMode(QTextEdit.NoWrap)
        labout.setTextInteractionFlags(Qt.LinksAccessibleByMouse|Qt.TextSelectableByMouse)
        labout.setMinimumHeight(250)

        d       = QDialog()
        d.setWindowIcon(self.iconGeigerLog)
        d.setFont(self.fontstd)
        d.setWindowTitle("Poisson Test")
        #d.setMinimumHeight(gglobs.window_height)
        #d.setWindowModality(Qt.ApplicationModal)
        #d.setWindowModality(Qt.NonModal)
        d.setWindowModality(Qt.WindowModal)

        bbox    = QDialogButtonBox()
        bbox.setStandardButtons(QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutV   = QVBoxLayout(d)
        layoutV.addWidget(navtoolbar)
        layoutV.addWidget(canvas2)
        layoutV.addWidget(labout)
        layoutV.addWidget(bbox)

        lenx        = len(x)
        sumx        = np.nansum (x)
        avgx        = np.nanmean(x)
        varx        = np.nanvar (x)
        stdx        = np.nanstd (x)
        minx        = np.nanmin (x)
        maxx        = np.nanmax (x)
        #print("count data: len:{}, sum:{:5.0f}, avg:{:5.3f}, var:{:5.3f}, std:{:5.3f}\n{}\n".format(lenx, sumx, avgx, varx, stdx, x))

        std95       = np.sqrt(avgx) * 1.96
        edge_min    = int(max(0,    min(minx , avgx - (std95 * 1.5))))
        edge_max    = int(max(30,   max(maxx , avgx + (std95 * 1.5))))
        delta       = edge_max - edge_min
        step        = int(delta / 20)
        edge_min    = max(0, edge_min - step)
        edge_max    = edge_max + step
        #print("step: {}, edge_min: {}, edge_max: {}, delta: {}".format(step, edge_min, edge_max, delta))

        bin_edges   = list(range(edge_min, edge_max, step)) # 3 extra steps beyond max value
        #print( "step=", step,  ",len(bin_edges)=", len(bin_edges), ", bin_edges=", bin_edges)

        # CREATE histogram
        # If bins is a sequence, it defines the bin edges, including the
        # rightmost edge, allowing for non-uniform bin widths.
        hist, bins = np.histogram(x, bins=bin_edges)
        #hist, bins = np.histogram(x, bins='auto') # gives bins as rational numbers
        #hist, bins = np.histogram(x, bins='sqrt') # used in Excel; bins as rational numbers
        #print( "hist=\n", hist, len(hist))
        #print( "bins returned by numpy=\n", bins, len(bins))


        # sum up the Poisson dist for the bins from above histogram
        pdfs = []
        #for i in range(0, bin_edges[-1], step):
        for i in range(bin_edges[0], bin_edges[-1], step):
            stepsum = 0
            for j in range(0,step):
                stepsum += scipy.stats.poisson.pmf(i + j, avgx)
            pdfs.append(stepsum * lenx)

        labout.append("No.   Count Rate    Frequency    % of   Poisson-Fit    Residuals")
        labout.append("      from ... to  (blue col)   Total    (red line) (Freq - Fit)")
        for i in range(0, len(hist)):
            labout.append("{:3d}   {:4d} ... <{:<4d} {:8d}   {:5.2f}%   {:10.1f}   {:+10.1f}".format( i, bins[i], bins[i+1], hist[i], hist[i]*100./lenx, pdfs[i], hist[i] - pdfs[i]))
        labout.append("Total count=       {:10d}  100.00%   {:10.1f}".format(sum(hist), sum(pdfs)))

# chi squared stuff  ----------------------------------------------------------

        chi2    = -99
        pchi2   = -99
        fchi2   = -99
        obs     = hist
        exp     = pdfs
        mini    = 0
        maxi    = len(obs)

        # find where obs and exp are both > 5
        for i in range(len(obs)):
            #print("i={}, obs={:9.0f}, exp={:9.2f}".format(i, obs[i], exp[i] ))
            if obs[i] >=5 and exp[i] >= 5:
                #print("mini--> i={}, obs= {}, exp={}".format(i, obs[i], exp[i]))
                mini = i
                break

        for i in range(mini, len(obs) ):
            #print("i={}, obs={:9.0f}, exp={:9.2f}".format(i, obs[i], exp[i] ))
            if obs[i] <= 5 or exp[i] <= 5:
                #print("maxi--> i={}, obs= {}, exp={}".format(i, obs[i], exp[i]))
                maxi = i
                break

        for i in range(maxi, len(obs) ):
            pass
            #print("i={}, obs={:9.0f}, exp={:9.2f}".format(i, obs[i], exp[i] ))

        #print("mini, maxi, diff:", mini, maxi, maxi - mini)

        # cut out only the part where obs and exp are both > 5
        obs = obs[mini:maxi]
        exp = exp[mini:maxi]

        # print data used for chi2 calc
        sumchi = 0
        for i in range(0, len(obs)):
            v = (obs[i] - exp[i])**2/exp[i]
            sumchi += v
            #print("i={:4d}, obs={:11.4f}, exp={:11.4f}, obs-exp={:11.4f}, chi={:11.4f}, sumchi={:11.4f}".format(i, obs[i], exp[i], obs[i] - exp[i], v, sumchi))

        fchi2 = len(obs) -2

        # calc chi2
        # use one extra degree of freedom for avg estimate
        chi2, pchi2 = scipy.stats.chisquare(obs, f_exp=exp, ddof=1, axis=None)
        #print("axis= default, ddof=1,  len(obs):", len(obs),  ",  chisquare, p:", chi2, pchi2, "p[%]: {:5.5f}".format(pchi2 * 100) )

# END chi squared stuff  ------------------------------------------------------

        width = step * 0.8

        # plot histogram ##########################################################
        #plt.bar(bins[:-1], hist, align='center', width=width)
        plt.bar(bins[:-1], hist, align='edge', width=width, label ="avg = {:0.2f}\nvar = {:0.2f}".format(avgx, varx))
        #plt.xlim(xmin = 0, xmax = bins[-1] + step)

        #plt.hist(x, bins=50, rwidth=0.9)
        #plt.hist(x, bins='auto')

        # determine r-squared
        #ss_res = np.sum((hist - pdfs[:-1]    ) ** 2)    # residual sum of squares
        ss_res = np.sum((hist - pdfs    ) ** 2)    # residual sum of squares
        ss_tot = np.sum((hist - np.mean(hist)) ** 2)    # total sum of squares
        r2 = 1 - (ss_res / ss_tot)                      # r-squared

        labout.append("Goodness of Poisson Fit :  r²   = {:5.3f}".format(r2))
        labout.append("Chi-squared Poisson Test:  chi² = {:5.3f}, f= {:1d}, p= {:2.2f}%".format(chi2, fchi2, pchi2 * 100.))

        plt.plot(bins[:-1] + step/2, pdfs, linewidth=3, color='red', label ="r2  = {:0.3f}".format(r2))

        #######################################################################


    # find best place for legend
        #if avgx >= bins[-1]/2:
        if avgx >= (bins[0] + bins[-1]) / 2:
            loc = 'upper left'
        else:
            loc = 'upper right'
        plt.legend(loc=loc, fontsize=12, prop={"family":"monospace"})

    # Assemble Data set statistics
        labout.append("\nData Set:")
        labout.append("File     = {}"    .format(DataSrc))
        labout.append("Records  = {}"    .format(x.size))
        labout.append("Cycletime={:8.2f}".format(cycletime * 86400) + " sec (overall average)")
        labout.append("Average  ={:8.2f}".format(avgx))
        labout.append("Variance ={:8.2f}  same as Average if true Poisson Dist.".format(varx))
        labout.append("Std.Dev. ={:8.2f}".format(stdx))
        labout.append("Sqrt(Avg)={:8.2f}  same as Std.Dev. if true Poisson Dist.".format(np.sqrt(avgx)))
        labout.append("Std.Err. ={:8.2f}".format(stdx / np.sqrt(x.size)))
        labout.append("Skewness ={:8.2f}  0:Norm.Dist.; skewed to: +:right   -:left".format(scipy.stats.skew    (x) ))
        labout.append("Kurtosis ={:8.2f}  0:Norm.Dist.; shape is:  +:pointy: -:flat".format(scipy.stats.kurtosis(x) ))
        labout.append("")

    # show window
        fig2.canvas.draw_idle()
        d.exec_()
        #plt.close()
        #plt.ion() # activate interactive mode again, IMPORTANT


#**Begin Eval_plotFFT *********************************************************

    def xxxEval_plotFFT(self, type = 'plot'):
        """Plotting FFT and Autocorrelation
        t       = time
        sigt    = Signal in time domain, (CPM/CPS here)
        freq    = Signal in frequency domain

        Has extra function for rectangle and autocorr
        """
        #
        # must be reworked. e.g. 'gglobs.focus' is no longer in use !!!
        #
        fprint("Eval_plotFFT is inactive", error=True)
        return

        markersize = 0.5#1.0

        if type == 'plot':              # use only data shown in the plot
            #print "gglobs.logTimeDiffSlice:", len(gglobs.logTimeDiffSlice), "\n", gglobs.logTimeDiffSlice
            #print "gglobs.logCPMSlice:", len(gglobs.logCPMSlice), "\n", gglobs.logCPMSlice
            rawt    = gglobs.logTimeDiffSlice
            if gglobs.focus == "Left":
                rawsigt = gglobs.logCPMSlice
                yunit = "CPM"
            else:
                rawsigt = gglobs.logCPSSlice
                yunit = "CPS"
            winTitleLabel = " (Data from Plot Only)"
        else:                           # use all data of the file
            #print "gglobs.logTimeDiff", len(), "\n", gglobs.logTimeDiff
            #print "gglobs.logCPM", len(gglobs.logCPM), "\n", gglobs.logCPM
            rawt    = gglobs.logTimeDiff
            if gglobs.focus == "Left":
                rawsigt = gglobs.logCPM
                yunit = "CPM"
            else:
                rawsigt = gglobs.logCPS
                yunit = "CPS"

            winTitleLabel = " (Data from complete File )"

        if rawsigt is None:
            self.showStatusMessage("No data available")
            return

        if rawt.size < 20:
            self.showStatusMessage("Not enough data (need 20+)")
            return

        DataSrc = os.path.basename(gglobs.currentDBPath)

        t    = rawt.copy()
        sigt = rawsigt.copy()



# Window functions ############################################################
        # the only place to activate Window function is here
        use_window_functions = False

        if use_window_functions:
            hamm    = np.hamming (len(t))
            hann    = np.hanning (len(t))
            black   = np.blackman(len(t))
            # Kaiser:
            # "A beta value of 14 is probably a good starting point"
            # beta  Window shape
            # 0     Rectangular
            # 5     Similar to a Hamming
            # 6     Similar to a Hanning
            # 8.6   Similar to a Blackman
            beta    = 5
            kaiser  = np.kaiser(len(t), beta)

            # Select one
            #win     = hamm
            #win     = hann
            #win     = black
            win     = kaiser

            # When using window functions subtract the average in order to avoid
            # spurious low-frequency peaks!
            sigt   = sigt - np.mean(sigt)

            # Time domain signal with Window function applied
            sigt_win = sigt * win

# Prepare variables ###########################################################

        t               = t * 1440.0  # convert days to minutes
        timeunit        = "minutes"
        frequencyunit   = "1/minute"
        cycletime       = (t[-1] - t[0]) / (t.size -1)  # in minutes

        sigt_mean       = np.mean(sigt)
        sigt_var        = np.var(sigt)
        sigt_std        = np.std(sigt)
        sigt_var        = np.var(sigt)
        sigt_err        = sigt_std / np.sqrt(sigt.size)

        print("t:    size:"       , t.size        , "\n", t)
        print("sigt: size:"       , sigt.size     , "\n", sigt)
        #print "sigt_win: size:"  , sigt_win.size , "\n", sigt_win


# figure and canvas ###################################################
        fig3 = plt.figure(3, facecolor = "#C9F9F0") # blueish tint
        plt.clf()
        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        canvas3 = FigureCanvas(fig3)
        canvas3.setFixedSize(1800, 700)
        navtoolbar = NavigationToolbar(canvas3, self)

# Data vs Time ################################################################
        plt.subplot (2,4,2)
        plt.title   ("Time Counts", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(sigt.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Time ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Count Rate  " + yunit, fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.plot    (t, sigt        ,  linewidth=0.4, color='red'   , label ="Time Domain" , marker="o", markeredgecolor='red'   , markersize=markersize)

# Autocorrelation vs Lag #########################################################
    # calculations
        asigt = sigt - sigt_mean
        #print "np.mean(sigt) , np.var(sigt) :", np.mean(sigt),  np.var(sigt)
        #print "np.mean(asigt), np.var(asigt):", np.mean(asigt), np.var(asigt)

        asigtnorm = np.var(asigt) * asigt.size  # to normalize autocorrelation
        ac = np.correlate(asigt, asigt, mode='full') / asigtnorm
        #ac = ac[ac.size/2:]
        ac = ac[int(ac.size/2):]
        #print "ac: len:", ac.size
        #print "ac:", "\n", ac

    # autocorrelation plot
        aax1 =  plt.subplot(2,4, 5)

        plt.title   ("Autocorrelation (normalized) vs. Lag Period", fontsize=11, loc = 'left', y = 1.08)
        plt.xlabel  ("Lag Period ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Autocorrelation", fontsize=12)
        plt.grid    (True)
        #plt.ticklabel_format(useOffset=False)

        aax2 = aax1.twiny()

        # how many points to show enlarged?
        for i in range(t.size):
            if ac[i] < 0: break

        tindex = min(i, t.size * 0.01)
        tindex = max(25, tindex, 60./(cycletime * 60.))
        tindex = int(tindex)  # Warning: ./geigerlog:3483: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
                              # aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="o", markeredgecolor='blue'  , markersize=markersize*2)
                              # What is the reason ?????
        #print "tindex:", tindex

        tnew = t - t[0]
        aax1.plot(tnew,          ac         , linewidth= 1.0, color='red'  , label ="Full Lag Period - Bottom Scale" , marker="o", markeredgecolor='red'   , markersize=markersize * 2)
        #aax1.legend(loc='upper right', fontsize=12)

        aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="D", markeredgecolor='blue'  , markersize=markersize * 6)
        #print "ac:", ac[:10]

        #plt.legend(loc='upper right', fontsize=12)
        plt.legend(loc='upper right', fontsize=8)

        for a in aax1.get_xticklabels():
            #a.set_color("red")
            #a.set_weight("bold")
            pass

        for a in aax2.get_xticklabels():
            a.set_color("blue")
            a.set_weight("bold")

# FFT plots
    # calculations
        # using amplitude spectrum, not power spectrum; power would be freq^2
        freq                = np.abs(np.fft.rfft(sigt     ))
        #freq2              = np.abs(np.fft.rfft(sigt2    ))
        print("freq:"       , len(freq)     , "\n", freq)
        #for i in range(0,100):  print freq[i]

        if use_window_functions:
            freq_win        = np.abs(np.fft.rfft(sigt_win ))
            #print "freq_win:"   , len(freq_win) , "\n", freq_win
            #for i in range(0,100):  print freq_win[i]

        f = np.fft.rfftfreq(t.size, d = cycletime)
        #print "f:   len:", f.size, "\n", f

        p  = np.reciprocal(f[1:])  # skipping 1st value frequency = 0
        #print "Period: len:", p.size, "\n", p


    # Plot FFT vs Time #########################################################
        plt.subplot(2, 4, 1)
        plt.title("FFT Spectrum vs. Time Period", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(freq.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel("Time Period ({})".format(timeunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.loglog(p, freq[1:]        , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)

    # Plot FFT vs Frequency ####################################################
        plt.subplot(2, 4, 6)
        #plt.title("FFT Spectrum vs. Frequency", fontsize=12, loc = 'left')
        plt.title("FFT Counts", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(freq.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], freq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)


# convolution plots ####################################################

        # rect for convolution - nr values of 1, followed by zeros
        nr = int(60 * 0.2)  # nr = 12
        nr = 60

        rect = np.zeros(sigt.size)
        for i in range(nr):
            rect[i] = 1
        print("rect:", len(rect), rect)

        # time axis
        bf = t[:rect.size]

    # Plot Rectangle Signal vs time

        plt.subplot (2, 4, 3)
        plt.title   ("Time Rectangle", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(rect.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Time ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Signal Value", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)
        plt.plot (bf, rect     , linewidth= 1.0, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize*4)


    # FFT of Signal vs Frequency ####################################################

        cfreq = np.abs(np.fft.rfft(rect     ))
        print("cfreq:   len:", cfreq.size, "\n", cfreq)

        f = np.fft.rfftfreq(t.size, d = cycletime)
        print("f:   len:", f.size, "\n", f)

        p  = np.reciprocal(f[1:])  # skipping 1st value frequency = 0
        print("Period: len:", p.size, "\n", p)

        plt.subplot (2, 4, 7)
        plt.title   ("FFT Rectangle", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(cfreq.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel  ("FFT Amplitude", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], cfreq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)


# last columns
    # upper

        csigt = scipy.signal.convolve(rect, sigt ) * (60 / nr)
        csigt = csigt[nr:len(sigt) + nr]
        print("csigt:", len(csigt), csigt)

        plt.subplot (2, 4, 4)
        plt.title   ("Time (Counts CNV Rectangle)", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(csigt.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')

        plt.xlabel  ("Time ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Count Rate CPM", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.plot (t[:-nr], csigt[:-nr]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)

    # lower
        ccfreq = cfreq * freq

        plt.subplot (2, 4, 8)
        plt.title   ("FFT (Counts CNV Rectangle)", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(cfreq.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel  ("FFT Amplitude", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], ccfreq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)



# arrange sub plots
        plt.subplots_adjust(hspace=0.4, wspace=0.3, left=.05, top=0.95, bottom=0.09, right=.97)

# textboxes ################################################################
        labout_left  = QTextBrowser() # label to hold some data on left side
        labout_left.setLineWrapMode(QTextEdit.NoWrap)
        labout_left.setTextInteractionFlags(Qt.LinksAccessibleByMouse|Qt.TextSelectableByMouse)
        labout_left.setMinimumHeight(150)

        #labout_left.append("{:22s}= {}"                             .format('File'               , os.path.basename(gglobs.currentDBPath)))
        labout_left.append("{:22s}= {}"                             .format('File'               , DataSrc))
        labout_left.append("{:22s}= {}"                             .format("No of Records"      , t.size))
        labout_left.append("{:22s}= {:4.2f}"                        .format("Count Rate Average" , sigt_mean))
        labout_left.append("{:22s}= {:4.2f} (Std.Dev:{:5.2f}, Std.Err:{:5.2f})"    .format("Count Rate Variance" , sigt_var, sigt_std, sigt_err))
        labout_left.append("{:22s}= {:4.2f} sec (overall average)"  .format("Cycle Time"         , cycletime * 60.)) # t is in minutes
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag=  0   sec)", ac[0]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[1] *60.), ac[1]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[2] *60.), ac[2]))
        #labout_left.append("{:22s}= {:4.2f} "                       .format("Autoc(lag={:5.1f} sec)".format(tnew[3] *60.), ac[3]))

        labout_right  = QTextBrowser() # label to hold some data on right side
        labout_right.setLineWrapMode(QTextEdit.NoWrap)
        labout_right.setTextInteractionFlags(Qt.LinksAccessibleByMouse|Qt.TextSelectableByMouse)
        labout_right.setMinimumHeight(120)

        fftmax      = np.max    (freq[1:])
        fftmaxindex = np.argmax (freq[1:]) + 1
        f_max       = f         [fftmaxindex ]

        labout_right.append("{:22s}= {:4.0f}"              .format("FFT(f=0)"         , freq[0]) )
        #labout_right.append("{:22s}= {:4.0f}"              .format("len(t)"         , len(t)) )
        labout_right.append("{:22s}= {:4.2f} (= FFT(f=0)/No of Records)".format("Count Rate Average", freq[0] / len(t)) )
        labout_right.append("{:22s}= {:4.2f}"              .format("Max FFT(f>0)"     , fftmax))
        labout_right.append("{:22s}= {}"                   .format("  @ Index"        , fftmaxindex))
        labout_right.append("{:22s}= {:4.4f}"              .format("  @ Frequency"    , f_max ))
        try:
            labout_right.append("{:22s}= {:4.4f}"              .format("  @ Period"       , p[fftmaxindex] ))
        except:
            labout_right.append("{:22s}= {:s}"              .format("  @ Period"       , "undefined" ))


# Pop Up  #################################################################
        d       = QDialog()
        d.setWindowIcon(self.iconGeigerLog)
        d.setFont(self.fontstd)
        d.setWindowTitle("FFT & Autocorrelation" + winTitleLabel)
        #d.setMinimumHeight(gglobs.window_height)
        #d.setWindowModality(Qt.ApplicationModal)
        #d.setWindowModality(Qt.NonModal)
        d.setWindowModality(Qt.WindowModal)

        bbox    = QDialogButtonBox()
        bbox.setStandardButtons(QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutH   = QHBoxLayout()
        layoutH.addWidget(labout_left)
        layoutH.addWidget(labout_right)


        layoutV   = QVBoxLayout(d)
        layoutV.addWidget(navtoolbar)
        layoutV.addWidget(canvas3)
        layoutV.addLayout(layoutH)
        layoutV.addWidget(bbox)

        fig3.canvas.draw_idle()
        d.exec_()

#**End Eval_plotFFT ***********************************************************


    def plotFFT(self):
        """Plotting FFT and Autocorrelation
        t       = time
        sigt    = Signal in time domain, (CPM/CPS here)
        freq    = Signal in frequency domain
        """
        #print("plotFFT:", "Entry")



        if gglobs.logTimeSlice is None:
            gglobs.ex.showStatusMessage("No data available")
            return

        #print("gglobs.logTimeDiffSlice, gglobs.logSliceMod:", gglobs.logTimeDiffSlice, gglobs.logSliceMod)
        #if np.all(gglobs.logTimeDiffSlice) == None or np.all(gglobs.logSliceMod) == None: return

        vindex      = gglobs.ex.select.currentIndex()
        vname       = gglobs.varnames[vindex]
        vnameFull   = gglobs.vardict[vname][0]
        yunit       = vnameFull
        #print("plotFFT: vname, vnameFull: ", vname, vnameFull)

        try:
            rawt0    = gglobs.logTimeDiffSlice
        except Exception as e:
            srcinfo = "plotFFT: could not load time data"
            exceptPrint(e, sys.exc_info(), srcinfo)
            return

        try:
            rawsigt0 = gglobs.logSliceMod[vname]
        except Exception as e:
            srcinfo = "plotFFT: could not load value data"
            exceptPrint(e, sys.exc_info(), srcinfo)
            return

        if rawsigt0 is None:
            self.showStatusMessage("No data available")
            return

        if rawt0.size < 20:
            self.showStatusMessage("Not enough data (need 20+)")
            return

        #print("rawt0, rawsigt0: len:", len(rawt0), len(rawsigt0))
        rawt    = np.ndarray(0)
        rawsigt = np.ndarray(0)
        #print("rawt, rawsigt: len:", len(rawt), len(rawsigt))
        for i in range(0,len(rawt0)):
            if np.isnan(rawsigt0[i]):
                #print("i, x0[i]:", i, x0[i])
                continue
            else:
                #print("i, x[i]:", i, x0[i])
                rawt    = np.append(rawt,    rawt0[i])
                rawsigt = np.append(rawsigt, rawsigt0[i])
        #print("rawt, rawsigt: len:", len(rawt), len(rawsigt))

        markersize = 1.0
        #winTitleLabel = " (Data from Plot Only)"

        DataSrc = os.path.basename(gglobs.currentDBPath)

        t    = rawt.copy()
        sigt = rawsigt.copy()


        ####### Window functions ##############################################
        # the only place to activate Window function is this:
        use_window_functions = False

        if use_window_functions:
            hamm    = np.hamming (len(t))
            hann    = np.hanning (len(t))
            black   = np.blackman(len(t))
            # Kaiser:
            # "A beta value of 14 is probably a good starting point"
            # beta  Window shape
            # 0     Rectangular
            # 5     Similar to a Hamming
            # 6     Similar to a Hanning
            # 8.6   Similar to a Blackman
            beta    = 5
            kaiser  = np.kaiser(len(t), beta)

            # Select one
            #win     = hamm
            #win     = hann
            #win     = black
            win     = kaiser

            # When using window functions subtract the average in order to avoid
            # spurious low-frequency peaks!
            sigt   = sigt - np.mean(sigt)
            #sigt2  = sigt - np.mean(sigt)

            # Time domain signal with Window function applied
            sigt_win = sigt * win
        #######################################################################

        t               = t * 1440.0  # convert days to minutes
        timeunit        = "minutes"
        frequencyunit   = "1/minute"
        cycletime       = (t[-1] - t[0]) / (t.size -1)  # in minutes

        #sigt_mean       = np.mean(sigt)
        #sigt_var        = np.var(sigt)
        #sigt_std        = np.std(sigt)
        #sigt_var        = np.var(sigt)
        #sigt_err        = sigt_std / np.sqrt(sigt.size)

        sigt_mean       = np.nanmean    (sigt)
        sigt_var        = np.nanvar     (sigt)
        sigt_std        = np.nanstd     (sigt)
        sigt_var        = np.nanvar     (sigt)
        sigt_err        = sigt_std / np.sqrt(sigt.size)

        # FFT calculation #####################################################
        # using amplitude spectrum, not power spectrum; power would be freq^2
        freq         = np.abs(np.fft.rfft(sigt     ))
        #freq2        = np.abs(np.fft.rfft(sigt2    ))

        if use_window_functions:
            freq_win     = np.abs(np.fft.rfft(sigt_win ))

        #print "t:    len:"       , len(t)        , "\n", t
        #print "sigt: len:"       , len(sigt)     , "\n", sigt
        #print "sigt_win:"   , len(sigt_win) , "\n", sigt_win
        #print "freq:"       , len(freq)     , "\n", freq
        #for i in range(0,100):  print freq[i]
        #print "freq_win:"   , len(freq_win) , "\n", freq_win
        #for i in range(0,100):  print freq_win[i]

        f = np.fft.rfftfreq(t.size, d = cycletime)
        #print "f:   len:", f.size, "\n", f

        p  = np.reciprocal(f[1:])  # skipping 1st value frequency = 0
        #print "Period: len:", p.size, "\n", p

        asigt = sigt - sigt_mean
        #print "np.mean(sigt) , np.var(sigt) :", np.mean(sigt),  np.var(sigt)
        #print "np.mean(asigt), np.var(asigt):", np.mean(asigt), np.var(asigt)

        asigtnorm = np.var(asigt) * asigt.size  # to normalize autocorrelation
        ac = np.correlate(asigt, asigt, mode='full') / asigtnorm
        #print( "ac: len:", ac.size)
        ac = ac[int(ac.size/2):]
        #print( "ac: len:", ac.size)
        #print( "ac:", "\n", ac)


    # figure and canvas ###################################################
        fig3 = plt.figure(3, facecolor = "#C9F9F0") # blueish tint
        plt.clf()
        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        canvas3 = FigureCanvas(fig3)
        canvas3.setFixedSize(1000, 600)
        navtoolbar = NavigationToolbar(canvas3, self)

    # Data vs Time ################################################################
        plt.subplot(2,2,1)
        plt.title("Time Course", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(sigt.size)
        plt.title(subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel("Time ({})".format(timeunit), fontsize=12)
        #plt.ylabel("Count Rate  " + yunit, fontsize=12)
        plt.ylabel("Variable  " + yunit, fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.plot(t, sigt        ,  linewidth=0.4, color='red'   , label ="Time Domain" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.plot(t, sigt_win    ,  linewidth=0.4, color='black' , label ="Time Domain" , marker="o", markeredgecolor='black' , markersize=markersize)

    # Autocorrelation vs Lag #########################################################
        aax1 =  plt.subplot(2,2,3)

        plt.title("Autocorrelation (normalized) vs. Lag Period", fontsize=12, loc = 'left', y = 1.1)
        plt.xlabel("Lag Period ({})".format(timeunit), fontsize=12)
        plt.ylabel("Autocorrelation", fontsize=12)
        plt.grid(True)
        #plt.ticklabel_format(useOffset=False)

        aax2 = aax1.twiny()

        # how many points to show enlarged?
        for i in range(t.size):
            if ac[i] < 0: break

        tindex = min(i, t.size * 0.01)
        tindex = max(25, tindex, 60./(cycletime * 60.))
        tindex = int(tindex)  # Warning: ./geigerlog:3483: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
                              # aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="o", markeredgecolor='blue'  , markersize=markersize*2)
                              # What is the reason ?????
        #print "tindex:", tindex
        #print "type(tindex):", type(tindex)

        tnew = t - t[0]
        aax1.plot(tnew,          ac         , linewidth= 0.4, color='red'  , label ="Full Lag Period - Bottom Scale" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #aax1.legend(loc='upper right', fontsize=12)

        aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="o", markeredgecolor='blue'  , markersize=markersize * 2)
        #print "ac:", ac[:10]

        #plt.legend(loc='upper right', fontsize=12)
        plt.legend(loc='upper right', fontsize=10)

        for a in aax1.get_xticklabels():
            #a.set_color("red")
            #a.set_weight("bold")
            pass

        for a in aax2.get_xticklabels():
            a.set_color("blue")
    #            a.set_weight("bold")

    # FFT vs Time #########################################################
        plt.subplot(2,2,2)
        plt.title("FFT Amplitude Spectrum vs. Time Period", fontsize=12, loc = 'left')
        plt.xlabel("Time Period ({})".format(timeunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.loglog(p, freq[1:]        , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.loglog(p, freq2[1:] -freq[1:]       , linewidth= 0.4, color='black'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.loglog(p, freq_win[1:]    , linewidth= 0.4, color='black' , label ="FFT" , marker="o", markeredgecolor='black' , markersize=markersize)

    # FFT vs Frequency ####################################################
        plt.subplot(2,2,4)
        plt.title("FFT Amplitude Spectrum vs. Frequency", fontsize=12, loc = 'left')
        plt.xlabel("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], freq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.semilogy (f[1:], freq2[1:] -freq[1:]     , linewidth= 0.4, color='black'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.semilogy (f[1:], freq_win[1:] , linewidth= 0.4, color='black' , label ="FFT" , marker="o", markeredgecolor='black' , markersize=markersize)

        #plt.legend(loc='upper left', fontsize=12)

    # arrange sub plots
        plt.subplots_adjust(hspace=0.5, wspace=0.2, left=.08, top=0.95, bottom=0.090, right=.98)

    # textboxes ################################################################
        labout_left  = QTextBrowser() # label to hold some data on left side
        labout_left.setLineWrapMode(QTextEdit.NoWrap)
        labout_left.setTextInteractionFlags(Qt.LinksAccessibleByMouse|Qt.TextSelectableByMouse)
        labout_left.setMinimumHeight(150)

        labout_left.append("{:22s}= {}"                             .format('File'               , DataSrc))
        labout_left.append("{:22s}= {}"                             .format("No of Records"      , t.size))
        labout_left.append("{:22s}= {:4.2f}"                        .format("Count Rate Average" , sigt_mean))
        labout_left.append("{:22s}= {:4.2f} (Std.Dev:{:5.2f}, Std.Err:{:5.2f})"    .format("Count Rate Variance" , sigt_var, sigt_std, sigt_err))
        labout_left.append("{:22s}= {:4.2f} sec (overall average)"  .format("Cycle Time"         , cycletime * 60.)) # t is in minutes
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag=  0   sec)", ac[0]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[1] *60.), ac[1]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[2] *60.), ac[2]))

        labout_right  = QTextBrowser() # label to hold some data on right side
        labout_right.setLineWrapMode(QTextEdit.NoWrap)
        labout_right.setTextInteractionFlags(Qt.LinksAccessibleByMouse|Qt.TextSelectableByMouse)
        labout_right.setMinimumHeight(120)

        fftmax      = np.max    (freq[1:])
        fftmaxindex = np.argmax (freq[1:]) + 1
        f_max       = f         [fftmaxindex ]

        labout_right.append("{:22s}= {:4.0f}"              .format("FFT(f=0)"         , freq[0]) )
        labout_right.append("{:22s}= {:4.2f} (= FFT(f=0)/No of Records)".format("Count Rate Average", freq[0] / len(t)) )
        labout_right.append("{:22s}= {:4.2f}"              .format("Max FFT(f>0)"     , fftmax))
        labout_right.append("{:22s}= {}"                   .format("  @ Index"        , fftmaxindex))
        labout_right.append("{:22s}= {:4.4f}"              .format("  @ Frequency"    , f_max ))
        labout_right.append("{:22s}= {:4.4f}"              .format("  @ Period"       , p[fftmaxindex] ))


    # Pop Up  #################################################################
        d       = QDialog()
        d.setWindowIcon(self.iconGeigerLog)
        d.setFont(self.fontstd)
        #d.setWindowTitle("FFT & Autocorrelation" + winTitleLabel)
        d.setWindowTitle("FFT & Autocorrelation" )
        #d.setMinimumHeight(gglobs.window_height)
        #d.setWindowModality(Qt.ApplicationModal)
        #d.setWindowModality(Qt.NonModal)
        d.setWindowModality(Qt.WindowModal)

        bbox    = QDialogButtonBox()
        bbox.setStandardButtons(QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutH   = QHBoxLayout()
        layoutH.addWidget(labout_left)
        layoutH.addWidget(labout_right)


        #layoutV   = QVBoxLayout(d)
        layoutV   = QVBoxLayout(d)
        layoutV.addWidget(navtoolbar)
        layoutV.addWidget(canvas3)
        layoutV.addLayout(layoutH)
        layoutV.addWidget(bbox)

        fig3.canvas.draw_idle()
        d.exec_()



######## class ggeiger ends ###################################################

def main():
    global app, styles

    # set directories and file names
    gglobs.progName         = getProgName   ()
    gglobs.progPath         = getProgPath   ()
    gglobs.gresPath         = getGresPath   ()
    gglobs.dataPath         = getDataPath   ()
    gglobs.proglogPath      = getProglogPath()
    gglobs.stdlogPath       = getStdlogPath ()
    gglobs.configPath       = getConfigPath ()
    gglobs.fileDialogDir    = getDataPath   ()

    #
    # Make sure that data directory exists; create it if needed
    # exit if it cannot be made or is not writable
    #
    if os.access(gglobs.dataPath , os.F_OK):
        # dir exists, ok
        if not os.access(gglobs.dataPath , os.W_OK):
            # dir exists, but is not writable
            print("ERROR: main: Data directory '{}' exists, but is not writable".format(gglobs.dataDirectory))
            return 1
    else:
        # dir does not exist; make it
        try:
            os.mkdir(gglobs.dataPath )
        except:
            # dir cannot be made
            print("ERROR: main: Could not make data directory '{}'".format(gglobs.dataDirectory))
            return 1

    # Make sure the gres directory exists and is readable
    if os.access(gglobs.gresPath , os.F_OK):
        # dir exists, ok
        if not os.access(gglobs.dataPath , os.R_OK):
            # dir exists, but is not readable
            print("ERROR: main: GeigerLog resource directory {} is not readable. Please, correct".format(gglobs.gresPath))
            return 1
    else:
        print("ERROR: main: GeigerLog resource directory {} does not exist. You may have to reinstall GeigerLog".format(gglobs.gresPath))
        return 1

    #
    # parse command line options
    #
    # sys.argv[0] is progname
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hdvwRVp:b:s:", ["help", "debug", "verbose", "werbose", "Redirect", "Version", "port=", "baudrate=", "style="])
    except getopt.GetoptError as errmessage :
        # print info like "option -a not recognized", then continue
        dprint("ERROR: '{}', use './geigerlog -h' for help".format(errmessage) , debug=True)
        return 1

    # processing the options
    for opt, optval in opts:
        if opt in ("-h", "--help"):
            #print(usage)
            print (gglobs.helpOptions)
            return

        elif opt in ("-d", "--debug"):
            gglobs.debug = True

        elif opt in ("-v", "--verbose"):
            gglobs.verbose = True

        elif opt in ("-w", "--werbose"):
            gglobs.werbose = True

        elif opt in ("-R", "--Redirect"):
            gglobs.redirect = True

        elif opt in ("-V", "--Version"):
            print("Version status:")
            for a in getVersionStatus(): print("   {:16s}: {}".format(a[0], a[1]))
            return


    # processing the args
    for arg in args:
        if arg == "showstyles":
            print("Styles found on system: ")
            for a in list(QStyleFactory.keys()): print("   " + a)
            #print("See configuration file geigerlog.cfg, section [Style] for details")
            return

        if arg == "keepFF":
            gglobs.keepFF   = True

        if arg == "devel":
            gglobs.devel    = True

        if arg == "devel1":
            gglobs.devel    = True
            gglobs.devel1   = True

        if arg == "devel2":
            gglobs.devel    = True
            gglobs.devel1   = True
            gglobs.devel2   = True

        if arg == "fullhist":
            gglobs.fullhist = True

        if arg == "testing":
            gglobs.testing  = True

        if arg == "test1":
            gglobs.test1    = True

        if arg == "test2":
            gglobs.test2    = True

        if arg == "test3":
            gglobs.test3    = True

        if arg == "test4":
            gglobs.test4    = True


    clearProgramLogFile() #clear and initialize the program log file 'geigerlog.proglog'

    try:
        if gglobs.devel:
            subprocess.call(["tput", "rmam"]) # tput rmam: no line break on lines longer than screen
            dprint("tput rmam was executed")
        else:
            subprocess.call(["tput", "smam"]) # tput smam: do line break on lines longer than screen
            dprint("tput smam was executed")
    except:
        dprint("WARNING: tput rmam / tput smam command failed", debug=True)

    # Signal handlers
    #dprint("SIGINT handler before:    SIGINT: {}, getsignal(SIGINT): {}".format(signal.SIGINT, signal.getsignal(signal.SIGINT)))
    signal.signal(signal.SIGINT, signal.SIG_DFL) # to allow shut down with ctrl-c when IN THE TERMINAL
    dprint("SIGINT handler activated: SIGINT: {}, getsignal(SIGINT): {}".format(signal.SIGINT, signal.getsignal(signal.SIGINT)))
    #
    # defining the own signal handler does not work properly
    # but using the default above does not shut down the threaded loop of RadMon MQQT
    # Signal handlers
    # CTRL-C : properly closes all files and devices and shuts down the program
    #dprint("initRadMon: before: SIGINT: {}, getsignal(SIGINT): {}".format(signal.SIGINT, signal.getsignal(signal.SIGINT)))
    #   signal.signal(signal.SIGINT,  signal_handler)   # to handle CTRL-C
    #   signal.signal(signal.SIGTSTP, signal_handler)   # to handle CTRL-Z
    #dprint("after:  SIGINT: {}, getsignal(SIGINT): {}".format(signal.SIGINT, signal.getsignal(signal.SIGINT)))
    #
    # test for what the signals are connected to
    #for i in range(0, 65): # fails with i>64
    #    try:
    #        print(": i: , signal.getsignal(i):", i, signal.getsignal(i))
    #        print(": i: {}, signal.getsignal(i): {}".format(i, signal.getsignal(i)))
    #    except:         print(": i: , signal.getsignal(i):", i, "Failed")

    # prints a list of all Python paths (but not PyQt4 paths)
    #for a in sys.path:
    #    print("sys.path:", a)

    dprint("Command line: sys.argv: {}".format(sys.argv))
    dprint("Recognized: options: {}, commands: {}".format(opts, args))

    dprint("Operating System: {}".format(platform.platform()))
    dprint("Machine: {}, {}".format(platform.machine(), platform.architecture()[0]))

    for a in sys.path:
        vprint("Python Path: {}".format(a))

# print version status to proglog
    vs = ""
    for a in getVersionStatus()[0:4]: vs += "{}: {},  ".format(a[0], a[1])
    dprint("Version status: ", vs[:-3])
    vs = ""
    for a in getVersionStatus()[4:12]: vs += "{}: {},  ".format(a[0], a[1])
    dprint("Version status: ", vs[:-3])
    vs = ""
    for a in getVersionStatus()[12: ]: vs += "{}: {},  ".format(a[0], a[1])
    dprint("Version status: ", vs[:-3])

    # matplotlib backend info
    dprint("Version status: matplotlib backend: ", matplotlib.get_backend())

# print paths
    vprint("progName:     " + gglobs.progName)
    vprint("progPath:     " + gglobs.progPath)
    vprint("dataPath:     " + gglobs.dataPath)
    vprint("gresPath:     " + gglobs.gresPath)
    vprint("proglogPath:  " + gglobs.proglogPath)
    vprint("configPath:   " + gglobs.configPath)

# Start PyQtX
    # results is message: (only PyQt5, not PyQt4!)
    # QApplication: invalid style override passed, ignoring it.
    #          Available styles: Windows, Fusion
    # unless a '-style <valid style>' is in sys.argv.    But can be ignored
    app = QApplication(sys.argv)
    app.setApplicationName("GeigerLog") # sets the name 'GeigerLog' as the application name
    #print( "get Application Name:", app.applicationName())
    app.setFont(QFont("Arial", 10))     # setting the application font size (takes int only?)

    QCoreApplication.addLibraryPath(gglobs.progPath + "/custom_libs/")
    dprint("{:40s}".format("QCoreApplication.applicationDirPath():"),  QCoreApplication.applicationDirPath())
    dprint("{:40s}".format("QCoreApplication.applicationFilePath():"), QCoreApplication.applicationFilePath())

    libPaths    = QCoreApplication.libraryPaths()
    libPathStr  = "QCoreApplication.libraryPaths():"
    if len(libPaths) == 0:
        dprint("{:40s}".format(libPathStr), "No Library Paths")
    else:
        for a in libPaths:
            dprint("{:40s}".format(libPathStr), a)

    #
    # Styles:
    #
    # QStyleFactory::keys() returns a list of valid keys, typically including
    # "Windows", "Motif", "CDE", "MotifPlus", "Platinum", "SGI" and "Compact".
    # Depending on the platform, "WindowsXP", "Aqua" or "Macintosh" may be available.
    #
    # Returns here: Breeze, Windows, Motif, CDE, Plastique, GTK+, Cleanlooks
    # best is 1)Breeze, 2)Cleanlooks, 3) Plastique, ... 6)Windows, 7)GTK+
    #
    # app.style().metaObject().className() :  returns Style codings:
    #   Breeze            =Breeze::Style,
    #   Cleanlooks        =QCleanlooksStyle,
    #   Plastique         =QPlastiqueStyle
    #   CDE               =QCDEStyle,
    #   Motif             =QMotifStyle,
    #   Windows           =QWindowsStyle,
    #   GTK+              =QGtkStyle
    #
    # order of my preference; first is best
    styles_rank = ['Breeze', 'Cleanlooks', 'Plastique', 'Windows', 'CDE', 'Motif', 'GTK+' ]
    styles      = []
    for a in list(QStyleFactory.keys()): styles.append(str(a))
    dprint("Style: found on system: ", styles)

    # PyQt5 styles default:
    # ['Windows', 'Fusion']
    # installing style for PyQt5:
    # sudo apt-get install qt5-style-plugins
    # Style danach: the same :-((

    # sets the style
    if gglobs.style != None:
        # either defined in config or on command line
        # if both then command line takes precedence
        #print "setting gglobs.style", gglobs.style
        #QApplication.setStyle(gglobs.style)
        #app.setStyle(gglobs.style)
        pass
    else:
        for s in styles_rank:       # Default if neither command line nor config
            if s in styles:         # test on availability in order of preference
                #print s
                #QApplication.setStyle(s)
                #app.setStyle(s)
                pass
                break

    gglobs.style = app.style().metaObject().className()
    dprint("Style: active: ", gglobs.style)

    # allows copy&Paste also on Win, but makes all Messageboxes as HTML coding
    # cumbersome with using space and tabs for formatting
    #app.setStyleSheet("QMessageBox { messagebox-text-interaction-flags: 5; }")

    # Reads the configuration file
    # - these settings may override defaults in gglobs.py
    # - command line options may override even these settings
    readGeigerLogConfig()

    ####### importing only when needed ########################################
    # gglobs.LJActivation is set in readGeigerLogConfig
    if gglobs.LJActivation:
        import glabjack
        global glabjack
    ###########################################################################

    initPlayWav() # initialize the pyaudio sound function

    # remaining command line options may override options in config file, so
    # must be processed AFTER reading the configuation file!
    for opt, optval in opts:
        if opt in ("-p", "--port"):
            gglobs.usbport = optval
            dprint("Command line setting for: Port: '{}', overriding GeigerConfig".format(gglobs.usbport))

        elif opt in ("-b", "--baudrate"):
            gglobs.baudrate = optval
            dprint("Command line setting for: Baudrate: '{}', overriding GeigerConfig".format(gglobs.baudrate))

        # '-style' is handled by QApplication(sys.argv)
        #elif opt in ("-s", "--style"):
        #    gglobs.style = optval
        #    print("-----------------optval:", optval)
        #    dprint("Command line setting for: Style: '{}', overriding GeigerConfig".format(gglobs.style))

    # starting the GUI
    dprint("Starting the GUI " + "-" * 110)
    ex     = ggeiger()     # an instance of ggeiger; runs init and draws window
    status = app.exec_()   # run the GUI until closure
    dprint("Exited GUI with status of: ", status)

    if gglobs.devel:        subprocess.call(["tput", "smam"]) # tput smam

    sys.exit(status)


if __name__ == '__main__':
    main()
