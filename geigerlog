#! /usr/bin/python3
# -*- coding: utf-8 -*-

"""
GeigerLog - A program with a Graphical User Interface to handle Geiger counters

Start as 'geigerlog -h' for help on available options and commands
Use GeigerLog-Manual-v<version number>.pdf for further details
"""

###############################################################################
#    This file is part of GeigerLog.
#
#    GeigerLog is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    GeigerLog is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with GeigerLog.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################

__author__          = "ullix"
__copyright__       = "Copyright 2016, 2017, 2018"
__credits__         = [""]
__license__         = "GPL3"


import sys
import os
import platform                 #
import re                       # regex
import getopt                   # parse command line for options and commands
import configparser             # parse configuration file geigerlog.cfg
import serial                   # needed in version_status()
import urllib.request           # for use with Radiation World Map
import urllib.parse             # for use with Radiation World Map

from PyQt4 import QtGui, QtCore
from PyQt4.phonon import Phonon # used only for an error sound

# Importing anything matplotlib results in this deprecation warning coming twice:
# (order of matplotlib commands has no impact on the warning)
#
#   /usr/local/lib/python3.5/dist-packages/matplotlib/__init__.py:898:
#   MatplotlibDeprecationWarning: The backend.qt4 rcParam was deprecated in
#   version 2.2.  In order to force the use of a specific Qt binding, either
#   import that binding first, or set the QT_API environment variable.
#   mplDeprecation)
import matplotlib
from matplotlib import __version__ as mplVersion

matplotlib.use('Qt4Agg', warn=True, force=False)    # use Qt4Agg, no the default TkAgg

import matplotlib.backends.backend_qt4agg # MUST be done BEFORE importing pyplot!
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QT as NavigationToolbar

import matplotlib.pyplot as plt # MUST import AFTER 'matplotlib.use()' / matplotli-backend!!!
import matplotlib.dates  as mpld

import numpy as np
import scipy
import scipy.signal

import signal
signal.signal(signal.SIGINT, signal.SIG_DFL) # to allow shut down with ctrl-c when IN THE TERMINAL

import gglobs
import gcommands
import ghist
import gplot
from   gutils import *


class ggeiger(QtGui.QMainWindow):

    def __init__(self):
        super(ggeiger, self).__init__()
        self.notePad           = None
        self.initUI()

    def initUI(self):

# theme
        #QtGui.QIcon.setThemeSearchPaths([gglobs.ThemeSearchPath])
        #for p in QtGui.QIcon.themeSearchPaths():
        #    dprint(gglobs.debug, "ThemeSearchPath:", p)
        #QtGui.QIcon.setThemeName(gglobs.ThemeName)
        #dprint(gglobs.debug, "ThemeName:      ", QtGui.QIcon.themeName())

# font standard
        self.fontstd = QtGui.QFont()
        self.fontstd.setFamily('Monospace')
        #self.fontstd.StyleHint(QtGui.QFont.TypeWriter)
        #self.fontstd.StyleHint(QtGui.QFont.Monospace)
        #self.fontstd.StyleHint(QtGui.QFont.Courier)
        #self.fontstd.setFamily('Lucida')
        self.fontstd.setFixedPitch(True)
        self.fontstd.setPointSize(10)
        self.fontstd.setBold(False)
        self.fontstd.setWeight(50)
        #self.fontstd.setStyleStrategy(QtGui.QFont.PreferMatch)
        #self.fontstd.setBold(True)
        #self.fontstd.Weight(QtGui.QFont.Normal)
        #self.fontstd.Weight(QtGui.QFont.DemiBold)
        #self.fontstd.Weight(QtGui.QFont.Bold)
        #self.fontstd.Weight(QtGui.QFont.Black)

# window
        screen_available = QtGui.QDesktopWidget().availableGeometry()

        #print "screen Geometry:", QtGui.QDesktopWidget().screenGeometry() # total hardware screen
        #print "screen_available", screen_available, screen_available.x(), screen_available.y(), "width:", screen_available.width(), "height:", screen_available.height()

        sw = min(gglobs.window_width  -  2, screen_available.width() ) # Frame of 1 pixel left and right
        sh = min(gglobs.window_height - 29, screen_available.height()) # Frame top + bottom + Window bar of 29 pixel
        x  = max(screen_available.width() - sw, 0)                     # should be >0 anyway
        #y  = 0
        y  = screen_available.y()
        if "WINDOWS" in platform.platform().upper(): y += 33           # some correction needed at least on Virtual Win8.1
        self.setGeometry(x, y, sw, sh) # position window in upper right corner of screen
        self.setWindowTitle('GeigerLog v' + gglobs.__version__)
        self.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))

#figure and its toolbar
        # a figure instance to plot on
        #self.figure = plt.figure(facecolor = "#F9F4C9", edgecolor='lightgray', linewidth = 0.0) # light yellow face
        self.figure = plt.figure(facecolor = "#DFDEDD") # lighter gray

        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        self.canvas = FigureCanvas(self.figure)
        #self.canvas.setFixedSize(1000,400)

        self.canvas.mpl_connect('motion_notify_event', self.updatecursorposition) # where the cursor is
        self.canvas.mpl_connect('button_press_event' , self.onclick)              # send a mouse click

        # this is the figure Navigation widget; it takes the Canvas widget and a parent
        self.navtoolbar = NavigationToolbar(self.canvas, self)
        self.navtoolbar.setIconSize(QtCore.QSize(32,32))

#menubar and statusbar and toolbar
        menubar     = self.menuBar()
        menubar.setFocus()
        #dprint(gglobs.debug, "Fonts: menubar -", strFontInfo("", menubar.fontInfo()))

        self.statusBar = QtGui.QStatusBar()
        self.setStatusBar(self.statusBar)

        toolbar     = self.addToolBar('Main')
        toolbar.setOrientation(QtCore.Qt.Horizontal) # is default; alt: Qt.Vertical
        toolbar.setIconSize(QtCore.QSize(32,32))  # standard size is too small
        #print "toolbar.iconSize()", toolbar.iconSize()
        toolbar.setToolTip("Main Toolbar")

# buttons connected to stuff (may not be in use)
        btnwidth = 60
        self.btna = QtGui.QPushButton('Button Alpha')
        self.btna.setMaximumWidth(btnwidth)
        self.btna.clicked.connect(self.btnAlpha)
        self.btnb = QtGui.QPushButton('Button Beta')
        self.btnb.setMaximumWidth(btnwidth)
        self.btnb.clicked.connect(self.btnBeta)
        self.btnc = QtGui.QPushButton('Button Gamma')
        self.btnc.setMaximumWidth(btnwidth)
        self.btnc.clicked.connect(self.btnGamma)
        self.btnd = QtGui.QPushButton('Button Delta')
        self.btnd.setMaximumWidth(btnwidth)
        self.btnd.clicked.connect(self.btnDelta)
        self.btne = QtGui.QPushButton('Button Epsilon')
        self.btne.setMaximumWidth(btnwidth)
        self.btne.clicked.connect(self.btnEpsilon)
        self.btnf = QtGui.QPushButton('Button Zeta')
        self.btnf.setMaximumWidth(btnwidth)
        self.btnf.clicked.connect(self.btnZeta)
        self.btng = QtGui.QPushButton('Button Eta')
        self.btng.setMaximumWidth(btnwidth)
        self.btng.clicked.connect(self.btnEta)
        self.btnh = QtGui.QPushButton('Button Theta')
        self.btnh.setMaximumWidth(btnwidth)
        self.btnh.clicked.connect(self.btnTheta)
        self.btni = QtGui.QPushButton('Button Iota')
        self.btni.setMaximumWidth(btnwidth)
        self.btni.clicked.connect(self.btnIota)

        self.btna.setText(self.btnAlpha     .__doc__)
        self.btnb.setText(self.btnBeta      .__doc__)
        self.btnc.setText(self.btnGamma     .__doc__)
        self.btnd.setText(self.btnDelta     .__doc__)
        self.btne.setText(self.btnEpsilon   .__doc__)
        self.btnf.setText(self.btnZeta      .__doc__)
        self.btng.setText(self.btnEta       .__doc__)
        self.btnh.setText(self.btnTheta     .__doc__)
        self.btni.setText(self.btnIota     .__doc__)

        layout2 = QtGui.QHBoxLayout()
        layout2.addWidget(self.btna)
        layout2.addWidget(self.btnb)
        layout2.addWidget(self.btnc)
        layout2.addWidget(self.btnd)
        layout2.addWidget(self.btne)
        layout2.addWidget(self.btnf)
        layout2.addWidget(self.btng)
        layout2.addWidget(self.btnh)
        layout2.addWidget(self.btni)


#file menu
        PlotLogAction = QtGui.QAction('Plot Log', self)
        PlotLogAction.setStatusTip('Plots the Log file')
        PlotLogAction.triggered.connect(lambda: self.plotGraph('Log'))

        PlotHisAction = QtGui.QAction('Plot History', self)
        PlotHisAction.setStatusTip('Plots the History file')
        PlotHisAction.triggered.connect(lambda: self.plotGraph('His'))

        PrintFileStatsAction =  QtGui.QAction('Print File Stats', self)
        PrintFileStatsAction.setStatusTip("Print the Statistics of all the data in the file")
        PrintFileStatsAction.triggered.connect(self.printFileStats)

        PrintPlotStatsAction =  QtGui.QAction('Print Plot Stats', self)
        PrintPlotStatsAction.setStatusTip("Print the Statistics of all the data in the current plot")
        PrintPlotStatsAction.triggered.connect(self.printPlotStats)

        HistogramFileAction =  QtGui.QAction('Show File Poisson Test', self)
        HistogramFileAction.setStatusTip("Shows a Poisson curve on a histogram of all the data in the file")
        HistogramFileAction.triggered.connect(lambda: self.plotPoisson('all'))

        HistogramPlotAction =  QtGui.QAction('Show Plot Poisson Test', self)
        HistogramPlotAction.setStatusTip("Shows a Poisson curve on a histogram of only the data in the current plot")
        HistogramPlotAction.triggered.connect(lambda: self.plotPoisson('plot'))

        FFTFileAction =  QtGui.QAction('Show File FFT && Autocorrelation', self)
        FFTFileAction.setStatusTip("Shows the FFT Spectra & an Autocorrelation of all the data in the file")
        FFTFileAction.triggered.connect(lambda: self.plotFFT('all'))

        FFTPlotAction =  QtGui.QAction('Show Plot FFT && Autocorrelation', self)
        FFTPlotAction.setStatusTip("Shows the FFT Spectra & an Autocorrelation of only the data in the current plot")
        FFTPlotAction.triggered.connect(lambda: self.plotFFT('plot'))

        exitAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_exit.png'))), 'Exit', self)
        exitAction.setShortcut('Ctrl+Q')
        exitAction.setStatusTip('Exit the GeigerLog program')
        #exitAction.triggered.connect(self.exitGeigerLog)
        exitAction.triggered.connect(self.close)

        fileMenu = menubar.addMenu('&File')
        fileMenu.addAction(PlotLogAction)
        fileMenu.addAction(PlotHisAction)
        fileMenu.addAction(PrintFileStatsAction)
        fileMenu.addAction(PrintPlotStatsAction)
        fileMenu.addAction(HistogramFileAction)
        fileMenu.addAction(HistogramPlotAction)
        fileMenu.addAction(FFTFileAction)
        fileMenu.addAction(FFTPlotAction)
        fileMenu.addAction(exitAction)
        #fileMenu.triggered[QtGui.QAction].connect(self.processtrigger)

        toolbar.addAction(exitAction)

# Device menu
        self.toggleDeviceConnectionAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_open.png'))), 'Connect / Disconnect Device', self)
        self.toggleDeviceConnectionAction.setStatusTip('Toggle connection of the computer with the Geiger counter device via the Serial Port')
        self.toggleDeviceConnectionAction.triggered.connect(self.toggleDeviceConnection)

        self.DeviceConnectAction = QtGui.QAction('Connect Device', self)
        self.DeviceConnectAction.setShortcut('Ctrl+C')
        self.DeviceConnectAction.setStatusTip('Connect the computer to the Geiger counter device via the Serial Port')
        self.DeviceConnectAction.triggered.connect(lambda : self.switchDeviceConnection("ON"))

        self.DeviceDisconnectAction = QtGui.QAction('Disconnect Device', self, enabled = False)
        self.DeviceDisconnectAction.setShortcut('Ctrl+D')
        self.DeviceDisconnectAction.setStatusTip('Disconnect the computer from the Geiger counter device via the Serial Port')
        self.DeviceDisconnectAction.triggered.connect(lambda : self.switchDeviceConnection("OFF"))

        self.DevicePowerToggle = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power_off.png'))), 'Switch Device Power', self, enabled=False)
        self.DevicePowerToggle.setStatusTip('Toggle Device Power On / OFF - Requires Connection to the Serial Port (gray: button disabled; red: Power OFF; yellow: Power ON)')
        self.DevicePowerToggle.triggered.connect(self.toggleDevicePower)

        self.DeviceInfoAction = QtGui.QAction('Show Device Info', self, enabled=False)
        self.DeviceInfoAction.setShortcut('Ctrl+I')
        self.DeviceInfoAction.setStatusTip('Show general Info on device')
        self.DeviceInfoAction.triggered.connect(self.printDevInfo)

        self.DeviceConfigAction = QtGui.QAction('Show Device Configuration Memory', self, enabled=False)
        self.DeviceConfigAction.setShortcut('Ctrl+G')
        self.DeviceConfigAction.setStatusTip('Show the device configuration memory as binary in human readable format')
        self.DeviceConfigAction.triggered.connect(self.printDevConfig)

        #self.DeviceSettingAction = QtGui.QAction('Show Device Firmware Settings', self, enabled=False)
        #self.DeviceSettingAction.setStatusTip('Show the firmware settings configured for the connected device')
        #self.DeviceSettingAction.triggered.connect(self.printDevSettings)

        self.DeviceONAction = QtGui.QAction('Switch Power ON', self, enabled=False)
        self.DeviceONAction.setStatusTip('Switch the device power to ON')
        self.DeviceONAction.triggered.connect(lambda: self.switchDevicePower("ON"))

        self.DeviceOFFAction = QtGui.QAction('Switch Power OFF', self, enabled=False)
        self.DeviceOFFAction.setStatusTip('Switch the device power to OFF')
        self.DeviceOFFAction.triggered.connect(lambda: self.switchDevicePower("OFF"))

        self.DeviceAlarmONAction = QtGui.QAction('Switch Alarm ON', self, enabled=False)
        self.DeviceAlarmONAction.setStatusTip('Switch the device alarm ON')
        self.DeviceAlarmONAction.triggered.connect(lambda: self.switchDeviceAlarm("ON"))

        self.DeviceAlarmOFFAction = QtGui.QAction('Switch Alarm OFF', self, enabled=False)
        self.DeviceAlarmOFFAction.setStatusTip('Switch the device alarm OFF')
        self.DeviceAlarmOFFAction.triggered.connect(lambda: self.switchDeviceAlarm("OFF"))

        self.DeviceSpeakerONAction = QtGui.QAction('Switch Speaker ON', self, enabled=False)
        self.DeviceSpeakerONAction.setStatusTip('Switch the device speaker ON')
        self.DeviceSpeakerONAction.triggered.connect(lambda: self.switchDeviceSpeaker("ON"))

        self.DeviceSpeakerOFFAction = QtGui.QAction('Switch Speaker OFF', self, enabled=False)
        self.DeviceSpeakerOFFAction.setStatusTip('Switch the device speaker OFF')
        self.DeviceSpeakerOFFAction.triggered.connect(lambda: self.switchDeviceSpeaker("OFF"))

        self.DeviceSavingStateAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, ''))), 'Switch History Saving Mode of Device', self, enabled=False)
        self.DeviceSavingStateAction.setStatusTip('Switch History Saving Mode of Device between OFF, CPS, CPM, and hourly as CPM')
        self.DeviceSavingStateAction.triggered.connect(self.switchSaveDataType)

        self.DeviceSetTimeAction = QtGui.QAction('Set Date+Time of Device', self, enabled=False)
        self.DeviceSetTimeAction.setStatusTip('Set the Date + Time of the device to the computer time')
        self.DeviceSetTimeAction.triggered.connect(self.deviceSetDateTime)

        self.DeviceREBOOTAction = QtGui.QAction('Reboot Device', self, enabled=False)
        self.DeviceREBOOTAction.setStatusTip('Send REBOOT command to the device')
        self.DeviceREBOOTAction.triggered.connect(self.doREBOOT)

        self.DeviceFACTORYRESETAction = QtGui.QAction('FACTORYRESET Device', self, enabled=False)
        self.DeviceFACTORYRESETAction.setStatusTip('Send FACTORYRESET command to the device')
        self.DeviceFACTORYRESETAction.triggered.connect(self.doFACTORYRESET)

        deviceMenu = menubar.addMenu('&Device')
        deviceMenu.addAction(self.DeviceConnectAction)
        deviceMenu.addAction(self.DeviceDisconnectAction)
        deviceMenu.addAction(self.DeviceInfoAction)
        deviceMenu.addAction(self.DeviceConfigAction)
        #deviceMenu.addAction(self.DeviceSettingAction)
        deviceMenu.addAction(self.DeviceONAction)
        deviceMenu.addAction(self.DeviceOFFAction)
        deviceMenu.addAction(self.DeviceAlarmONAction)
        deviceMenu.addAction(self.DeviceAlarmOFFAction)
        deviceMenu.addAction(self.DeviceSpeakerONAction)
        deviceMenu.addAction(self.DeviceSpeakerOFFAction)
        deviceMenu.addAction(self.DeviceSavingStateAction)
        deviceMenu.addAction(self.DeviceSetTimeAction)
        deviceMenu.addAction(self.DeviceREBOOTAction)
        deviceMenu.addAction(self.DeviceFACTORYRESETAction)
        #deviceMenu.triggered[QtGui.QAction].connect(self.processtrigger)

        #self.device = QtGui.QComboBox()
        #self.device.setToolTip("Device Selector")
        #self.device.addItems(gglobs.devices)
        #self.device.setCurrentIndex(gglobs.devicesIndex)
        #self.device.currentIndexChanged.connect(self.selectDevice)
        #self.device.setStatusTip("Select Geiger counter device in use")

        #self.btnDeviceConnectAction = QtGui.QAction('Connect Device', self)
        #self.DeviceConnectAction.setShortcut('Ctrl+C')
        #self.DeviceConnectAction.setStatusTip('Connect the computer to the Geiger counter device via the Serial Port')
        #self.DeviceConnectAction.triggered.connect(lambda : self.switchDeviceConnection("ON"))

        self.dbtnDeviceConnect =  QtGui.QPushButton('Click for Connection')
        self.dbtnDeviceConnect.clicked.connect(self.toggleDeviceConnection)
        self.dbtnDeviceConnect.setEnabled(True)
        self.dbtnDeviceConnect.setFixedSize(170,32)
        self.dbtnDeviceConnect.setStatusTip("Toggle Device Discovery and Connection")
        self.dbtnDeviceConnect.setToolTip("Toggle Device Discovery and Connection")
        #self.dbtnDeviceConnect.setStatusTip('Toggle connection of the computer with the Geiger counter device via the Serial Port')
        #self.dbtnDeviceConnect.setStyleSheet("QPushButton:pressed {color: red; background-color: #12cc3d; border: solid 10px; } ")
        #self.dbtnDeviceConnect.setStyleSheet("font-size:16px;")
        #self.dbtnDeviceConnect.setStyleSheet("QPushButton:default { background-color: red }") # geht nicht
        #self.dbtnDeviceConnect.setStyleSheet("default { background-color: red }") # geht nicht
        #self.dbtnDeviceConnect.setStyleSheet("{ background-color: red }") # geht nicht
        #self.dbtnDeviceConnect.setStyleSheet("background-color: red ") # so geht's
        #self.dbtnDeviceConnect.setStyleSheet("QPushButton:pressed {background-color: red; border:solid 15px green;}") # so geht's
        #self.dbtnDeviceConnect.setStyleSheet("QPushButton:pressed {background-color: red; border:solid 15px green;} background-color: red ") # nur der erste teil geht
        #self.dbtnDeviceConnect.setStyleSheet("QPushButton:pressed {background-color: red; border:solid 15px green;}" "background-color: green ") # nur der erste teil geht
        #self.dbtnDeviceConnect.setStyleSheet("background-color: green " "QPushButton:pressed {background-color: red; border:solid 15px green;}" ) # nichts geht
        self.dbtnDeviceConnect.setCheckable(True)
        self.dbtnDeviceConnect.setChecked(False)
        self.dbtnDeviceConnect.setStyleSheet("QPushButton:checked {background-color: #12cc3d;\
         border-radius: 2px; border:1px solid silver; color: black; font-size:14px; font-weight:bold}") # so geht's

        toolbar     = self.addToolBar('Device')
        toolbar.setToolTip("Device Toolbar")
        toolbar.setIconSize(QtCore.QSize(32,32))   # standard size is too small
        #toolbar.addWidget(self.device)            # the old drop down selector
        toolbar.addWidget(self.dbtnDeviceConnect)
        #toolbar.addAction(self.toggleDeviceConnectionAction) # the connect icon
        toolbar.addAction(self.DevicePowerToggle)

#Log Menu
        self.logLoadFileAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_log_get.png'))), 'Get Log File or Create New One', self)
        self.logLoadFileAction.setShortcut('Ctrl+F')
        self.logLoadFileAction.setStatusTip('Load file for logging or create new one. Plot data if there are any in the loaded file')
        self.logLoadFileAction.triggered.connect(self.getLogFile)

        self.startloggingAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_log_start.png'))), 'Start Logging', self, enabled=False)
        self.startloggingAction.setShortcut('Ctrl+L')
        self.startloggingAction.setStatusTip('Start logging from device. Requires: 1) Connection, 2) Device is powered, 3) Log file is loaded')
        self.startloggingAction.triggered.connect(self.startTimer)

        self.stoploggingAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_log_stop.png'))), 'Stop Logging', self, enabled=False)
        self.stoploggingAction.setShortcut('Ctrl+S')
        self.stoploggingAction.setStatusTip('Stop logging from device')
        self.stoploggingAction.triggered.connect(self.stopTimer)

        self.addCommentAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, ''))), 'Add Comment to Log', self, enabled=False)
        self.addCommentAction.setShortcut('Ctrl+A')
        self.addCommentAction.setStatusTip('Add a comment to the current log file')
        self.addCommentAction.triggered.connect(self.addComment)

        self.showLogDataAction = QtGui.QAction('Show Log Data', self)
        self.showLogDataAction.setStatusTip('Show all log data from current log file')
        self.showLogDataAction.triggered.connect(self.showLogData)

        self.quickLogAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_quick_log.png'))), 'Quick Log', self, enabled=False)
        self.quickLogAction.setShortcut('Ctrl+K')
        self.quickLogAction.setStatusTip('One-click log. Saves always into file default.log; will be overwritten on next Quick Log click')
        self.quickLogAction.triggered.connect(self.quickLog)

        self.showLogTagsAction = QtGui.QAction('Show Log Comments', self)
        self.showLogTagsAction.setStatusTip('Show only lines from log containing comments')
        self.showLogTagsAction.triggered.connect(self.showLogTags)

        self.showLogExcerptAction = QtGui.QAction('Show Log Data Excerpt', self)
        self.showLogExcerptAction.setStatusTip('Show first and last few lines of current log file')
        self.showLogExcerptAction.triggered.connect(self.showLogDataExcerpt)

        self.countUnit = QtGui.QComboBox()
        self.countUnit.setToolTip("Selector for Units used in the Count Rate Display")
        self.countUnit.addItems(["CPM:", "CPS:", "µSv/h:", "mSv/d:", "mSv/a:"])
        self.countUnit.setFont(QtGui.QFont("", weight=QtGui.QFont.Bold))
        self.countUnit.setStatusTip('Selects the type of count rate to show when logging: CPM, CPS, µSv/h')
        self.countUnit.currentIndexChanged.connect(self.changedCountUnit)

        self.labelCPM = QtGui.QLabel("---")
        self.labelCPM.setToolTip("Count Rate Display - Click to get a new log value")
        self.labelCPM.setMinimumWidth(100)
        self.labelCPM.setFont(QtGui.QFont('sans', 20, QtGui.QFont.Bold))
        self.labelCPM.setStyleSheet('color:darkgray;')
        self.labelCPM.setAlignment(QtCore.Qt.AlignCenter) # option: AlignLeft
        self.labelCPM.setStatusTip('Shows the count rate when logging is active - Click for a new log value')
        #self.labelCPM.mousePressEvent=self.mousePressEvent
        self.labelCPM.mousePressEvent=self.getManualLogValue

        countLabel = QtGui.QHBoxLayout()
        countLabel.addWidget(self.countUnit)
        countLabel.addWidget(self.labelCPM)
        #countLabel.addStretch(10)

        countGroup = QtGui.QGroupBox()
        countGroup.setLayout(countLabel)
        # next: required to correct for gtk alignment problem
        # border is made invisible by setting to background color
        countGroup.setStyleSheet("QGroupBox{ border:1px solid rgb(242,241,240);}")

        loggingMenu = menubar.addMenu('&Log')
        loggingMenu.addAction(self.logLoadFileAction)
        loggingMenu.addAction(self.startloggingAction)
        loggingMenu.addAction(self.stoploggingAction)
        loggingMenu.addAction(self.quickLogAction)
        loggingMenu.addAction(self.addCommentAction)
        loggingMenu.addAction(self.showLogDataAction)
        loggingMenu.addAction(self.showLogTagsAction)
        loggingMenu.addAction(self.showLogExcerptAction)
        #loggingMenu.triggered[QtGui.QAction].connect(self.processtrigger)

        toolbar     = self.addToolBar('Log')
        toolbar.setToolTip("Log Toolbar")
        toolbar.setIconSize(QtCore.QSize(32,32))  # standard size is too small
        toolbar.addAction(self.logLoadFileAction)
        toolbar.addAction(self.startloggingAction)
        toolbar.addAction(self.quickLogAction)
        toolbar.addWidget(countGroup)
        toolbar.addAction(self.stoploggingAction)

#History Menu
        self.histLoadBinAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_hist_bin_active.png'))), 'Get History from Binary File', self)
        self.histLoadBinAction.setShortcut('Ctrl+B')
        self.histLoadBinAction.setStatusTip('Load history data from binary file and plot')
        self.histLoadBinAction.triggered.connect(lambda: self.getHistory("Binary File"))

        self.histLoadHisAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_hist_his_active.png'))), 'Get History from Parsed File', self)
        self.histLoadHisAction.setShortcut('Ctrl+P')
        self.histLoadHisAction.setStatusTip('Load history data from parsed history file and plot')
        self.histLoadHisAction.triggered.connect(lambda: self.getHistory("Parsed File"))

        self.histDeviceAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_hist_device_active.png'))), 'Get History from Device ', self, enabled=False)
        self.histDeviceAction.setShortcut('Ctrl+H')
        self.histDeviceAction.setStatusTip('Load history data from device and plot; requires Device connection')
        self.histDeviceAction.triggered.connect(lambda: self.getHistory("Device"))

        self.showHistHisDataAction = QtGui.QAction('Show History Parsed Data', self)
        #self.showHistHisDataAction.setShortcut('Ctrl+S')
        self.showHistHisDataAction.setStatusTip('Show history data parsed from binary data')
        self.showHistHisDataAction.triggered.connect(self.showHistHisData)

        self.showHistHisTagsAction = QtGui.QAction('Show History Tags/Comments', self)
        #self.showHistHisTagsAction.setShortcut('Ctrl+S')
        self.showHistHisTagsAction.setStatusTip('Show only lines from history containing tags or comments')
        self.showHistHisTagsAction.triggered.connect(self.showHistHisTags)

        self.showHistBinDataAction = QtGui.QAction('Show History Binary Data', self)
        #self.showHistBinDataAction.setShortcut('Ctrl+L')
        self.showHistBinDataAction.setStatusTip('Show history binary data in human readable form')
        self.showHistBinDataAction.triggered.connect(self.showHistBinData)

        self.showHistExcerptAction = QtGui.QAction('Show History Data Excerpt', self)
        #self.showHistExcerptAction.setShortcut('Ctrl+S')
        self.showHistExcerptAction.setStatusTip('Show first and last few lines of both binary and parsed data')
        self.showHistExcerptAction.triggered.connect(self.showHistExcerpt)

        historyMenu = menubar.addMenu('Histor&y')
        historyMenu.addAction(self.histDeviceAction)
        historyMenu.addAction(self.histLoadBinAction)
        historyMenu.addAction(self.histLoadHisAction)
        historyMenu.addAction(self.showHistBinDataAction)
        historyMenu.addAction(self.showHistHisDataAction)
        historyMenu.addAction(self.showHistHisTagsAction)
        historyMenu.addAction(self.showHistExcerptAction)
        #historyMenu.triggered[QtGui.QAction].connect(self.processtrigger)

        toolbar     = self.addToolBar('History')
        toolbar.setToolTip("History Toolbar")
        toolbar.setIconSize(QtCore.QSize(32,32))  # standard size is too small
        toolbar.addAction(self.histDeviceAction)
        toolbar.addAction(self.histLoadBinAction)
        toolbar.addAction(self.histLoadHisAction)

# Web menu
        webStatusTip  = 'Update Radiation World Maps using average of data shown in the plot'
        webActionText = 'Update Radiation World Maps'
        # menu entry
        self.webMapAction = QtGui.QAction(webActionText, self, enabled = False)
        self.webMapAction.setStatusTip(webStatusTip)
        self.webMapAction.triggered.connect(self.pushToWeb)

        # toolbar button
        self.WebAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_map.png'))), webActionText, self, enabled=False)
        self.WebAction.setStatusTip(webStatusTip)
        self.WebAction.triggered.connect(self.pushToWeb)

        webMenu = menubar.addMenu('&Web')
        webMenu.addAction(self.webMapAction)
        #webMenu.triggered[QtGui.QAction].connect(self.processtrigger)

        toolbar     = self.addToolBar('Web')
        toolbar.setToolTip("Web Toolbar")
        toolbar.setIconSize(QtCore.QSize(32,32))  # standard size is too small
        toolbar.addAction(self.WebAction)


#Help Menu
        self.helpQickStartAction = QtGui.QAction('Quickstart', self)
        self.helpQickStartAction.setStatusTip('Guidance for an easy start')
        self.helpQickStartAction.triggered.connect(self.helpQuickStart)

        self.helpManualUrlAction = QtGui.QAction('GeigerLog Manual', self)
        self.helpManualUrlAction.setStatusTip('Open the GeigerLog Manual (locally if available, or online)')
        self.helpManualUrlAction.triggered.connect(self.openUrl)

        self.helpWorldMapsAction = QtGui.QAction('Radiation World Maps', self)
        self.helpWorldMapsAction.setStatusTip('Contributing to the Radiation World Maps')
        self.helpWorldMapsAction.triggered.connect(self.helpWorldMaps)

        self.helpOccupationalRadiationAction = QtGui.QAction('Occupational Radiation Limits', self)
        self.helpOccupationalRadiationAction.setStatusTip('Occupational Radiation Limits in USA and Germany')
        self.helpOccupationalRadiationAction.triggered.connect(self.helpOccupationalRadiation)

        self.DeviceUSBDiscoveryAction = QtGui.QAction('USB Autodiscovery', self)
        self.DeviceUSBDiscoveryAction.setStatusTip('Finding the USB Port and the Baudrate automatically')
        self.DeviceUSBDiscoveryAction.triggered.connect(self.USBautoDiscovery)

        self.helpAboutAction = QtGui.QAction('About GeigerLog', self)
        self.helpAboutAction.setStatusTip('About the GeigerLog program')
        self.helpAboutAction.triggered.connect(self.helpAbout)

        # next entries no longer in menu; visible only on devel as button
        self.helpOptionsAction = QtGui.QAction('Options', self)
        self.helpOptionsAction.setStatusTip('Show command line options')
        self.helpOptionsAction.triggered.connect(self.helpOptions)

        self.changeOptionsAction = QtGui.QAction('Change Options', self)
        self.changeOptionsAction.setStatusTip('Allows to change some command line options during running')
        self.changeOptionsAction.triggered.connect(self.changeOptions)

        self.helpSystemInfoAction = QtGui.QAction('System Info', self)
        self.helpSystemInfoAction.setStatusTip('Show Details on the Current Program Settings and Environment')
        self.helpSystemInfoAction.triggered.connect(self.showSystemInfo)

        helpMenu = menubar.addMenu('&Help')
        helpMenu.addAction(self.helpQickStartAction)
        helpMenu.addAction(self.helpManualUrlAction)
        helpMenu.addAction(self.helpWorldMapsAction)
        helpMenu.addAction(self.helpOccupationalRadiationAction)
        helpMenu.addSeparator()
        #    helpMenu.addAction(self.helpOptionsAction)
        #    helpMenu.addAction(self.changeOptionsAction)
        #    helpMenu.addAction(self.helpSystemInfoAction)
        helpMenu.addAction(self.DeviceUSBDiscoveryAction)
        helpMenu.addSeparator()
        helpMenu.addAction(self.helpAboutAction)
        #helpMenu.triggered[QtGui.QAction].connect(self.processtrigger)

# DataOptions
        # labels and entry fields
        dltitle  = QtGui.QLabel("Data")
        dltitle.setFont(QtGui.QFont("system", weight=QtGui.QFont.Bold))
        dlcf     = QtGui.QLabel("Files")
        dlcf.setAlignment(QtCore.Qt.AlignCenter)
        dlcy     = QtGui.QLabel("Cycle(s)")
        dlcy.setAlignment(QtCore.Qt.AlignCenter)
        dlunit   = QtGui.QLabel("CPM/CPS")
        dlunit.setAlignment(QtCore.Qt.AlignCenter)

        dllog=QtGui.QLabel("Log:")
        self.dcfLog=QtGui.QLineEdit()
        self.dcfLog.setReadOnly(True)
        self.dcfLog.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")
        self.dcfLog.setStatusTip('The full path of the Log-File if any is loaded')

        self.dcycl  = QtGui.QLineEdit()
        self.dcycl.setStatusTip('The logging cycle to be used in seconds')
        self.dcycl.setMaximumWidth(60)

        self.dcunit = QtGui.QComboBox()
        self.dcunit.addItems(["CPM", "CPS"])
        self.dcunit.setStatusTip('The count rate logged as CPM or CPS')
        self.dcunit.setMaximumWidth(70)

        dlhist=QtGui.QLabel("History:")
        self.dcfHis=QtGui.QLineEdit()
        self.dcfHis.setReadOnly(True)
        self.dcfHis.setStyleSheet("QLineEdit { background-color : #DFDEDD; color : rgb(80,80,80); }")
        self.dcfHis.setStatusTip('The full path of the History-File if any is loaded')

        #data buttons
        dbtnPlotLog =  QtGui.QPushButton('Plot')
        dbtnPlotLog.clicked.connect(lambda: self.plotGraph('Log'))
        dbtnPlotLog.setMaximumWidth(36)
        dbtnPlotLog.setStatusTip("Plot the Logging Data")

        dbtnPlotHis =  QtGui.QPushButton('Plot')
        dbtnPlotHis.clicked.connect(lambda: self.plotGraph('His'))
        dbtnPlotHis.setMaximumWidth(36)
        dbtnPlotHis.setStatusTip("Plot the History Data")

        dbtnApplyData = QtGui.QPushButton('Apply')
        dbtnApplyData.clicked.connect(self.applyDataOptions)
        dbtnApplyData.setStyleSheet("background-color: lightblue")
        #dbtnApplyData.setFont(QtGui.QFont("system", weight=QtGui.QFont.Bold))
        dbtnApplyData.setStatusTip("Apply the Data Options to the logging settings")
        dbtnApplyData.setMaximumWidth(60)

        # button clear notepad
        clearbutton    =  QtGui.QPushButton('Clear NotePad')
        clearbutton.clicked.connect(self.clearNotePad)
        clearbutton.setStatusTip('Delete all content of the NotePad')

        # button halt notepad (aka stop printing)
        haltbutton    =  QtGui.QPushButton('StopPad')
        haltbutton.clicked.connect(self.haltNotePad)
        haltbutton.setMaximumWidth(60)
        haltbutton.setStatusTip('Stop printing to the NotePad')

        #layout the Data Options
        dOptions=QtGui.QGridLayout()
        dOptions.setColumnMinimumWidth (2, 80)
        dOptions.setColumnMinimumWidth (3, 50)

        #dOptions.setColumnStretch (1,1000)
        dOptions.addWidget(dltitle,          0, 0)
        dOptions.addWidget(dlcf,             0, 2)
        dOptions.addWidget(dlcy,             0, 3)
        dOptions.addWidget(dlunit,           0, 4)
        dOptions.addWidget(dbtnPlotLog,      1, 1)
        dOptions.addWidget(dbtnPlotHis,      2, 1)
        dOptions.addWidget(dllog,            1, 0)
        dOptions.addWidget(self.dcfLog,      1, 2)
        dOptions.addWidget(self.dcycl,       1, 3)
        dOptions.addWidget(self.dcunit,      1, 4)
        dOptions.addWidget(dlhist,           2, 0)
        dOptions.addWidget(self.dcfHis,      2, 2)
        dOptions.addWidget(dbtnApplyData,    1, 5)
        dOptions.addWidget(haltbutton,       2, 3)
        dOptions.addWidget(clearbutton,      2, 4, 1, 2)

        # group Data Options into box
        dataGroup = QtGui.QGroupBox()
        dataGroup.setLayout(dOptions)
        dataGroup.setMinimumHeight(130)
        dataGroup.setMaximumHeight(130)

# GraphOptions
        # labels and entry fields
        ltitle  = QtGui.QLabel("Graph")
        ltitle.setFont(QtGui.QFont("system", weight=QtGui.QFont.Bold))
        lmin    = QtGui.QLabel("Min")
        lmin.setAlignment(QtCore.Qt.AlignCenter)
        lmax    = QtGui.QLabel("Max")
        lmax.setAlignment(QtCore.Qt.AlignCenter)
        lunit   = QtGui.QLabel("Unit\nDisplayed")
        lunit.setAlignment(QtCore.Qt.AlignCenter)
        lmode   = QtGui.QLabel("Scale")
        lmode.setAlignment(QtCore.Qt.AlignCenter)
        lavg    = QtGui.QLabel("Avg")
        lavg.setAlignment(QtCore.Qt.AlignCenter)
        llog    = QtGui.QLabel("Log")
        llog.setAlignment(QtCore.Qt.AlignCenter)
        lcum    = QtGui.QLabel("CAvg")
        lcum.setAlignment(QtCore.Qt.AlignCenter)
        lmav    = QtGui.QLabel("MovAvg(s)")
        lmav.setAlignment(QtCore.Qt.AlignCenter)

        ewidth = 120
        lcounts=QtGui.QLabel("Counts:")
        self.ymin=QtGui.QLineEdit()
        self.ymin.setMaximumWidth(ewidth)
        self.ymin.setStatusTip('Minimum setting for Count-axis (effective only when Scale is set to Fix)')

        self.ymax=QtGui.QLineEdit()
        self.ymax.setMaximumWidth(ewidth)
        self.ymax.setStatusTip('Maximum setting for Count-axis (effective only when Scale is set to Fix)')

        self.yunit = QtGui.QComboBox()
        self.yunit.addItems(["CPM", "CPS", "µSv/h"])
        self.yunit.setMaximumWidth(80)
        self.yunit.setStatusTip('Select a plot of CPM or CPS or µSv/h vs. time - does NOT depend on the data being collected by CPM or CPS')

        self.ymode = QtGui.QComboBox()
        self.ymode.addItems(["auto", "fix"])
        self.ymode.setMaximumWidth(65)
        self.ymode.setStatusTip('On auto the graph will select min and max of Count axis, on fix the entered values will be used; then both min and max must be given')

        chk_width = 20

        self.avgbox = QtGui.QCheckBox()
        self.avgbox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.avgbox.setChecked(gglobs.avgChecked)
        self.avgbox.setTristate (False)
        self.avgbox.setStatusTip("If checked Average and ±95% lines will be shown")
        self.avgbox.setMaximumWidth(chk_width)
        self.avgbox.setMinimumWidth(chk_width)

        self.cumbox = QtGui.QCheckBox()
        self.cumbox.setChecked(gglobs.cumChecked)
        self.cumbox.setTristate (False)
        self.cumbox.setStatusTip("If checked the cumulative average of count rate will be shown")
        self.cumbox.setMaximumWidth(chk_width)
        self.cumbox.setMinimumWidth(chk_width)

        self.logbox = QtGui.QCheckBox()
        self.logbox.setChecked(gglobs.logChecked)
        self.logbox.setTristate (False)
        self.logbox.setStatusTip("If checked the logarithm (base 10) of count rate will be shown")
        self.logbox.setMaximumWidth(chk_width)
        self.logbox.setMinimumWidth(chk_width)

        self.mavbox = QtGui.QCheckBox()
        self.mavbox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.mavbox.setChecked(gglobs.mavChecked)
        self.mavbox.setTristate (False)
        self.mavbox.setStatusTip('If checked a Moving Average line will be drawn')
        self.mavbox.setMaximumWidth(chk_width)
        self.mavbox.setMinimumWidth(chk_width)

        self.mav=QtGui.QLineEdit()
        self.mav.setMaximumWidth(60)
        self.mav.setStatusTip('Enter the Moving Average smoothing period in seconds')
        self.mav.setText(str(gglobs.mav_initial))

        ltime=QtGui.QLabel("Time:")
        self.xmin=QtGui.QLineEdit()
        self.xmin.setMaximumWidth(ewidth)
        self.xmin.setStatusTip('The minimum (left) limit of the time to be shown. Enter manuallly or by left-mouse-click on the graph')

        self.xmax=QtGui.QLineEdit()
        self.xmax.setMaximumWidth(ewidth)
        self.xmax.setStatusTip('The maximum (right) limit of the time to be shown. Enter manuallly or by right-mouse-click on the graph')

        self.xunit = QtGui.QComboBox()
        self.xunit.addItems(["Time", "auto", "second", "minute", "hour", "day"])
        self.xunit.setMaximumWidth(80)
        self.xunit.currentIndexChanged.connect(self.changedTimeUnit)
        self.xunit.setStatusTip('The time axis to be shown as Time-of-Day (Time) or time since first record in seconds, minutes, hours, days; auto selects most appropriate period')

        self.xmode = QtGui.QComboBox()
        self.xmode.addItems(["auto", "fix"])
        self.xmode.setMaximumWidth(65)
        self.xmode.setStatusTip('On auto the graph will determine the limits; on fix the entered values will be used; then both min and max must be given')

        btn_width = 40

        btnHistogram =  QtGui.QPushButton('Poiss')
        btnHistogram.clicked.connect(lambda: self.plotPoisson('plot'))
        btnHistogram.setMaximumWidth(btn_width)
        btnHistogram.setMinimumWidth(btn_width)
        btnHistogram.setStatusTip("Shows a Poisson curve on a histogram of only the data in the current plot")

        btnFFT =  QtGui.QPushButton('FFT')
        btnFFT.clicked.connect(lambda: self.plotFFT('plot'))
        btnFFT.setMaximumWidth(btn_width)
        btnFFT.setMinimumWidth(btn_width)
        btnFFT.setStatusTip("Show the FFT spectra & an Autocorrelation of the data in the plot")

        btnPlotStats =  QtGui.QPushButton('Stats')
        btnPlotStats.clicked.connect(self.printPlotStats)
        #btnPlotStats.setMaximumWidth(btn_width)    # comment out to allow to use all the space
        btnPlotStats.setStatusTip("Print the Statistics of the data points currently plotted")

        self.btnPlotCCD =  QtGui.QPushButton('CCD')
        self.btnPlotCCD.clicked.connect(self.PlotCCD)
        self.btnPlotCCD.setMaximumWidth(btn_width)
        self.btnPlotCCD.setStatusTip("Plot the Cumulative of Count Rate Deviation (= actual Count Rate - average Count Rate)")
        self.btnPlotCCD.setCheckable(True)
        self.btnPlotCCD.setChecked(False)

        self.btnMoveLegend = QtGui.QPushButton('Move Lgd')
        self.btnMoveLegend.clicked.connect(self.moveLegend)
        #self.btnMoveLegend.setMaximumWidth(80)
        self.btnMoveLegend.setStatusTip("Move the Graphs Legend to a different place on the Graph")

        btnReset  = QtGui.QPushButton('Reset')
        btnReset.clicked.connect(self.resetGraph)
        btnReset.setMaximumWidth(60)
        btnReset.setStatusTip("Reset the Graph Options to the Default condisions")

        btnApplyGraph = QtGui.QPushButton('Apply')
        btnApplyGraph.clicked.connect(self.applyGraphOptions)
        btnApplyGraph.setStyleSheet("background-color: lightblue")
        #btnApplyGraph.setFont(QtGui.QFont("system", weight=QtGui.QFont.Bold))
        #btnApplyGraph.setMaximumWidth(80)
        btnApplyGraph.setStatusTip("Apply the Graph Options and replot")
        btnApplyGraph.setAutoDefault(True)

        vline0 = QtGui.QFrame()
        vline0.setFrameShape(QtGui.QFrame.VLine)

        vline1 = QtGui.QFrame()
        vline1.setFrameShape(QtGui.QFrame.VLine)

        vline2 = QtGui.QFrame()
        vline2.setFrameShape(QtGui.QFrame.VLine)

        #layout the GraphOptions
        gOptions=QtGui.QGridLayout()
        gOptions.addWidget(ltitle,          0, 0)
        gOptions.addWidget(lmin,            0, 1)
        gOptions.addWidget(lmax,            0, 2)
        gOptions.addWidget(lunit,           0, 3)
        gOptions.addWidget(lmode,           0, 4)
        gOptions.addWidget(lavg,            0, 5)
        gOptions.addWidget(llog,            0, 6)
        #gOptions.addWidget(lcum,            0, 6)
        gOptions.addWidget(lmav,            0, 7, 1, 2)
        gOptions.addWidget(vline0,          0, 9)
        gOptions.addWidget(btnHistogram,    0, 10)
        gOptions.addWidget(btnFFT,          0, 11)

        gOptions.addWidget(lcounts,         1, 0)
        gOptions.addWidget(self.ymin,       1, 1)
        gOptions.addWidget(self.ymax,       1, 2)
        gOptions.addWidget(self.yunit,      1, 3)
        gOptions.addWidget(self.ymode,      1, 4)
        gOptions.addWidget(self.avgbox,     1, 5)
        gOptions.addWidget(self.logbox,     1, 6)
        #gOptions.addWidget(self.cumbox,     1, 6)
        gOptions.addWidget(self.mavbox,     1, 7)
        gOptions.addWidget(self.mav,        1, 8)
        gOptions.addWidget(vline1,          1, 9)
        #gOptions.addWidget(self.btnPlotCCD, 1, 10)
        #gOptions.addWidget(btnPlotStats,    1, 11)
        gOptions.addWidget(btnPlotStats,    1, 10, 1, 2)

        gOptions.addWidget(ltime,           2, 0)
        gOptions.addWidget(self.xmin,       2, 1)
        gOptions.addWidget(self.xmax,       2, 2)
        gOptions.addWidget(self.xunit,      2, 3)
        gOptions.addWidget(self.xmode,      2, 4)
        gOptions.addWidget(btnReset,        2, 5, 1, 2)
        gOptions.addWidget(btnApplyGraph,   2, 7, 1, 2)
        gOptions.addWidget(vline2,          2, 9)
        gOptions.addWidget(self.btnMoveLegend,   2, 10, 1, 2)

        # group Graph Options into box
        group = QtGui.QGroupBox()
        group.setLayout(gOptions)
        group.setMinimumHeight(130)
        group.setMaximumHeight(130)

# NotePad, to be added below data
        self.notePad = QtGui.QTextEdit()
        self.notePad.setReadOnly(True)
        self.notePad.setFont(self.fontstd)
        self.notePad.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        #self.notePad.setLineWrapMode(QtGui.QTextEdit.WidgetWidth)
        #self.notePad.setStyleSheet("color:black; weight: bold;")
        #self.notePad.setColor(QtGui.QColor("#000000"))
        #self.notePad.setMinimumWidth(600)
        #self.notePad.setStyleSheet("background-color: #f8f8f8;")  # off white
        #self.notePad.setStyleSheet("background-color: #F7FDFF;") # very light blue
        #self.notePad.setTextBackgroundColor(QColor(/rgb(0xF7, 0xFD, 0xFF))
        #self.notePad.setBackgroundColor(QtGui.QColor("#a7FDFF"))
        #dprint(gglobs.debug, "Fonts: notePad -", strFontInfo("", self.notePad.fontInfo()))

# LogPad, to be added below graph
        self.logPad = QtGui.QTextEdit()
        self.logPad.setReadOnly(True)
        self.logPad.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        #self.logPad.setLineWrapMode(QtGui.QTextEdit.WidgetWidth)
        self.logPad.setFont(self.fontstd)
        #dprint(gglobs.debug, "Fonts: logPad  -", strFontInfo("", self.logPad.fontInfo()))
        #self.logPad.setMinimumWidth(800)
        #self.logPad.setColor(0xFFFFFF)
        #self.logPad.setStyleSheet("color:black;")
        #self.logPad.setStyleSheet("background-color: yellow;")
        #self.logPad.setStyleSheet("color:blue;padding:2px; margin:3px;background-color: yellow;")
        #self.logPad.setStyleSheet("background-color: lightyellow;")
        #self.logPad.setStyleSheet("font-family:Monospace;")

# set the layout - left
        layoutPad = QtGui.QVBoxLayout()
        layoutPad.addWidget(dataGroup)
        if gglobs.devel:
            layoutPad.addLayout(layout2)  # only Spare button, keep for tests
        layoutPad.addWidget(self.notePad)


# set the layout - right
        graphbox = QtGui.QVBoxLayout()
        graphbox.addWidget(self.canvas)
        graphbox.setMargin(0)

        graphgroup = QtGui.QGroupBox()
        graphgroup.setLayout(graphbox)

        layoutGraph = QtGui.QVBoxLayout()
        layoutGraph.addWidget(group)
        layoutGraph.addWidget(graphgroup)
        layoutGraph.addWidget(self.logPad)
        #layoutGraph.addStretch(10)

# set the layout - both
        grid = QtGui.QGridLayout()
        grid.addLayout(layoutPad,   0, 0)
        grid.addLayout(layoutGraph, 0, 1)

# add navigation toolbar as last toolbar
        self.addToolBar(self.navtoolbar)
        self.navtoolbar.setToolTip("Graph Toolbar")

# centralwidget
        centralwidget = QtGui.QWidget()
        centralwidget.setLayout(grid)
        self.setCentralWidget(centralwidget)

#set gglobs (still used for fprint in utils)
        gglobs.NotePad = self.notePad

#timer for logging
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.getLogValue)

#show
        self.dcfLog.setText(str(gglobs.logFilePath))     # default is None
        self.dcfHis.setText(str(gglobs.hisFilePath))
        self.dcycl. setText(str(gglobs.logcycle))

        self.show()
        if gglobs.window_size == "maximized":
            self.showMaximized()

        vprint(gglobs.verbose, "Fonts: App     -",       strFontInfo("", app.font()))  # print font info for QApplication
        vprint(gglobs.verbose, "Fonts: logPad  -",       strFontInfo("", self.logPad.fontInfo()))
        vprint(gglobs.verbose, "Fonts: notePad -",       strFontInfo("", self.notePad.fontInfo()))
        vprint(gglobs.verbose, "Fonts: menubar -",       strFontInfo("", menubar.fontInfo()))
        vprint(gglobs.verbose, "Screen: Dimensions: ",   QtGui.QDesktopWidget().screenGeometry()) # gives screen dimensions
        vprint(gglobs.verbose, "Screen: Available:  ",   screen_available)                        # gives screen dimensions available

        # Note on Windows sizes:
        # "On X11, a window does not have a frame until the window manager decorates it."
        # see: http://doc.qt.io/qt-4.8/application-windows.html#window-geometry
        dprint(gglobs.debug, "Window: Dimensions: ", self.geometry(), " w/o Frame") # gives Windows dimensions but has the frame EXCLUDED!
        dprint(gglobs.debug, "Window: Dimensions: ", self.frameGeometry(), " WITH Frame (not valid on X11)") # self.frameGeometry() gives Windows dimensions including frame, but not on X11!

        # Devel Data - start GeigerLog with command 'devel' e.g.: 'geigerlog -dv devel'
        if gglobs.devel:
            testFile = gglobs.dataPath + "/testdata/TESTDATA.log"
            testFile = gglobs.dataPath + "/default.log"
            #testFile = gglobs.dataPath + "/COPYduenger1.log"
            #testFile = gglobs.dataPath + "/Synthetic/" + "WhiteNoisePoisson, mean=20.0.log"
            #testFile = gglobs.dataPath + "/Synthetic/" + "WhiteNoisePoisson, mean=2.5, cycle=1.0, mode=CPS.log"

            if os.access(testFile , os.R_OK):
                self.getLogFile(defaultFile = testFile)
            else:
                dprint(True, "Testfile '{}' not found".format(testFile))

        # copyright message
        message = __copyright__ + ", by " + __author__ + ", License: " + __license__
        self.statusBar.showMessage(message, 0)  # message remains until overwritten by next

        dprint(gglobs.debug, "Startup complete\n")


##  test1  #################################
        #if gglobs.test1:
        #    dprint(True, "Preparing for test1")
        #    gglobs.ser, errmessage = gcommands.serialOPEN(gglobs.usbport, gglobs.baudrate, gglobs.timeout)
        #    gcommands.test1()
        #    self.close()



#========== END initUI(self) ==================================================
#========== BEGIN Class Functions =============================================

    def xxxmousePressEvent(self, event):
        """Take a measurement when a mouse click occurs ANYWHERE in the
        centralwidget area outside other widgets (leaves the frame)"""

        print("event:", event)
        print("event type:", event.type())
        #vprint(gglobs.verbose, "mousePressEvent: button:", event.button())
        if gglobs.logging:
            if event.button() == 1: # left mouse button
                dprint(gglobs.debug, "mousePressEvent: Get Logvalue")
                debugIndent(1)

                cpm = self.getLogValue()
                self.print2NotePad(header("Manually Triggered Log Value"))
                usvh = cpm * gglobs.calibration
                self.print2NotePad("{} :   {}  =  {:3.2f} µSv/h  =  {:3.2f} mSv/d  =  {:3.2f} mSv/a".format("CPM", cpm, usvh, usvh /1000 * 24, usvh /1000 *24 *365))

                debugIndent(0)


    def getManualLogValue(self, event):
        """Take a measurement when the count rate area is left clicked"""

        #print("event:", event, "event type:", event.type())
        if gglobs.logging:
            if event.button() == 1: # left mouse button
                vprint(gglobs.verbose, "getManualLogValue:")
                debugIndent(1)

                cpm  = self.getLogValue()
                usvh = cpm * gglobs.calibration
                msg  = "{} :   {}  =  {:3.2f} µSv/h  =  {:3.2f} mSv/d  =  {:3.2f} mSv/a".format("CPM", cpm, usvh, usvh /1000 * 24, usvh /1000 *24 *365)
                self.print2NotePad(header("Manually Triggered Log Value"))
                self.print2NotePad(msg)
                vprint(gglobs.verbose, "getManualLogValue: " + msg)

                debugIndent(0)


#exit GeigerLog
    def closeEvent(self, event):
        """
        is called via self.close!
        Allow to Exit unless Logging is active
        """

        dprint(gglobs.debug, "closeEvent: event: {}".format(event))
        debugIndent(1)

        if gglobs.logging :
            msg = "Can't exit because logging is active! Stop logging first"
            self.showStatusMessage(msg)
            okToExit = False
        else:
            msg = "Exiting now"
            okToExit = True

        dprint(gglobs.debug, "closeEvent: " + msg)
        debugIndent(0)

        if okToExit:
            event.accept() # let the window close
            #print "event.accept() done"

            QtGui.QApplication.quit()              # works but keeps prog running, CTRL-C needed
            QtGui.QApplication.closeAllWindows()   # works but keeps prog running, CTRL-C needed
            sys.exit(0)                            # required to really shutdown the program
        else:
            event.ignore()
            #print "event.ignore() done"


#Data Options
    def applyDataOptions(self):

        oldlogcycle = gglobs.logcycle
        oldcpmflag  = gglobs.cpmflag
        if oldcpmflag == True:
            oldunitIndex = 0
        else:
            oldunitIndex = 1

        logcycle  = self.dcycl.text().replace(",", ".")  #replace comma with dot
        unitIndex = self.dcunit.currentIndex() # Index=0-> CPM; =1->CPS

        try:
            lc = float(logcycle)
        except:
            lc = 0

        if lc < 0.1:
            self.print2NotePad("ERROR: Log cycle must be a number and at least 0.1 sec")
            self.dcycl.setText(str(oldlogcycle))
            self.dcunit.setCurrentIndex(oldunitIndex)
            return
        else:
            gglobs.logcycle = lc
            if unitIndex == 0:
                gglobs.cpmflag = True
            else:
                gglobs.cpmflag = False

        vprint(gglobs.verbose, "New Data Options: Cycle={}sec, mode={}".format(gglobs.logcycle, "CPM" if gglobs.cpmflag else "CPS"))

        if gglobs.logging:              # if ongoing logging
            self.stopTimer()            # stop/start to set timer
            self.startTimer()           # for new cycle


#GraphOptions
    def applyGraphOptions(self):

        if gglobs.currentFilePath == None: return

        #replace comma with dot, strip outer whitespace
        xmin  = (str(self.xmin.text()).replace(",", ".")).strip()
        xmax  = (str(self.xmax.text()).replace(",", ".")).strip()
        xunit = str(self.xunit.currentText())
        xmode = str(self.xmode.currentText())

        ymin  = (str(self.ymin.text()).replace(",", ".")).strip()
        ymax  = (str(self.ymax.text()).replace(",", ".")).strip()
        yunit = str(self.yunit.currentText())
        ymode = str(self.ymode.currentText())

        mav   = (str(self.mav.text()).replace(",", ".") ).strip()

        #print "X:", xmin, xmax, xunit, xmode
        #print "Y:", ymin, ymax, yunit, ymode, mav

        if  xmin == "":
            gglobs.Xleft  = None
        else:
            if gglobs.Xunit == "Time":
                try:
                    gglobs.Xleft = mpld.datestr2num(str(xmin))
                except:
                    gglobs.Xleft = None
                    self.errprint2NotePad("Did not recognize Time Min")
            else:
                try:
                    gglobs.Xleft     = float(xmin)
                except:
                    gglobs.Xleft     = None
                    self.errprint2NotePad("Did not recognize Time Min")

        if  xmax == "":
            gglobs.Xright = None
        else:
            if gglobs.Xunit == "Time":
                try:
                    gglobs.Xright = mpld.datestr2num(str(xmax))
                except:
                    gglobs.Xright = None
                    self.errprint2NotePad("Did not recognize Time Max")
            else:
                try:
                    gglobs.Xright    = float(xmax)
                except:
                    gglobs.Xright    = None
                    self.errprint2NotePad("Did not recognize Time Max")

        #print "Xleft ", gglobs.Xleft
        #print "Xright", gglobs.Xright

        if gglobs.Xleft != None and gglobs.Xright != None:
            if gglobs.Xleft >= gglobs.Xright:
                self.errprint2NotePad("Wrong numbers: Time Min must be less than Time Max")
                return

        gglobs.Xunit     = xunit
        gglobs.Xscale    = xmode

        try:
            gglobs.Ymin      = float(ymin)
        except:
            gglobs.Ymin      = None

        try:
            gglobs.Ymax      = float(ymax)
        except:
            gglobs.Ymax      = None

        if gglobs.Ymin != None and gglobs.Ymax != None:
            if gglobs.Ymin >= gglobs.Ymax:
                self.errprint2NotePad("Wrong numbers: Count Rate min must be less than Count Rate max")
                return

        gglobs.Yunit     = yunit
        gglobs.Yscale    = ymode

        try:
            gglobs.mav     = float(mav)
        except:
            gglobs.mav     = gglobs.mav_initial

        gglobs.mavChecked  = self.mavbox.isChecked()
        gglobs.avgChecked  = self.avgbox.isChecked()
        gglobs.logChecked  = self.logbox.isChecked()
        gglobs.cumChecked  = self.cumbox.isChecked()

        self.plotCurrent()


    def moveLegend(self):
        """Reposition Legend in one of the outer positions"""

        if gglobs.currentFilePath == None:
            self.showStatusMessage("No graph displayed")
            return
        if not (gglobs.avgChecked or gglobs.mavChecked):
            self.showStatusMessage("No legend displayed")
            return

        gglobs.legendPos = (gglobs.legendPos + 1) % 9
        gplot.plotLegend()


    def printFileStats(self):
        """Print Statistics for the whole File"""

        if gglobs.currentFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Data Properties - All Data from File"))
        self.print2NotePad("from: {}\n".format(gglobs.currentFilePath))
        gplot.printDataProp()


    def printPlotStats(self):
        """Print Statistics for that part of the File shown in the plot"""

        if gglobs.currentFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Data Properties - Data as selected in Plot"))
        self.print2NotePad("from: {}\n".format(gglobs.currentFilePath))
        gplot.printDataProp(False)


    def plotGraph(self, current = None):

        msg = "No file available"
        if current == None:
            if gglobs.currentFilePath == None:
                self.showStatusMessage(msg)
                return

        elif current == "Log":
            if gglobs.logFilePath == None:
                self.showStatusMessage(msg)
                return
            else:
                gglobs.currentFilePath = gglobs.logFilePath
                gglobs.currentFileData = gglobs.logFileData
                self.dcfLog.setStyleSheet("QLineEdit { background-color: #F9F4C9; color: rgb(80,80,80); }")
                self.dcfHis.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")

        elif current == 'His':
            if gglobs.hisFilePath == None:
                self.showStatusMessage(msg)
                return
            else:
                gglobs.currentFilePath = gglobs.hisFilePath
                gglobs.currentFileData = gglobs.hisFileData
                self.dcfHis.setStyleSheet("QLineEdit { background-color: #F9F4C9; color: rgb(80,80,80); }")
                self.dcfLog.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")

        else:
            dprint(True, "PROGRAMMING ERROR in geigerlog:plotGraph: var current is:", current)
            sys.exit(1)

        self.print2NotePad(header("Plot Data"))
        self.print2NotePad("from: {}".format(gglobs.currentFilePath))

        self.plotCurrent()      # does NOT do a graph option reset

        return


    def resetGraph(self):
        """resets all graph options to start conditions and plots the graph"""


        dprint(gglobs.debug, "resetGraph:")
        debugIndent(1)

        self.xmin.setText("")
        self.xmax.setText("")
        self.ymin.setText("")
        self.ymax.setText("")
        self.mav.setText (str(gglobs.mav_initial))
        self.xunit.setCurrentIndex(0)
        self.yunit.setCurrentIndex(0)
        self.xmode.setCurrentIndex(0)
        self.ymode.setCurrentIndex(0)

        self.clearPlotDefaults()

        self.avgbox.    setChecked(gglobs.avgChecked)
        self.logbox.    setChecked(gglobs.logChecked)
        self.cumbox.    setChecked(gglobs.cumChecked)
        self.mavbox.    setChecked(gglobs.mavChecked)
        self.btnPlotCCD.setChecked(False)
        self.btnPlotCCD.setStyleSheet("color:")

        plt.clf()
        self.plotCurrent()

        debugIndent(0)


    def plotCurrent(self):
        """plots the graph with busy cursor"""

        dprint(gglobs.debug, "plotCurrent:")
        debugIndent(1)

        self.setBusyCursor()
        self.figure.set_facecolor('#F9F4C9') # change color from gray to light yellow
        gplot.makePlot(fprintMAV = True)
        self.setNormalCursor()

        debugIndent(0)


    def changedTimeUnit(self, i):
        """recalc xmin, xmax on Time unit changes"""

        #print "i:", i

        oldXunit = gglobs.XunitCurrent
        #print "oldXunit", oldXunit

        if oldXunit == "Time":
            if gglobs.Xleft != None:
                gglobs.Xleft = gglobs.Xleft - gglobs.logTimeFirst
            if gglobs.Xright != None:
                gglobs.Xright = gglobs.Xright - gglobs.logTimeFirst

        elif oldXunit == "day": # no changes all in days
            if gglobs.Xleft != None:
                gglobs.Xleft = gglobs.Xleft
            if gglobs.Xright != None:
                gglobs.Xright = gglobs.Xright

        elif oldXunit == "hour":
            if gglobs.Xleft != None:
                gglobs.Xleft = gglobs.Xleft / 24.
            if gglobs.Xright != None:
                gglobs.Xright = gglobs.Xright / 24.

        elif oldXunit == "minute":
            if gglobs.Xleft != None:
                gglobs.Xleft = gglobs.Xleft / 1440.
            if gglobs.Xright != None:
                gglobs.Xright = gglobs.Xright / 1440.

        elif oldXunit == "second":
            if gglobs.Xleft != None:
                gglobs.Xleft = gglobs.Xleft / 86400.
            if gglobs.Xright != None:
                gglobs.Xright = gglobs.Xright / 86400.


        #print " gglobs.logTimeFirst", gglobs.logTimeFirst
        #print " gglobs.Xleft",  gglobs.Xleft
        #print " gglobs.Xright", gglobs.Xright

        gglobs.XunitCurrent = str(self.xunit.currentText())
        newXunit            = gglobs.XunitCurrent

        if newXunit == "auto":
            l = gglobs.logTime.max() - gglobs.logTime.min()
            #print "l=", l
            if l > 3:
                Xunit = "day"
            elif l * 24. > 3:
                #print l * 24.
                Xunit = "hour"
            elif l * 1440. > 3:
                #print l *1440.
                Xunit = "minute"
            else:
                Xunit = "second"

            newXunit = Xunit


        gglobs.XunitCurrent = newXunit
        gglobs.Xunit        = newXunit
        #print "newXunit", newXunit

        if newXunit == "Time":
            if gglobs.Xleft != None:
                gglobs.Xleft =  (str(mpld.num2date((gglobs.Xleft  + gglobs.logTimeFirst))))[:19]
            if gglobs.Xright != None:
                gglobs.Xright = (str(mpld.num2date((gglobs.Xright + gglobs.logTimeFirst))))[:19]

        elif newXunit == "day": # no changes all in days
            if gglobs.Xleft != None:
                gglobs.Xleft = gglobs.Xleft
            if gglobs.Xright != None:
                gglobs.Xright = gglobs.Xright

        elif newXunit == "hour":
            if gglobs.Xleft != None:
                gglobs.Xleft = gglobs.Xleft * 24.
            if gglobs.Xright != None:
                gglobs.Xright = gglobs.Xright * 24.

        elif newXunit == "minute":
            if gglobs.Xleft != None:
                gglobs.Xleft = gglobs.Xleft * 1440.
            if gglobs.Xright != None:
                gglobs.Xright = gglobs.Xright * 1440.

        elif newXunit == "second":
            if gglobs.Xleft != None:
                gglobs.Xleft = gglobs.Xleft * 86400.
            if gglobs.Xright != None:
                gglobs.Xright = gglobs.Xright * 86400.

        #print " gglobs.Xleft",  gglobs.Xleft
        #print " gglobs.Xright", gglobs.Xright
        #print " newXunit", newXunit

        if gglobs.Xleft == None:
            self.xmin.setText("")
        else:
            self.xmin.setText(str(gglobs.Xleft))

        if gglobs.Xright == None:
            self.xmax.setText("")
        else:
            self.xmax.setText(str(gglobs.Xright))

        self.applyGraphOptions()


    def clearPlotDefaults(self):
        """Graphic Options"""

        gglobs.legendPos           = 0                 # upper left
        gglobs.Xleft               = None
        gglobs.Xright              = None
        gglobs.Xunit               = "Time"
        gglobs.Xscale              = "auto"
        gglobs.Ymin                = None
        gglobs.Ymax                = None
        gglobs.Yunit               = "CPM"
        gglobs.Yscale              = "auto"
        gglobs.mav                 = gglobs.mav_initial # length of Moving Average period in seconds
        gglobs.mavChecked          = False
        gglobs.avgChecked          = True
        gglobs.logChecked          = False
        gglobs.cumChecked          = False
        self.xmin.setText("")
        self.xmax.setText("")


    def updatecursorposition(self, event):
        """when cursor inside plot, get position and print to statusbar"""

        if event.inaxes:
            x = event.xdata
            y = event.ydata
            #print x,y

            if gglobs.Xunit == "Time":
                tod = (str(mpld.num2date(x)))[:19]
                t   = gplot.getTsr(gglobs.logTimeFirst, x)
                message = "Time since 1st record: {}, Time: {}, CPM:{:0.1f}".format(t, tod, y)
            else:
                tod = gplot.getToD(gglobs.logTimeFirst, x, gglobs.XunitCurrent)
                t   = "{:0.3f} {}s".format(x, gglobs.XunitCurrent)
                message = "Time since 1st record: {}, Time: {}, CPM:{:0.1f}".format(t, tod, y)

            self.statusBar.showMessage(message, 0)


    def onclick(self, event):
        """on mouseclick in graph enter time coords into xmin, xmax
        left click = xmin, right click = xmax"""

        if event.inaxes:
            x = event.xdata
            y = event.ydata
            b = event.button
            #print event, x,y,b

            if gglobs.Xunit == "Time":
                t = (str(mpld.num2date(x)))[:19]
            else:
                t = str(x)

            if b == 1:                  # left click, xmin
                self.xmin.setText(t)
            elif b == 3:                # right click, xmax
                self.xmax.setText(t)
            else:
                pass


#history
    def getHistory(self, source = "Binary File"):
        """getHistory either from binary file or from parsed file or from device"""

        if source == "Binary File":
            # there must be an existing '*.bin' file and must be allowed to write .lst, .his files
            dlg=QtGui.QFileDialog(caption = "Get History from existing Binary File")
            dlg.setFileMode(QtGui.QFileDialog.ExistingFile)
            dlg.setFilter("History Files (*.bin)")

        elif source == "Parsed File":
            # there must be an existing '*.his' file
            dlg=QtGui.QFileDialog(caption= "Get History from Parsed File")
            dlg.setFileMode(QtGui.QFileDialog.ExistingFile)
            dlg.setFilter("History Files (*.his)")

        else: # source is device
            if gglobs.logging:
                mediaErr.play()
                lheader = header("Get History from Device")
                self.print2NotePad(lheader)
                fprint("Cannot load History from device with ongoing Logging. Stop Logging first", error= True)
                return

            # may use existing or new file, but must be allowed to write new files (.bin, .lst, .his)
            dlg=QtGui.QFileDialog(caption = "Get History from Device - enter new filename or select from existing")
            dlg.setFileMode(QtGui.QFileDialog.AnyFile)
            dlg.setFilter("History Files (*.bin)")

        dlg.setViewMode     (QtGui.QFileDialog.Detail)
        dlg.setWindowIcon   (QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        dlg.setDirectory    (gglobs.fileDialogDir)


        if dlg.exec_() == QtGui.QDialog.Accepted:
            gglobs.fileDialogDir = dlg.directory().path()
            #print("fileDialogDir:", gglobs.fileDialogDir)

            fnames  = dlg.selectedFiles()
            fn      = str(fnames[0])
            #print "fn=", fn
            ext     = os.path.splitext(fn)[1]
            #print "extension=", ext
            fn_base     = os.path.splitext(fn)[0]
            #print "fn_base=", fn_base

            if ext not in  (".bin", ".his", "lst"):
                # if neither ext is given, attach ext to all 3 files
                gglobs.binFilePath = fn + ".bin"
                gglobs.lstFilePath = fn + ".lst"
                gglobs.hisFilePath = fn + ".his"
            else:
                # if either is given, assume basename for all 3 files
                gglobs.binFilePath = fn_base + ".bin"
                gglobs.lstFilePath = fn_base + ".lst"
                gglobs.hisFilePath = fn_base + ".his"
        else: # QtGui.QDialog.Rejected =    0
            return

        #dprint(gglobs.debug, "gglobs.binFilePath:", gglobs.binFilePath)
        #dprint(gglobs.debug, "gglobs.lstFilePath:", gglobs.lstFilePath)
        #dprint(gglobs.debug, "gglobs.hisFilePath:", gglobs.hisFilePath)

        if source == "Binary File":

            lheader = header("Get History from Binary File")

            # Reading ok?
            if not os.access(gglobs.binFilePath, os.R_OK) :
                err_mesg = "Cannot read file - check permission of file: {}".format(gglobs.binFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing into directory ok?
            if not os.access(gglobs.dataPath,    os.W_OK) :
                err_mesg = "Cannot write files - check permission of directory: {}".format(gglobs.dataPath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing *.lst file ok?
            if os.path.isfile(gglobs.lstFilePath) and not os.access(gglobs.lstFilePath, os.W_OK) :
                err_mesg = "Cannot write file - check permission of file: {}".format(gglobs.lstFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing *.his file ok?
            if os.path.isfile(gglobs.hisFilePath) and not os.access(gglobs.hisFilePath, os.W_OK) :
                err_mesg = "Cannot write file - check permission of file: {}".format(gglobs.hisFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

        elif source == "Parsed File":
            lheader = header("Get History from Parsed File")
            if not os.access(gglobs.hisFilePath, os.R_OK) :
                err_mesg = "Cannot read file - check permission of file: {}".format(gglobs.hisFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            gglobs.currentFilePath = gglobs.hisFilePath
            gglobs.binFilePath = None
            gglobs.lstFilePath = None

        else:
            lheader = header("Get History from Device")
            if os.path.isfile(gglobs.binFilePath):
                msg = QtGui.QMessageBox()
                msg.setIcon(QtGui.QMessageBox.Critical)
                msg.setWindowTitle("CAUTION")
                critical  = """You selected an existing file, which will be <b>OVERWRITTEN</b> if you continue. Please confirm with OK.
<br><br>Otherwise click Cancel and enter a new filename in the Get History from Device dialog."""
                msg.setText(critical)
                msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
                msg.setDefaultButton(QtGui.QMessageBox.Cancel)
                msg.setEscapeButton(QtGui.QMessageBox.Cancel)
                retval = msg.exec_()

                if retval == 1024:
                    if not os.access(gglobs.binFilePath, os.W_OK):
                        err_mesg = "Cannot write file - check permission of file: " + gglobs.binFilePath
                        self.print2NotePad(lheader)
                        self.errprint2NotePad(err_mesg)
                        return
                else:
                    return

            # writing to directory ok?
            if not os.access(gglobs.dataPath,    os.W_OK) :
                err_mesg = "Cannot write files - check permission of directory: {}".format(gglobs.dataPath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing bin file ok?
            if os.path.isfile(gglobs.binFilePath) and not os.access(gglobs.binFilePath, os.W_OK) :
                err_mesg = "Cannot write file - check permission of file: {}".format(gglobs.binFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing lst file ok?
            if os.path.isfile(gglobs.lstFilePath) and not os.access(gglobs.lstFilePath, os.W_OK) :
                err_mesg = "Cannot write file - check permission of file: {}".format(gglobs.lstFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing his file ok?
            if os.path.isfile(gglobs.hisFilePath) and not os.access(gglobs.hisFilePath, os.W_OK) :
                err_mesg = "Cannot write file - check permission of file: {}".format(gglobs.hisFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

        self.print2NotePad(lheader)

        dprint(gglobs.debug, "getHistory: history file basename:{} (*.bin, *.lst, *.his)".format(os.path.splitext(gglobs.hisFilePath)[0]))
        debugIndent(1)

        self.setBusyCursor()
        error, message = ghist.makeHIST(source, gglobs.binFilePath, gglobs.lstFilePath, gglobs.hisFilePath)
        self.setNormalCursor()

        if error == 0 or error == 1:
            gglobs.currentFilePath = gglobs.hisFilePath
            self.dcfHis.setText(gglobs.currentFilePath)
            self.dcfHis.setStyleSheet("QLineEdit { background-color: #F9F4C9; color: rgb(80,80,80); }")
            self.dcfLog.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")
            gglobs.hisFileData     = self.getFileData()
            gglobs.currentFileData = gglobs.hisFileData

            self.plotGraph()
            self.clearLogPad()
        else:
            self.errprint2NotePad(message)

        debugIndent(0)


    def myconverter(self, datestr):
        """datestring to number for numpy genfromtxt"""

        #py3string_date = datestr.strip().decode("ASCII") # required by Py3
        py3string_date = datestr.strip().decode("UTF-8") # required by Py3
        datenum = mpld.datestr2num(py3string_date)
        #print("datestr:", datestr, "datenum:", datenum)

        return datenum


    def getFileData(self):
        """c
        read the data from currentFilePath into numpy array per numpy-genfromtxt,
        then split off ByteIndex column, and return timestamp and CPM as 2-column array
        may fail when too few data in file, hence try
        """

        # handling text files with encodings
        # http://python-notes.curiousefficiency.org/en/latest/python3/text_file_processing.html
        # mystring.decode('iso-8859-1').encode('utf8')
        # For Python 3: bytes(apple,'iso-8859-1').decode('utf-8')
        # Using encoding="latin-1" should NEVER give an exception:
        #   with open(gglobs.currentFilePath, "rt", encoding="latin-1") as cfghandle:
        #        llines = cfghandle.readlines()      # llines is list of lines

        start = time.time()
        self.setBusyCursor()

        with open(gglobs.currentFilePath, "rb") as cfghandle: # read BINARY
            llines = cfghandle.readlines()   # llines is list of lines of bytes
        #for i in range(10): print("llines[{}]: {}".format(i,llines[i]))

        # get the data using numpy
        # -- on numpy < 1.14 must use 'file', like:
        #    gendata    = np.genfromtxt(datafile, delimiter=",", converters = {1: old_datestr2num})
        # -- on numpy >=1.14 can use 'list' of lines
        #    gendata    = np.genfromtxt(llist,    delimiter=",", converters = {1: old_datestr2num})
        try:
            # get data from file:
            #origFileData = np.genfromtxt(gglobs.currentFilePath, delimiter=",", converters = {1:self.myconverter})

            # get data from list of bytes
            origFileData = np.genfromtxt(llines, delimiter=",", converters = {1:self.myconverter})
            #print("origFileData:\n", origFileData)

            dataArray    = origFileData[:,1:3]
            #print("dataArray:\n", dataArray)

        except Exception as e:
            # File is without data or conversion has failed
            # or File has only 1 record; 2 records ok
            srcinfo = "ERROR in getFileData - np.genfromtxt"
            exceptPrint(e, sys.exc_info(), srcinfo)
            dataArray    = np.empty([0,2])

        self.setNormalCursor()

        vprint(gglobs.verbose, "getFileData: {:6.1f}ms file loading and parsing into numpy array, ".format((time.time() - start) * 1000.))
        #print( "getFileData: dataArray:\n", dataArray)

        return dataArray


    def showHistExcerpt(self):

        if gglobs.lstFilePath == None and gglobs.hisFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Excerpt of History Data"))

        if gglobs.lstFilePath == None:
            self.print2NotePad("Binary History data not available")
        else:
            self.print2NotePad("from: {}\n".format(gglobs.lstFilePath))
            self.printExcerptLines(gglobs.lstFilePath)

        if gglobs.hisFilePath == None:
            self.print2NotePad("Parsed History data not available")
        else:
            self.print2NotePad("\nfrom: {}\n".format(gglobs.hisFilePath))
            self.printExcerptLines(gglobs.hisFilePath)


    def showHistHisData(self):
        """print HIST parsed data"""

        if gglobs.hisFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Parsed History Data"))
        self.print2NotePad("from: {}\n".format(gglobs.hisFilePath))

        self.setBusyCursor()
        data = readFileLines(gglobs.hisFilePath)
        gglobs.stopPrinting = False
        for a in data:
            self.print2NotePad(a[:-1])
            if gglobs.stopPrinting: break
        gglobs.stopPrinting = False
        self.setNormalCursor()


    def showHistHisTags(self):
        """print comments only from HIST parsed data"""

        if gglobs.hisFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Parsed History Tags and Comments"))
        self.print2NotePad("from: {}\n".format(gglobs.hisFilePath))

        self.setBusyCursor()
        data = readFileLines(gglobs.hisFilePath)
        for a in data:
            if a[0] == '#':
                self.print2NotePad(a[:-1])
        self.setNormalCursor()


    def showHistBinData(self):
        """print HIST binary data in human readable form:'bytenumber: hex = dec'"""

        if gglobs.lstFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Binary History Data"))
        self.print2NotePad("from: {}\n".format(gglobs.lstFilePath))

        self.setBusyCursor()
        gglobs.stopPrinting = False
        data = readFileLines(gglobs.lstFilePath)
        for a in data:
            self.print2NotePad(a[:-1])
            if gglobs.stopPrinting: break

        gglobs.stopPrinting = False
        self.setNormalCursor()


    def printExcerptLines(self, path, lmax = 5):
        """print first and last lines of the file"""

        if path == None:
            self.showStatusMessage("No file available")
            return

        self.setBusyCursor()

        lines_all = readFileLines(path)

        if "ERROR" in lines_all[0][:6]:  # error message instead of data
            self.print2NotePad(lines_all[0])
            return

        recs_found = False
        for i in range(0, len(lines_all)):
            if lines_all[i][0] != "#": # any records other than comments?
                recs_found = True
                break

        if recs_found :
            for i in lines_all[0:lmax]:
                self.print2NotePad(i[:-1]) # omit the closing '/n'

            self.print2NotePad("...")

            for i in lines_all[-lmax:]:
                self.print2NotePad(i[:-1])
        else:
            self.print2NotePad("No records")

        self.setNormalCursor()


#logging
    def startTimer(self):
        """Starts the logging"""

        dprint(gglobs.debug, "startTimer:")
        debugIndent(1)

        self.print2NotePad(header("Start Logging"))

        # NOTE: the first 4 "if" should never be executed, as Start Logging should
        # not be enabled unless all those conditions are met. Leaving them anyway

        if gglobs.ser == None:
            self.errprint2NotePad("ALERT: Cannot log; Device is not connected")

        elif gcommands.isPowerOn() == "OFF":
            self.errprint2NotePad("ALERT: Cannot log; Device is switched OFF")

        elif gglobs.logFilePath == None:
            self.errprint2NotePad("ALERT: Cannot log; Logfile is not loaded")

        elif not os.access(gglobs.logFilePath, os.W_OK):
            # cannot write to file
            self.errprint2NotePad("ALERT: Cannot log; Logfile is not available for writing!")

        else:
            if gcommands.isPowerOn() != "ON":
                self.errprint2NotePad("ALERT: Cannot determine power state of device; it maybe switched OFF; observe logging output")

            writestring1  = "#LOGGING,{}, Start:  cycle: {} sec, mode: '{}'".format(stime(), gglobs.logcycle, "CPM" if gglobs.cpmflag else "CPS")
            writestring2  = "#LOGGING,{}, Connected Device: '{}'".format(stime(), gglobs.deviceDetected)
            writeFileA(gglobs.logFilePath, writestring1)
            self.print2LogPad(writestring1)
            self.print2NotePad(writestring1)
            writeFileA(gglobs.logFilePath, writestring2)
            self.print2LogPad(writestring2)
            self.print2NotePad(writestring2)

            dprint(gglobs.debug, "startTimer: Cleaning pipeline before logging")
            gcommands.getExtraByte()

            self.timer.start(gglobs.logcycle * 1000.0) # time is in ms
            dprint(gglobs.debug, "startTimer: Logging now; Timer is started with cycle {} sec.".format(gglobs.logcycle))
            gglobs.logging              = True
            gglobs.cpm_counter          = 0
            gglobs.currentFilePath      = gglobs.logFilePath
            self.dcfLog.setStyleSheet("QLineEdit { background-color: #F9F4C9; color: rgb(80,80,80); }")
            self.dcfHis.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")

            self.checkLoggingState()

            self.getLogValue()  # first call now; timer fires only AFTER 1st period!

        debugIndent(0)


    def stopTimer(self):
        """Stops the logging"""

        dprint(gglobs.debug, "stopTimer:")
        debugIndent(1)

        self.print2NotePad(header("Stop Logging"))
        self.timer.stop()
        gglobs.logging = False

        writestring  = "#LOGGING,{}, Stop".format(stime())
        writeFileA(gglobs.logFilePath, writestring)
        self.print2LogPad(writestring)
        self.print2NotePad(writestring)

        dprint(gglobs.debug, "stopTimer: Cleaning pipeline after logging")
        gcommands.getExtraByte()

        self.checkLoggingState()
        self.labelCPM.setStyleSheet('color:darkgray;')

        dprint(gglobs.debug, "stopTimer: Logging is stopped")
        debugIndent(0)


    def getLogValue(self):
        """
        Reads CPM or CPS from device, saves it in log file, and prints record
        into LogPad.
        Called by the timer once the timer is started
        """

        if not gglobs.logging: return
        if gglobs.logFilePath == None: return

        vprint(gglobs.verbose, "getLogValue: and save to:", gglobs.logFilePath)
        debugIndent(1)

        timetag              = stime()
        cpm, err, errmessage = gcommands.getCPMS(gglobs.cpmflag)  # counts per MINUTE with cpmflag=True, else CPS
        #print "getLogValue: cpm, err, errmessage", cpm, type(cpm), err, errmessage
        gglobs.cpm_counter   += 1

        if err == 0 or err == 1:
            # count rate always stored in CPM even if CPS requested
            if gglobs.cpmflag == False:             # we requested CPS
                cpscnt      = "(measured as CPS: {:0.0f})".format(cpm / 60)
            else:                                   # we requested CPM
                cpscnt      = ""

            if err == 0:
                printstring = "#{:<7d}  {:19s}  CPM: {:<6.0f} {}".format(gglobs.cpm_counter, timetag, cpm, cpscnt)
                writestring = " {:7d},{:19s}, {:}".format(gglobs.cpm_counter, timetag, cpm)

            else: #err == 1
                printstring = "#{:<7d}  {:19s}  CPM: {:<6.0f}, WARNING: {}".format(gglobs.cpm_counter, timetag, cpm, errmessage)
                writestring = " {:7d},{:19s}, {:}\n".format(gglobs.cpm_counter, timetag, cpm)
                writestring += "#{:7d},{:19s}, {:}, WARNING: {}".format(gglobs.cpm_counter, timetag, cpm, errmessage)

        else: # err == -1 (or else)
            printstring = "#{:<7d}  {:19s}  CPM: {}, ERROR: {}".format(gglobs.cpm_counter, timetag, cpm, errmessage)
            writestring = "#{:7d},{:19s}, {:}, ERROR: {}".format(gglobs.cpm_counter, timetag, cpm, errmessage)
            self.stopTimer()
            self.toggleDeviceConnection()
            self.print2NotePad("Check USB Port and Baudrate settings!")

        gglobs.lastCPM = cpm
        self.updateCountLabel(cpm)

        writeFileA(gglobs.logFilePath, writestring)
        self.print2LogPad(printstring)            # print cpm on logPad

        # update the logFileData array
        gglobs.logFileData      = np.append(gglobs.logFileData, [[mpld.datestr2num(timetag), cpm]], axis=0)

        #update graph only if it is the current one!
        #print "gglobs.currentFilePath", gglobs.currentFilePath
        if gglobs.logFilePath == gglobs.currentFilePath:
            gglobs.currentFileData  = gglobs.logFileData
            #print "gglobs.logFileData:\n", gglobs.logFileData

            # for now ALWAYS do a full plot, not just an update
            if True or (gglobs.cpm_counter < 10 and gglobs.sizePlotSlice < 10) or (gglobs.cpm_counter % 10 == 0):
                gplot.makePlot()
            else:
                gplot.updatePlot(gglobs.logFilePath, timetag, cpm)

        debugIndent(0)

        return cpm


    def changedCountUnit(self, i):
        """counter unit combo in Toolbar was changed"""

        self.updateCountLabel(gglobs.lastCPM)


    def updateCountLabel(self, cpm):
        """update the CPM/CPS/µSv/h counts in the toolbar"""

        #self.countUnit.addItems([u"CPM:", u"CPS:", u"µSv/h:", u"mSv/d", u"mSv/a"])
        if gglobs.lastCPM == None: return

        if gglobs.logging:
            self.labelCPM.setStyleSheet('color: black; background-color: #F4D345;')

        #if "CPM" in str(self.countUnit.currentText()):
        if "CPM" in str(self.countUnit.currentText()):
            labelCPMText = str(cpm)

        #elif "CPS" in str(self.countUnit.currentText()):
        elif "CPS" in str(self.countUnit.currentText()):
            labelCPMText = "{:0.1f}".format(cpm / 60.)

        elif "µSv/h" in str(self.countUnit.currentText()):
            labelCPMText = "{:0.2f}".format(cpm * gglobs.calibration)

        elif "mSv/d" in str(self.countUnit.currentText()):
            labelCPMText = "{:0.1f}".format(cpm * gglobs.calibration / 1000.0 * 24)

        else: #u"mSv/a"
            labelCPMText = "{:0.0f}".format(cpm * gglobs.calibration / 1000.0 * 24 * 365.25)

        self.labelCPM.setText(labelCPMText)


    def quickLog(self):
        """Reads CPM or CPS from device and displays in Toolbar
        Called by the timer, once the timer is started"""

        dprint(gglobs.debug, "quickLog:")
        debugIndent(1)

        self.print2NotePad(header("Quick Log"))
        self.clearLogPad()

        gglobs.logFilePath      = os.path.join(gglobs.dataPath, "default.log")
        gglobs.currentFilePath  = gglobs.logFilePath
        dprint(gglobs.debug, "quickLog: filename:", gglobs.logFilePath)

        line = "#HEADER ,using Quick Log file: default.log"
        self.print2LogPad(line)
        writeFileW(gglobs.logFilePath, line)

        gglobs.currentFilePath = gglobs.logFilePath
        self.print2NotePad("Logfile: {}".format(gglobs.currentFilePath))

        self.dcfLog.setText(gglobs.currentFilePath)
        self.dcfLog.setStyleSheet("QLineEdit { background-color: #F9F4C9; color: rgb(80,80,80); }")
        self.dcfHis.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")

        gglobs.logFileData      = np.empty([0,2])
        gglobs.currentFileData  = gglobs.logFileData
        #print "gglobs.logFileData:", gglobs.logFileData

        fig = plt.figure(1)
        plt.clf()                                    # clear figure
        fig.canvas.draw_idle()

        self.resetGraph()

        self.checkLoggingState()

        self.startTimer()

        debugIndent(0)


    def getLogFile(self, defaultFile = False):
        """Load existing file for logging, or create new one"""

        dprint(gglobs.debug, "getLogFile: defaultFile: '{}'".format(defaultFile))
        debugIndent(1)

        if defaultFile == False:
            #dlg=QtGui.QFileDialog(directory = gglobs.dataPath, caption= "Get Log File - enter new filename or select from existing")
            dlg=QtGui.QFileDialog(caption= "Get Log File - enter new filename or select from existing")
            dlg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
            dlg.setFileMode(QtGui.QFileDialog.AnyFile)
            dlg.setViewMode(QtGui.QFileDialog.Detail)
            dlg.setFilter("Logging Files (*.log)")
            dlg.setDirectory(gglobs.fileDialogDir)
            #print("gglobs.fileDialogDir:", gglobs.fileDialogDir)

            if dlg.exec_() == QtGui.QDialog.Accepted: # (=1)
                #print("dlg.directory():", dlg.directory())
                #print("dlg.directory().path():", dlg.directory().path())
                gglobs.fileDialogDir = dlg.directory().path()

                fnames  = dlg.selectedFiles()
                fn      = str(fnames[0])
                ext     = os.path.splitext(fn)[1]
                if ext != ".log":  fn += ".log"      # forces the ".log" extension

            else: # QtGui.QDialog.Rejected (= 0)
                dprint(gglobs.debug, "getLogFile: FileDialog Escape")
                debugIndent(0)
                return

            if os.path.isfile(fn):
                msg = QtGui.QMessageBox()
                msg.setIcon(QtGui.QMessageBox.Warning)
                msg.setWindowTitle("CAUTION")
                critical  = """You selected an existing file, which will be modified \
    when logging by <b>APPENDING</b> new data to it.Please confirm with OK.
    <br><br>Otherwise click Cancel and enter a new filename in the Get Log File dialog."""
                msg.setText(critical)
                msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
                msg.setDefaultButton(QtGui.QMessageBox.Cancel)
                msg.setEscapeButton(QtGui.QMessageBox.Cancel)
                retval = msg.exec_()

                if retval != 1024:
                    dprint(gglobs.debug, "getLogFile: Existing File Escape")

                    debugIndent(0)
                    return

            gglobs.logFilePath = fn
        else:
            gglobs.logFilePath = defaultFile

        if gglobs.logging:
            self.stopTimer()

        gglobs.currentFilePath  = gglobs.logFilePath
        self.dcfLog.setText(gglobs.currentFilePath)
        self.dcfLog.setStyleSheet("QLineEdit { background-color: #F9F4C9; color: rgb(80,80,80); }")
        self.dcfHis.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")

        self.print2NotePad(header("Get Logfile"))
        self.print2NotePad("Logfile: {}".format(gglobs.currentFilePath))
        dprint(gglobs.debug, "getLogFile: log filename:", gglobs.currentFilePath)
        self.clearLogPad()

        fig = plt.figure(1)
        plt.clf()                                    # clear figure
        fig.canvas.draw_idle()

        if not os.path.isfile(gglobs.logFilePath):
            # File does not exist; create new one
            self.print2NotePad("Logfile newly created - available for writing")
            line = "#HEADER ,{}, Logfile newly created as '{}'".format(stime(), os.path.basename(gglobs.logFilePath))
            self.print2LogPad(line)
            writeFileW(gglobs.logFilePath, line)
            self.clearPlotDefaults()
            gglobs.logFileData      = np.empty([0,2])

        else:
            # File does exist
            if os.access(gglobs.logFilePath, os.W_OK):
                # can read and write
                self.print2NotePad("Logfile opened - available for writing")

            elif os.access(gglobs.logFilePath, os.R_OK):
                # can read only
                self.errprint2NotePad("Logfile opened - ALERT: available ONLY FOR READING")

            gglobs.logFileData      = self.getFileData()

        gglobs.currentFileData  = gglobs.logFileData

        self.resetGraph()
        self.checkLoggingState()

        debugIndent(0)


    def addComment(self):
        """Adds a comment in the current log file"""

        d = QtGui.QInputDialog()
        info = "Enter your comment:" + " "*100
        text, ok = d.getText(self, 'Add a Comment', info)
        text = str(text)

        if ok:
            line = "#COMMENT,{}, {}".format(stime(), text)
            self.print2LogPad(line)
            writeFileA(gglobs.logFilePath, line)

        vprint(gglobs.verbose, "Add a Comment:", "text=", text, ",  ok=", ok)


    def showLogData(self):
        """ print logged data to notepad"""

        if gglobs.logFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Log Data"))
        self.print2NotePad("from: {}\n".format(gglobs.logFilePath))

        self.setBusyCursor()
        data = readFileLines(gglobs.logFilePath)
        gglobs.stopPrinting = False
        for a in data:
            self.print2NotePad(a[:-1]) # remove \n at end
            if gglobs.stopPrinting: break
        gglobs.stopPrinting = False
        self.setNormalCursor()


    def showLogTags(self):
        """print comments only from log data"""

        if gglobs.logFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Log Comments"))
        self.print2NotePad("from: {}\n".format(gglobs.logFilePath))

        self.setBusyCursor()
        data = readFileLines(gglobs.logFilePath)
        for a in data:
            if a[0] == '#':
                self.print2NotePad(a[:-1]) # remove \n at end
        self.setNormalCursor()


    def showLogDataExcerpt(self):
        """show first and last lmax lines of the log file"""

        if gglobs.logFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Log Data Excerpt"))
        self.print2NotePad("from: {}\n".format(gglobs.logFilePath))

        self.setBusyCursor()
        self.printExcerptLines(gglobs.logFilePath, lmax = 12)
        self.setNormalCursor()

#device
    def doREBOOT(self):
        """reboot the device"""

        msg = QtGui.QMessageBox()
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setIcon(QtGui.QMessageBox.Warning)
        msg.setWindowTitle("Reboot Device")
        msg.setText("Rebooting your device.\nPlease confirm with OK, or Cancel")
        msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
        msg.setDefaultButton(QtGui.QMessageBox.Cancel)
        msg.setEscapeButton(QtGui.QMessageBox.Cancel)
        retval = msg.exec_()

        if retval != 1024:   return

        self.print2NotePad(header("Device Reboot"))
        rec, err, errmessage = gcommands.setREBOOT()
        if err == 0 or err == 1:
            self.print2NotePad("REBOOT completed")
        else:
            self.print2NotePad("ERROR in doREBOOT: " + errmessage)


    def doFACTORYRESET(self):
        """Does a FACTORYRESET of the device"""

        d = QtGui.QInputDialog()
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        warning ="""
CAUTION - You are about to reset the device to factory condition!
All data and your changes of settings will be lost. \n
If you want to proceed, enter the word 'FACTORYRESET' (in all capital)
and press OK"""

        text, ok = d.getText(self, 'FACTORYRESET', warning)

        vprint(gglobs.verbose, "Factory Reset:", "text=", text, ",  ok=", ok)
        if ok:
            self.print2NotePad(header("Device FACTORYRESET"))
            if text == "FACTORYRESET":
                rec, err, errmessage = gcommands.setFACTORYRESET()
                #rec, err, errmessage = 0, 0, ""
                if err == 0 or err == 1:
                    self.print2NotePad("FACTORYRESET completed")
                else:
                    self.print2NotePad("ERROR in doFACTORYRESET: " + message)
            else:
                self.print2NotePad("Entry '{}' not matching 'FACTORYRESET' - Reset NOT done".format(text))


    def toggleDeviceConnection(self):
        """if no connection exists, then make connection else disconnect"""

        if gglobs.logging:
            self.dbtnDeviceConnect.setChecked(True)
            self.showStatusMessage("Can't change because logging is active! Stop logging first")
            return

        if gglobs.ser == None:
            self.switchDeviceConnection(new_connection = "ON")
        else:
            self.switchDeviceConnection(new_connection = "OFF")



    def switchDeviceConnection(self, new_connection = "ON"):
        """
        if new_connection = ON and no connection exists, then try to make
        USB connection (with verification of communication with device)
        else disconnect (unless already disconnected)
        """

        dprint(gglobs.debug, "switchDeviceConnection: --> {}. ".format(new_connection))
        debugIndent(1)

        if new_connection == "ON":
            self.print2NotePad(header("Connect Device"))
            QtGui.QApplication.processEvents()

            if gglobs.ser != None:
                self.print2NotePad("Device is already connected")

            else:
                self.setBusyCursor()

                # try to open the port
                # this is the only place where serialopen is called
                # gglobs.ser is None on errors, otherwise a proper connection
                gglobs.ser, errmessage = gcommands.serialOPEN(gglobs.usbport, gglobs.baudrate, gglobs.timeout)

                if gglobs.ser != None:  # device is connected, and communication had been verified with getVER()

                    # stop heartbeat was introduced to test GMC-500 communication
                    # it looks like it is not be needed any more
                    #                rec = gcommands.turnHeartbeatOFF()

                    self.dbtnDeviceConnect.setText(gglobs.deviceDetected)
                    self.dbtnDeviceConnect.setChecked(True)

                    self.print2NotePad("Found Device:", "'{}'".format(gglobs.deviceDetected))
                    self.print2NotePad("Device is connected to port:'{}', baudrate:{}, timeout:{} sec".format(gglobs.ser.name, gglobs.ser.baudrate, gglobs.ser.timeout))

                    self.setEnableDeviceActions(new_enable = True)

                    gcommands.getDeviceProperties()

                    try:
                        gglobs.cfg, error, errmessage = gcommands.getCFG()
                        #print("did get config with errmessage:", errmessage)
                    except Exception as e:
                        srcinfo = "ERROR: not getting config"
                        exceptPrint(e, sys.exc_info(), srcinfo)
                        gglobs.cfg = None

                    if gglobs.cfg == None or len(gglobs.cfg) != gglobs.configsize:
                        self.errprint2NotePad("Could not read device configuration correctly")
                        self.errprint2NotePad("Configuration dependent commands in menu Device are being inactivated!")
                        self.setDisableDeviceActions()

                    PowerState = gcommands.isPowerOn()
                    if PowerState == "ON":
                        self.print2NotePad("Powerstate of device is:", "ON")
                        self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power_on.png'))))
                    elif PowerState == "OFF":
                        self.print2NotePad("Powerstate of device is:", "OFF")
                        self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power_off.png'))))
                    else:
                        self.errprint2NotePad("Powerstate of device is:", PowerState)
                        self.DevicePowerToggle.         setEnabled(False)

                    vprint(gglobs.verbose, "Power is: ", PowerState)

                    media.play()

                else:
                    mediaErr.play()
                    self.dbtnDeviceConnect.setChecked(False)
                    self.errprint2NotePad(errmessage)
                    self.print2NotePad("Connection failed. Try running 'USB Autodiscovery' from menu Help")

                self.setNormalCursor()

        else: # new_connection == OFF
            if gglobs.logging:
                self.dbtnDeviceConnect.setChecked(True)
                self.showStatusMessage("Can't change because logging is active! Stop logging first")
                debugIndent(0)
                return

            #if gglobs.logging:
            #    self.stopTimer()
            #    gglobs.logging = False

            self.print2NotePad(header("Disconnect Device"))
            QtGui.QApplication.processEvents()

            if gglobs.ser == None:
                self.print2NotePad("No connected Device")

            else:
                gglobs.ser.close()
                gglobs.ser          = None

                msg = "Device '{}' is disconnected".format(gglobs.deviceDetected)
                self.print2NotePad(msg)
                dprint(gglobs.debug, "switchDeviceConnection: " + msg)

                self.setEnableDeviceActions(new_enable = False)

                self.dbtnDeviceConnect.setText("Click for Connection")
                self.dbtnDeviceConnect.setChecked(False)

        self.checkLoggingState()

        debugIndent(0)


    def checkLoggingState(self):
        """some cleanup of status"""

        if gglobs.ser == None or gglobs.logFilePath == None or gcommands.isPowerOn() == "OFF":
            self.startloggingAction.    setEnabled(False)
            self.stoploggingAction.     setEnabled(False)
        else:
            self.startloggingAction.    setEnabled(True)

        if gglobs.ser == None or gcommands.isPowerOn() == "OFF":
            pass
            self.quickLogAction.       setEnabled(False)
        else:
            self.quickLogAction.       setEnabled(True)

        if gglobs.ser == None:
            self.toggleDeviceConnectionAction.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_open.png'))))
            self.histDeviceAction.       setEnabled(False)
        else:
            self.toggleDeviceConnectionAction.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_closed.png'))))
            #self.histDeviceAction.       setEnabled(True)

        if gglobs.logging == True or gglobs.ser == None:
            self.histDeviceAction.      setEnabled(False)

        if gglobs.logging == False and gglobs.ser != None:
            self.histDeviceAction.      setEnabled(True)

        if gglobs.logFilePath != None:
            self.addCommentAction.      setEnabled(True)
        else:
            self.addCommentAction.      setEnabled(False)

        if gglobs.logging == True:
            self.logLoadFileAction.     setEnabled(False)
            self.stoploggingAction.     setEnabled(True)
            self.startloggingAction.    setEnabled(False)
            self.quickLogAction.        setEnabled(False)

            self.WebAction.             setEnabled(True)
            self.webMapAction.          setEnabled(True)
        else:
            self.logLoadFileAction.     setEnabled(True)
            self.stoploggingAction.     setEnabled(False)
            self.WebAction.             setEnabled(False)
            self.webMapAction.          setEnabled(False)



    def setEnableDeviceActions(self, new_enable = True):

        # Device
        self.DeviceConnectAction.       setEnabled(not new_enable)
        self.DeviceDisconnectAction.    setEnabled(new_enable)
        self.DeviceInfoAction.          setEnabled(new_enable)
        self.DeviceConfigAction.        setEnabled(new_enable)
        #self.DeviceSettingAction.       setEnabled(new_enable)
        self.DeviceONAction.            setEnabled(new_enable)
        self.DeviceOFFAction.           setEnabled(new_enable)
        self.DeviceSetTimeAction.       setEnabled(new_enable)
        self.DeviceREBOOTAction.        setEnabled(new_enable)
        self.DeviceFACTORYRESETAction.  setEnabled(new_enable)

        # Device functions using the config
        self.DeviceSpeakerONAction.     setEnabled(new_enable)
        self.DeviceSpeakerOFFAction.    setEnabled(new_enable)
        self.DeviceAlarmONAction.       setEnabled(new_enable)
        self.DeviceAlarmOFFAction.      setEnabled(new_enable)
        self.DeviceSavingStateAction.   setEnabled(new_enable)

        #toolbar toggle
        self.DevicePowerToggle.         setEnabled(new_enable)

        # History
        self.histDeviceAction.          setEnabled(new_enable)


    def setDisableDeviceActions(self):

        # when config is not usable
        self.DeviceSpeakerONAction.     setEnabled(False)
        self.DeviceSpeakerOFFAction.    setEnabled(False)
        self.DeviceAlarmONAction.       setEnabled(False)
        self.DeviceAlarmOFFAction.      setEnabled(False)
        self.DeviceSavingStateAction.   setEnabled(False)


    def toggleDevicePower(self):
        """Toggle Device Power ON / OFF"""

        if gglobs.logging:
            self.DevicePowerToggle.setChecked(True)
            self.showStatusMessage("Can't change because logging is active! Stop logging first")
            return

        if gcommands.isPowerOn() == "ON":
            self.switchDevicePower("OFF")
        else:
            self.switchDevicePower("ON")


    def switchDevicePower(self, newstate = "ON"):
        """Switch Device power to ON or OFF"""

        debugIndent(1)

        msg = "Switch Device Power {}".format(newstate)
        self.print2NotePad(header(msg))
        dprint(gglobs.debug, "switchDevicePower: " + msg)

        self.setBusyCursor()
        if newstate == "ON":
            if gcommands.isPowerOn() != "ON":
                gcommands.setPOWERON()
                time.sleep(3) # takes some time to settle!
        else:
            if gcommands.isPowerOn() == "ON":
                if gglobs.logging:
                    self.stopTimer()
                gcommands.setPOWEROFF()
                time.sleep(3) # takes some time to settle!

        cfg, error, errmessage     = gcommands.getCFG()     # read config after power change
        gglobs.cfg = cfg

        ipo = gcommands.isPowerOn()
        self.print2NotePad("Power State of device is: ",  ipo)

        if   ipo == "ON":
            self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power_on.png'))))
        elif ipo == "OFF":
            self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power_off.png'))))
        else:
            self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power_on.png'))))

        self.checkLoggingState()
        self.setNormalCursor()
        debugIndent(0)


    def printDevInfo(self):
        """prints basic info on the device"""

        self.setBusyCursor()

        gcommands.fprintDeviceInfo()

        self.print2NotePad("Device Firmware Settings:")
        pds = gcommands.ftextSettings()
        self.print2NotePad(pds)
        dprint(gglobs.debug, "printDevInfo: Settings:\n" + pds)

        self.setNormalCursor()


    def printDevConfig(self):
        """prints the 256 or 512 bytes of device configuration"""

        dprint(gglobs.debug, "printDevConfig: ")
        debugIndent(1)

        self.setBusyCursor()

        self.print2NotePad(header("Device Configuration"))
        pdc = gcommands.ftextCFG()
        self.print2NotePad(pdc)
        dprint(gglobs.debug, "printDevConfig:\n" + pdc)

        self.setNormalCursor()

        debugIndent(0)


    def deviceSetDateTime(self):
        """ set date and time on device to computer date and time"""

        dprint(gglobs.debug, "deviceSetDateTime:")
        debugIndent(1)

        while True:
            self.print2NotePad(header("Set Date+Time of Device"))
            rec, error, errmessage = gcommands.getDATETIME()
            if error < 0:
                self.print2NotePad("Communication problem with device:", errmessage)
                break

            computerTime = stime()
            deviceTime   = str(rec)
            deltat       = datestr2num(computerTime) - datestr2num(deviceTime)
            if deltat == 0:
                dtxt = "Device time is same as computer time"
            elif deltat > 0:
                dtxt = "Device is slower than computer by {:0.0f} sec".format(deltat)
            else:
                dtxt = "Device is faster than computer by {:0.0f} sec".format(abs(deltat))

            self.print2NotePad("Date and Time from device is:", deviceTime)
            self.print2NotePad("Date and Time from computer is:", "{}".format(computerTime))
            self.print2NotePad("", "{}\n".format(dtxt))

            self.print2NotePad("Setting device time to computer time")
            gcommands.setDATETIME()
            #extra = gcommands.getExtraByte()

            rec, error, errmessage = gcommands.getDATETIME()
            deviceTime = str(rec)
            self.print2NotePad("New Date and Time from device is:", str(deviceTime))

            break

        debugIndent(0)


    def switchSaveDataType(self):
        """Switches the Saving State"""

        dprint(gglobs.debug, "switchSaveDataType:")
        debugIndent(1)

        while True:
            # get current config
            cfg, error, errmessage = gcommands.getCFG()
            gglobs.cfg = cfg
            if error < 0:
                self.print2NotePad("Error:" + errmessage)
                break

            SDT, SDTtxt = gcommands.getSaveDataType()
            gglobs.savedatatype = SDTtxt

            # setup dialog and get new config setting
            selection   = gglobs.savedatatypes
            text, ok    = QtGui.QInputDialog().getItem(self, 'Switch History Saving Mode', "Select new history saving mode and press ok:   ", selection, SDT, False )
            vprint(gglobs.verbose, "Switch History Saving Mode:", "text=", text, ",  ok=", ok)

            if not ok: break      # user has selected Cancel

            self.print2NotePad(header("Switch History Saving Mode"))

            newSDT = selection.index(text)
            #print "newSDT:", newSDT
            self.setBusyCursor()

            # write the new config data
            gcommands.writeConfigData(gglobs.cfgOffsetSDT, newSDT)

            # read the config to verify
            cfg, error, errmessage = gcommands.getCFG()
            gglobs.cfg             = cfg
            if error < 0:
                self.errprint2NotePad("Error:" + errmessage)
                break

            self.setNormalCursor()
            SDT, SDTtxt = gcommands.getSaveDataType()
            self.print2NotePad("Device History Saving Mode:", "{}".format(SDTtxt))
            gglobs.savedatatype = SDTtxt

            break

        debugIndent(0)


    def switchDeviceSpeaker(self, newstate = "ON"):
        """Switch Device Speaker to ON or OFF"""

        self.setBusyCursor()
        self.print2NotePad(header("Switch Device Speaker {}".format(newstate)))

        while True: # to allow jumping to exit
            # get current config
            cfg, error, errmessage = gcommands.getCFG()
            if error < 0:
                self.errprint2NotePad("Error:" + errmessage)
                break

            if newstate == "ON":
                st = 1
            else:
                st = 0

            # write the new config data
            gcommands.writeConfigData(gglobs.cfgOffsetSpeaker, st)

            # check config for success
            cfg, error, errmessage = gcommands.getCFG()
            if error < 0:
                self.errprint2NotePad("Error:" + errmessage)
                break

            if cfg[gglobs.cfgOffsetSpeaker] == 1:
                ipo = "ON"
            else:
                ipo = "OFF"

            self.print2NotePad("Device Speaker State is: ",  ipo)
            break

        self.setNormalCursor()


    def switchDeviceAlarm(self, newstate = "ON"):
        """Switch Device Alarm to ON or OFF"""

        self.setBusyCursor()
        self.print2NotePad(header("Switch Device Alarm {}".format(newstate)))

        while True: # to allow jumping to exit
            # get current config
            cfg, error, errmessage = gcommands.getCFG()
            if error < 0:
                self.errprint2NotePad("Error:" + errmessage)
                break

            if newstate == "ON":
                st = 1
            else:
                st = 0

            # write the new config data
            gcommands.writeConfigData(gglobs.cfgOffsetAlarm, st)

            time.sleep(1.0)

            # check config for success
            cfg, error, errmessage = gcommands.getCFG()
            gglobs.cfg = cfg

            self.print2NotePad("Device Alarm State is: ",  gcommands.isAlarmOn())
            break

        self.setNormalCursor()


#help
    def helpQuickStart(self):
        """Quickstart item on the Help menu"""

        msg = QtGui.QMessageBox()
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - Quickstart")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpQuickstart)
        msg.setStandardButtons(QtGui.QMessageBox.Ok)
        msg.setDefaultButton(QtGui.QMessageBox.Ok)
        msg.setEscapeButton(QtGui.QMessageBox.Ok)
        msg.setWindowModality(QtCore.Qt.WindowModal)

        # none of this size stuff works; looks like a bug
        # size does not work; use invisible button as spacer instead
        #msg.resize(800, 800)
        #msg.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        #msg.updateGeometry()
        #msg.setMinimumWidth(900)
        #msg.setBaseSize(900,900)
        #msg.setFixedSize(900, 900)

        btn = QtGui.QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def helpWorldMaps(self):
        """Using the Radiation World Map"""

        msg = QtGui.QMessageBox()
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - Radiation World Maps")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpWorldMaps)
        msg.setStandardButtons(QtGui.QMessageBox.Ok)
        msg.setDefaultButton(QtGui.QMessageBox.Ok)
        msg.setEscapeButton(QtGui.QMessageBox.Ok)
        msg.setWindowModality(QtCore.Qt.WindowModal)

        btn = QtGui.QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def helpOccupationalRadiation(self):
        """Occupational Radiation Limits"""

        msg = QtGui.QMessageBox()
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - Occupational Radiation Limits")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpOccupationalRadiation)
        msg.setStandardButtons(QtGui.QMessageBox.Ok)
        msg.setDefaultButton(QtGui.QMessageBox.Ok)
        msg.setEscapeButton(QtGui.QMessageBox.Ok)
        msg.setWindowModality(QtCore.Qt.WindowModal)

        btn = QtGui.QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def helpOptions(self):
        """Options item on the Help menu"""

        msg = QtGui.QMessageBox()
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - Options")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpOptions)
        msg.setStandardButtons(QtGui.QMessageBox.Ok)
        msg.setDefaultButton(QtGui.QMessageBox.Ok)
        msg.setEscapeButton(QtGui.QMessageBox.Ok)
        msg.setWindowModality(QtCore.Qt.WindowModal)

        btn = QtGui.QPushButton()# invisible button
        btn.setMinimumWidth(450) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def changeOptions(self):
        """Switches State of some options"""

        options       = ("Verbose  = False",
                         "Verbose  = True",
                         "Debug    = False",
                         "Debug    = True",
                         "Redirect = False",
                         "Redirect = True",
                         "testing  = False",
                         "testing  = True",
                         )

        index         = 0
        text, ok      = QtGui.QInputDialog().getItem(self, 'Switch Option', "Select new option setting and press ok:   ", options, index, False )
        vprint(gglobs.verbose, "changeOptions: text= '{}', ok={}".format( text, ok))

        if not ok: return      # user has selected Cancel

        newIndex    = options.index(text)

        self.print2NotePad(header("Change Options"))
        self.print2NotePad("New Option setting:", "{}".format(options[newIndex]))

        if   newIndex == 0:
            gglobs.verbose  = False
        elif newIndex == 1:
            gglobs.verbose  = True

        elif newIndex == 2:
            gglobs.debug    = False
        elif newIndex == 3:
            gglobs.debug    = True

        elif newIndex == 4:
            gglobs.redirect = False
        elif newIndex == 5:
            gglobs.redirect = True

        elif newIndex == 6:
            gglobs.testing  = False
        elif newIndex == 7:
            gglobs.testing  = True
        else:
            pass


    def showSystemInfo(self):
        """System Info on the Help Menu"""

        screen           = QtGui.QDesktopWidget().screenGeometry()
        screen_available = QtGui.QDesktopWidget().availableGeometry()
        geom             = self.geometry()
        geom_frame       = self.frameGeometry()

        fmt              = "\n{:33s}{}"
        si               = ""   # system info
        si += fmt.format("Device:",                           "")
        si += fmt.format("  Model connected:",                str(gglobs.deviceDetected))
        try: # fails if gglobs.memory is still 'auto'
            si += fmt.format("  Memory (bytes):",                "{:,}".format(gglobs.memory))
        except:
            si += fmt.format("  Memory (bytes):",                "{:}".format(gglobs.memory))

        try: # fails if gglobs.SPIRpage is still 'auto'
            si += fmt.format("  SPIRpage Size (bytes):",         "{:,}"    .format(gglobs.SPIRpage))
        except:
            si += fmt.format("  SPIRpage Size (bytes):",         "{:}"    .format(gglobs.SPIRpage))
        si += fmt.format("  SPIRbugfix:",                    "{:}"    .format(gglobs.SPIRbugfix))
        si += fmt.format("  configsize (bytes):",            "{:}"    .format(gglobs.configsize))
        si += fmt.format("  Calibration (µSv/h / CPM):",     str(gglobs.calibration))
        si += fmt.format("  voltagebytes (bytes):",         "{:}"    .format(gglobs.voltagebytes))
        si += fmt.format("  endianness:",                   "{:}"    .format(gglobs.endianness))
        si += fmt.format("  History Saving Mode:",           str(gglobs.savedatatype))
        si += fmt.format("USB Port Settings:",                "")
        si += fmt.format("  Port:",                          str(gglobs.usbport))
        si += fmt.format("  Baudrate:",                      "{:,}".format(int(gglobs.baudrate)))
        si += fmt.format("  Timeout:",                       str(gglobs.timeout))
        si += fmt.format("  ttyS:",                          str(gglobs.ttyS))
        si += fmt.format("Runtime settings:",                 "")
        si += fmt.format("  Flag Debug:",                    str(gglobs.debug))
        si += fmt.format("  Flag Verbose:",                  str(gglobs.verbose))
        si += fmt.format("  Flag KeepFF:",                   str(gglobs.keepFF))
        si += fmt.format("  Flag Redirect:",                 str(gglobs.redirect))
        si += fmt.format("  Flag Development:",              str(gglobs.devel))
        si += fmt.format("  Flag Testing:",                  str(gglobs.testing))
        si += fmt.format("  GeigerLog Program Directory:",   str(getProgPath()))
        si += fmt.format("  GeigerLog Data Directory:",      str(gglobs.dataPath))
        si += fmt.format("  GeigerLog Resource Directory:",  str(gglobs.gresPath))
        si += fmt.format("  GeigerLog Manual:",              str(gglobs.manual_filename))
        si += fmt.format("  Worldmaps Settings:",            "UserID: '{}', CounterID: '{}'".format(gglobs.UserID, gglobs.CounterID))
        si += fmt.format("GUI:",                              "")
        si += fmt.format("  Monitor:",                        "")
        si += fmt.format("   Screen size - Hardware:",       "{}x{}".format(screen.width(), screen.height()))
        si += fmt.format("   Screen size - Available:",      "{}x{}, at position: x={}, y={}".format(screen_available.width(), screen_available.height(), screen_available.x(), screen_available.y()))
        si += fmt.format("   Current window size:",           "{}x{} including window frame (w/o frame: {}x{})".format(geom_frame.width(), geom_frame.height(), geom.width(), geom.height()))
        si += fmt.format("  Styles:",                         "")
        si += fmt.format("   Styles available on System:",    styles)
        si += fmt.format("   Active Style (internal name):",  str(gglobs.style))
        si += fmt.format("  Fonts:",                          "")
        si += fmt.format("   Active Font - Application:",     strFontInfo("", app.font()))
        si += fmt.format("   Active Font - NotePad:",         strFontInfo("", self.notePad.fontInfo()))
        si += fmt.format("Version status:",                   "")
        for a in version_status():
            si += fmt.format( "  {:}:".format(a[0]),          "{}".format( a[1]))
        si += fmt.format("Platform:",                         "")
        si += fmt.format("  Operating System:",               "{}".format(platform.platform()))
        si += fmt.format("  Machine:",                        "{}, {}".format(platform.machine(), platform.architecture()[0]))

        msg = QtGui.QMessageBox()
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - System Info")
        msg.setFont(self.fontstd)
        msg.setText(si)
        msg.setStandardButtons  (QtGui.QMessageBox.Ok)
        msg.setDefaultButton    (QtGui.QMessageBox.Ok)
        msg.setEscapeButton     (QtGui.QMessageBox.Ok)
        msg.setWindowModality   (QtCore.Qt.WindowModal)
        #msg.setMinimumWidth(1600) #not working
        ###msg.setTextInteractionFlags(Qt.TextSelectableByMouse)

        btn = QtGui.QPushButton() # to become invisible button defining width of dialog box
        btn.setMinimumWidth(1200) # determines width of box; width is limited by other stuff
        btn.setMaximumHeight(0)   # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def openUrl(self):
        """Show the GeigerLog Manual, either the local version, or if not
        possble, then the version on SourceForge"""

        manual_file = None

        #if gglobs.manual_filename != None:
        if gglobs.manual_filename != 'auto':
            # if filename defined in config file, use that name
            # but if file does not exist, it has already been overwritten with
            # None when reading the config
            manual_file = getProgPath() + "/" + gglobs.manual_filename
        else:
            # if NOT defined in config file, use first found file which begins
            # with 'GeigerLog-Manual'
            path = getProgPath() + "/"
            for filename in os.listdir(path):
                #print filename
                if re.match("GeigerLog-Manual", filename):
                    #print "filename", filename
                    manual_file = getProgPath() + "/" + filename
                    break
        #print "manual_file", manual_file

        if manual_file != None:

            try:
                #a = 1/0
                import subprocess
                if sys.platform.startswith('linux'):
                    subprocess.call(["xdg-open", manual_file])
                    dprint(gglobs.debug, "Showing '{}' via xdg-open on Linux".format(manual_file))
                else:
                    os.startfile(manual_file)
                    dprint(gglobs.debug, "Showing '{}' via os.startfile on other OS".format(manual_file))

                return
            except:
                print(sys.exc_info())
                dprint(gglobs.debug, "Failure Showing '{}' via xdg-open on Linux or via os.startfile on other OS".format(manual_file))

            try:
                #a=1/0
                import subprocess
                if sys.platform.startswith('linux'):
                    subprocess.call(["firefox", manual_file])
                    dprint(gglobs.debug, "Showing '{}' via firefox on Linux".format(manual_file))
                else:
                    os.startfile(manual_file)
                    dprint(gglobs.debug, "Showing '{}' via os.startfile on other OS".format(manual_file))

                return
            except:
                print(sys.exc_info())
                dprint(gglobs.debug, "Failure Showing '{}' via firefox on Linux or via os.startfile on other OS".format(manual_file))

            try:
                #a = 1/0
                import webbrowser
                webbrowser.open(manual_file)
                dprint(gglobs.debug, "Showing '{}' via import webbrowser".format(manual_file))
                return
            except:
                print(sys.exc_info())
                dprint(gglobs.debug, "Failure Showing '{}' via import webbrowser".format(manual_file))


        try:
            #a=1/0
            shortv = gglobs.__version__.split("_")[0]
            url = QtCore.QUrl('https://sourceforge.net/projects/geigerlog/files/GeigerLog-Manual-v{}.pdf'.format(shortv))
            if not QtGui.QDesktopServices.openUrl(url):
                QtGui.QMessageBox.warning(self, 'GeigerLog Manual', 'Could not open GeigerLog Manual.pdf')
                dprint(gglobs.debug, "Failure Showing manual with QtCore.QUrl")
            else:
                dprint(gglobs.debug, "Showing '{}' via QtCore.QUrl".format(manual_file))
        except:
            print(sys.exc_info())
            dprint(gglobs.debug, "Failure Showing manual with QtCore.QUrl")

        self.errprint2NotePad("WARNING: Could not find GeigerLog-Manual, neither locally nor online!")
        self.print2NotePad("The file 'GeigerLog-Manual-xyz', with xyz being a version number, is missing")
        self.print2NotePad("from the GeigerLog working directory 'geigerlog'.")


    def USBautoDiscovery(self):
        """USB Autodiscovery with option to select any found connection"""

        dprint(gglobs.debug, "USBautoDiscovery:")
        debugIndent(1)

        if gglobs.ser != None:
            self.switchDeviceConnection(new_connection = "OFF")
            QtGui.QApplication.processEvents()

        self.setBusyCursor()
        rec, errmessage = gcommands.autoPORT()
        self.setNormalCursor()

        msg = QtGui.QMessageBox()
        msg.setWindowTitle("USB Autodiscovery")
        msg.setIcon(QtGui.QMessageBox.Information)
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))

        if rec == None:
            flag = "fail"
            txt1 = errmessage + "\n\nIs device connected? Check cable and plugs! Re-run in a few seconds."
        else:
            if len(rec) == 1:
                flag  = "success"
                txt1  = "A Geiger Counter was found at:\n"
                txt1 += "     Port: " + str(rec[0][0]) + "              Baudrate: " + str(rec[0][1])
                txt1 += "\n\nPress OK to make this your new setting and connect, Cancel otherwise."
                txt1 += "\n\nTo make this permanent edit the configuration file geigerlog.cfg\nand enter above settings in Section 'Serial Port'."

            else:
                flag  = "fail"
                txt1  = "The following ports and baudrates have connected Geiger Counters:\n"
                for i in rec:
                    txt1 += "\n     Port: " + str(i[0]) + "              Baudrate: " + str(i[1])
                txt1 += "\n\nGeigerLog can handle only a single connected Geiger Counter."
                txt1 += "\n\nEither remove all counters except one now and re-run 'USB Autodiscovery', or "
                txt1 += "edit the configuration file geigerlog.cfg in Section 'Serial Port' to define your counter."

        msg.setText(txt1)

        txt1  = "-" * 100
        txt1 += "\nThe current settings of GeigerLog are:"
        txt1 += "\n     Port: " + gglobs.usbport + "                Baudrate: " + str(gglobs.baudrate)
        msg.setInformativeText(txt1)

        if flag == "fail":
            msg.setStandardButtons(QtGui.QMessageBox.Cancel)
        else:
            msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
        msg.setDefaultButton(QtGui.QMessageBox.Cancel)
        msg.setEscapeButton(QtGui.QMessageBox.Cancel)

        retval = msg.exec_()

        if retval == 1024:
            dprint(gglobs.debug, "USBautoDiscovery: Accepting autodiscovered port settings; connecting now")
            gglobs.usbport = str(rec[0][0])
            gglobs.baudrate = str(rec[0][1])
            self.switchDeviceConnection(new_connection = "ON")
        else:
            dprint(gglobs.debug, "USBautoDiscovery: Not accepting autodiscovered port settings; cancelling now")

        debugIndent(0)


    def helpAbout(self):
        """About item on the Help menu"""

        description = gglobs.helpAbout.format(__author__, gglobs.__version__, __copyright__, __license__)

        licon   = QtGui.QLabel() # label to hold the geigerlog icon
        licon.setPixmap(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png')))

        ltext   = QtGui.QLabel() # label to hold the 'eigerlog' text as picture
        ltext.setPixmap(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'eigerlog.png')))

        labout  = QtGui.QTextBrowser() # label to hold the description
        labout.setLineWrapMode(QtGui.QTextEdit.WidgetWidth)
        labout.setText(description)
        labout.setOpenExternalLinks(True) # to open links in a browser
        labout.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout.setMinimumWidth(800)
        #labout.setTextColor(QtGui.QColor("red"))
        #labout.setTextBackgroundColor(QtGui.QColor("red"))
        #print labout.textBackgroundColor().toRgb().red()
        #print labout.textBackgroundColor().toRgb().green()
        #print labout.textBackgroundColor().toRgb().blue()
        #labout.setStyleSheet("background-color: #F2F1F0; font-size:15px;")

        d       = QtGui.QDialog()
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        d.setFont(self.fontstd)
        d.setWindowTitle("Help - About GeigerLog")
        #d.setWindowModality(QtCore.Qt.ApplicationModal)
        d.setWindowModality(QtCore.Qt.WindowModal)
        #d.setMinimumWidth(800)
        d.setMinimumHeight(gglobs.window_height + 50)

        bbox    = QtGui.QDialogButtonBox()
        bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutTop = QtGui.QHBoxLayout()
        layoutTop.addWidget(licon)
        layoutTop.addWidget(ltext)
        layoutTop.addStretch()      # to keep the icons on the left

        layoutV   = QtGui.QVBoxLayout(d)
        layoutV.addLayout(layoutTop)
        layoutV.addWidget(labout)
        layoutV.addWidget(bbox)

        d.exec_()


#utilities in Class
    def errprint2NotePad(self, *args):
        """print into Notepad area an error text in red and make sound"""

        mediaErr.play()

        line = "<span style='color:red;'>{:35s} ".format(args[0])
        for s in range(1, len(args)):
            line += "{}".format(args[s])
        line += "</span>"

        stopred = "<span style='color:black;'></span>"
        self.notePad.append(line + stopred)
        QtGui.QApplication.processEvents()

        time.sleep(0.3) # wait for the end of sound


    def print2NotePad(self, *args):
        """print all args in NotePad area"""

        line = "{:35s}".format(args[0])
        for s in range(1, len(args)):
            line += "{} ".format(args[s])

        self.notePad.append(line)
        QtGui.QApplication.processEvents()


    def clearNotePad(self):
        """Clear the notepad"""

        self.notePad.clear()


    def haltNotePad(self):
        """Clear the notepad"""

        gglobs.stopPrinting = True


    def print2LogPad(self, *args):
        """print all args in logPad area"""

        line = "{:35s}".format(args[0])
        for s in range(1, len(args)):
            line += "{}".format(args[s])

        self.logPad.append(line)
        QtGui.QApplication.processEvents()


    def clearLogPad(self):
        """Clear the logpad"""

        self.logPad.clear()


    def setBusyCursor(self):

        QtGui.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        #QtGui.QApplication.processEvents()


    def setNormalCursor(self):

        QtGui.QApplication.restoreOverrideCursor()
        #QtGui.QApplication.processEvents()


    def showStatusMessage(self, message):
        """shows message by flashing the Status Bar red for 0.5 sec, then switches back to normal"""

        mediaErr.play()

        self.statusBar.showMessage(message, 0)         # message remains until overwritten by next status
        self.statusBar.setStyleSheet("QStatusBar { background-color:red; color:white; }")
        QtGui.QApplication.processEvents()             #assure that things are visible
        QtGui.QApplication.processEvents()             # did not work doing it only once strange???
        time.sleep(0.5)                                # stays red for 0.5 sec
        self.statusBar.setStyleSheet("QStatusBar { }") # reset to default colors


#########################################
#not used
    def processtrigger(self, q):
        """for testing"""

        pass
        #self.showStatusMessage(q.text())
        #print q.text() + " is triggered"


    def showDialog(self):
        #   QtGui.QMessageBox.NoIcon
        #   QtGui.QMessageBox.Question
        #   QtGui.QMessageBox.Information
        #   QtGui.QMessageBox.Warning
        #   QtGui.QMessageBox.Critical

        msg = QtGui.QMessageBox()
        msg.setWindowTitle("FACTORYRESET Device")
        msg.setIcon(QtGui.QMessageBox.Critical)

        msg.setText("You are about to do a FACTORYRESET !")
        msg.setInformativeText("Are you sure?")

        msg.setDetailedText("And here is more...")
        msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel|QtGui.QMessageBox.Save|QtGui.QMessageBox.Open|QtGui.QMessageBox.Abort|QtGui.QMessageBox.Ignore|QtGui.QMessageBox.Retry)
        msg.setDefaultButton(QtGui.QMessageBox.Cancel)
        msg.setEscapeButton(QtGui.QMessageBox.Cancel)

        retval = msg.exec_()
        dprint(gglobs.debug, "value of pressed message box button:", retval)

#########################################


    def plotPoisson(self, type = 'plot'):
        """Plotting a Poisson Fit to a histogram of the data"""

        if type == 'plot':
            #print "gglobs.cpmSlice", gglobs.cpmSlice
            x = gglobs.logCPMSlice # only data in the plot
            t = gglobs.logTimeDiffSlice
        else:
            #print "gglobs.logCPM", gglobs.logCPM
            x = gglobs.logCPM # all data
            t = gglobs.logTimeDiff
        if x is None:
            self.showStatusMessage("No file available")
            return

        DataSrc     = os.path.basename(gglobs.currentFilePath)
        cycletime   = (t[-1] - t[0]) / (t.size -1)  # in minutes

        ######################################
        # to show histogram of delta between 2 consecutive counts
        if False:
        #if True:
            dx = x[:-1].copy()
            for i in range(0, len(dx)):
                dx[i] = abs(x[i+1] - x[i])
                #if dx[i] > 10: print i, dx[i]
            #print x, len(x)
            #print dx, len(dx)
            x = dx
            yunit = "Differences between 2 consecutive CPM!"
        #######################################

        # if CPS selected in Graph, treat as CPS
        else:
            if self.yunit.currentText() == "CPS":
                x = x / 60.
                yunit = "CPS"
            else:
                yunit = "CPM"


        # switch off interactive mode
        #plt.ioff()

        fig2 = plt.figure(2, facecolor = "#E7F9C9")
        plt.clf()
        plt.title("Count Rate Histogram with Poisson Fit", fontsize=12, loc='left')
        plotSubTitle = "  Recs:" + str(x.size)
        plt.title(plotSubTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel("Count Rate ({})".format(yunit), fontsize=12)
        plt.ylabel("Frequency of Occurence", fontsize=12)
        plt.grid(True)
        plt.subplots_adjust(hspace=None, wspace=.2 , left=.17, top=0.9, bottom=0.15, right=.97)
        plt.ticklabel_format(useOffset=False)

        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        canvas2 = FigureCanvas(fig2)
        canvas2.setFixedSize(550,350)
        navtoolbar = NavigationToolbar(canvas2, self)

        labout  = QtGui.QTextBrowser() # label to hold the description
        labout.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout.setMinimumHeight(160)

        d       = QtGui.QDialog()
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        d.setFont(self.fontstd)
        d.setWindowTitle("Poisson Test")
        #d.setMinimumHeight(gglobs.window_height)
        #d.setWindowModality(QtCore.Qt.ApplicationModal)
        #d.setWindowModality(QtCore.Qt.NonModal)
        d.setWindowModality(QtCore.Qt.WindowModal)

        bbox    = QtGui.QDialogButtonBox()
        bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutV   = QtGui.QVBoxLayout(d)
        layoutV.addWidget(navtoolbar)
        layoutV.addWidget(canvas2)
        layoutV.addWidget(labout)
        layoutV.addWidget(bbox)

        step = max(1, int(0.3 * np.sqrt(x.max())))
        bins = list(range(0, max(10, int(x.max() + step * 3)), step))
        #print "bins=", bins

        hist, bins = np.histogram(x, bins=bins)
        #hist, bins = np.histogram(x)
        #print "hist=\n", hist, len(hist)
        #print "bins=\n", bins, len(bins)

        avg         = np.mean(x)
        var         = np.var(x)
        std         = np.std(x)
        sum_hist    = int(np.sum(hist))

        try:
            from scipy import stats
            pdf = stats.poisson.pmf(bins, avg)
            sum_pdf  = sum(pdf)
            pdfs = pdf * sum_hist/sum_pdf
        except:
            labout.append("Cannot calculate Poisson Curve - Module 'scipy' is missing")
            pdfs= bins - bins

        labout.append("No.   Count Rate    Frequency    % of   Poisson-Fit")
        labout.append("      from ... to   (columns)    Total   (red line)")
        for i in range(0, len(hist)):
            labout.append("{:3d}   {:4d} ... <{:<4d} {:8d}   {:5.2f}%   {:10.1f}".format( i, bins[i], bins[i+1], hist[i], hist[i]*100./sum_hist, pdfs[i]))
        labout.append("Total count=       {:10d}  100.00%   {:10.1f}".format(sum(hist), sum(pdfs)))

        width = step * 0.8

        # histogram ##########################################################
        #rec = plt.bar(bins[:-1], hist, align='edge', width=width)
        rec = plt.bar(bins[:-1], hist, align='center', width=width)
        plt.xlim(xmin = 0, xmax = bins[-1] + step)

        #rec = plt.hist(x, bins=50, rwidth=0.9)
        #rec = plt.hist(x, bins='auto')

        # determine r-squared
        ss_res = np.sum((hist - pdfs[:-1]    ) ** 2)    # residual sum of squares
        ss_tot = np.sum((hist - np.mean(hist)) ** 2)    # total sum of squares
        r2 = 1 - (ss_res / ss_tot)                      # r-squared

        labout.append("Goodness of Poisson Fit (Average, Total) r²= {:8.3f}".format(r2))

        plt.plot(bins, pdfs, linewidth=3, color='red', label ="r2  = {:0.3f}\navg= {:0.2f}".format(r2, avg))

        #######################################################################


        # find best place for legend
        if avg >= bins[-1]/2:
            plt.legend(loc='upper left', fontsize=12)
        else:
            plt.legend(loc='upper right', fontsize=12)

        labout.append("\nData Set:")
        labout.append("File     = {}"    .format(DataSrc))
        labout.append("Records  = {}"    .format(x.size))
        labout.append("Cycletime={:8.2f}".format(cycletime * 86400) + " sec (overall average)")
        labout.append("Average  ={:8.2f}".format(avg))
        labout.append("Variance ={:8.2f}  same as Average if true Poisson Dist.".format(var))
        labout.append("Std.Dev. ={:8.2f}".format(std))
        labout.append("Sqrt(Avg)={:8.2f}  same as Std.Dev. if true Poisson Dist.".format(np.sqrt(avg)))
        labout.append("Std.Err. ={:8.2f}".format(std / np.sqrt(x.size)))

        try:
            skew     = stats.skew    (x)
            kurtosis = stats.kurtosis(x)
            labout.append("Skewness ={:8.2f}  0:Norm.Dist.; skewed to: +:right   -:left".format(skew))
            labout.append("Kurtosis ={:8.2f}  0:Norm.Dist.; shape is:  +:pointy: -:flat".format(kurtosis))
        except:
            labout.append("Skewness = Cannot calculate, Module scipy is missing")
            labout.append("Kurtosis = Cannot calculate, Module scipy is missing")
        labout.append("")

        fig2.canvas.draw_idle()
        d.exec_()
        #plt.close()
        #plt.ion() # activate interactive mode again, IMPORTANT


    def createSyntheticLog(self):
        """Create synthetic data and save in log format.
        All times in SECONDS"""

        records     = 20000
        cycletime   = 1.0
        #mode        = "CPS"
        mode        = "CPM"

        mean        = 20  # -> "CPM"=150, like in KCl case
        stddev      = np.sqrt(mean)

    # get time
        t = np.float64(np.array(list(range(0, records)))) * cycletime
        print("time: size: {}, Delta-t: {} sec".format(t.size, (t[1] - t[0])))
        print(np.int_(t))

        # convert time in sec to datetime strings
        strt0 = "2018-01-01 00:00:00"          # nominal default start datetime
        t0    = mpld.datestr2num(strt0)        # time zero
        td    = np.empty(records, dtype='U19') # holds strings of max length 19
        print("td, len:", td.size, td)
        for i in range(0, records):
            td[i] = mpld.num2date(t0 + t[i] / 86400.) #clipped after 19 chars

    # get data
        #sigt, DataSrc     = self.getWhiteNoisePoisson(records, mean, cycletime, mode)       # White Noise from Poisson Distribution
        #sigt,  DataSrc    = self.getWhiteNoiseNormal(records, mean=mean, stddev=stddev)    # White Noise from Normal Distribution
        #sigt,  DataSrc    = self.getSinus(records, t)                                      # Sine (one or more)
        #sigt,  DataSrc    = self.getWhiteNoiseSine(records, t)                             # White Noise with Sine
        #sigt,  DataSrc    = self.getConstantData(records, t)                               # constant + breaks
        #sigt, DataSrc     = self.getAutocorr(records)                                      # Autocorr as time function
        #sigt, DataSrc     = self.getRectangle(records)                                      # Rectangle of 20 samples @ 3sec = 1min
        #sigt, DataSrc     = self.getWhiteNoisePoissonAutocorr(records, mean, cycletime)     # Autocorrelated Poisson Noise
        sigt, DataSrc     = self.getRandomData(records, mean, stddev)                  # Radom Data

        # Mean=17, followed by mean=29
        #sigt1, DataSrc     = self.getWhiteNoisePoisson(20000, mean=17)                  # White Noise from Poisson Distribution
        #sigt2, DataSrc2    = self.getWhiteNoisePoisson(20000, mean=29)                  # White Noise from Poisson Distribution
        #sigt = np.concatenate((sigt1 , sigt2))
        #print "len(sigt):", len(sigt)
        #DataSrc = "WhiteNoisePoisson,mean=17&29CPM"

        print(DataSrc)

        if mode == "CPS":
            sigt *= 60              # save as CPM

        for i in range(0, 10): print("i: {:4d}, time(sec): {:5.2f}, sigt: {}".format(i, t[i] * 60., sigt[i]))
        print("...")
        for i in range(0, records, int(records/10.)): print("i: {:4d}, time(min): {:5.2f}, sigt: {}".format(i, t[i], sigt[i]))

    # write to log file
        path = gglobs.dataPath + "/" + DataSrc + ".log"
        writeFileW(path, "", linefeed = True)
        writeFileA(path, "#HEADER ," + strt0 + ", SYNTHETIC data: " + DataSrc)
        writeFileA(path, "#LOGGING," + strt0 + ", Start: cycle {} sec, mode '{}', device 'SYNTHETIC'".format(cycletime, mode))
        for i in range(records):
            writestring = " {:7d},{:19s}, {:}".format(i, td[i], sigt[i])
            writeFileA(path, writestring)


    def getWhiteNoisePoisson(self, records, mean, cycletime, mode):
        """White noise data drawn from Poisson distribution"""

        DataSrc = "WhiteNoisePoisson, mean={}, cycle={}, mode={}".format(mean, cycletime, mode)

        x = np.random.poisson(mean, size=records )
        print("x.size, x.mean, x.var, x.std. :", x.size, np.mean(x), np.var(x), np.std(x))
        print(x)

        return x, DataSrc


    def getWhiteNoisePoissonAutocorr(self, records, mean, cycletime):
        """White noise data drawn from Poisson distribution"""

        DataSrc = "Autocorrelated Poisson Noise, CPM={}, cycle={}sec".format(mean, cycletime)

        x    = np.random.poisson(mean / 60., size=records * 60 + 60 )
        print("x.size, x.mean, x.var, x.std. :", x.size, np.mean(x), np.var(x), np.std(x))
        print(x)

        x2   = np.zeros(records)
        print("all zeros: x2.size, x2.mean, x2.var, x2.std. :", x2.size, np.mean(x2), np.var(x2), np.std(x2))

        for i in range(0, records):
            j = i * cycletime
            x2[i] = np.sum(x[j : j + 60])

        print("x2.size, x2.mean, x2.var, x2.std. :", x2.size, np.mean(x2), np.var(x2), np.std(x2))

        return x2, DataSrc


    def getSinus(self, records, t):
        """
        sinus data
        All times in seconds
        """

        DataSrc = "Sinus"

        pi2 = 2.0 * np.pi

        x   = 10.0 + 5.0 * np.sin(t * pi2 / (100. * 60. +  0. )  ) # periode von 100   min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (400. * 60. +  0. )  ) # periode von 400   min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / ( 30. * 60. +  0. )  ) # periode von  50   min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (  3. * 60. +  4. )  ) # periode von   3.x min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (  3. * 60. +  9. )  ) # periode von   3.y min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (  3. * 60. + 13. )  ) # periode von   3.z min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (  1.0            )  ) # periode von   1   sec
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (  0.5            )  ) # periode von   0.5 sec

        return x, DataSrc


    def getConstantData(self, records, t):
        """
        constant data
        All times in seconds
        """

        DataSrc = "Constant + Breaks"

        x  = np.ones(records) * 1000

        for i in range(0, records - 10, 20):
            x[i] = 500.
            x[i + 1] = -10.
            x[i + 2] = 1.

        return x, DataSrc


    def getWhiteNoiseNormal(self, records, mean=16, stddev=4):
        """
        White noise data
        All times in seconds
        """

        DataSrc = "WhiteNoiseNormal, mean={}, stddev={:3.2f}".format(mean, stddev)

        x = np.random.normal(mean, stddev, size=records)

        return x, DataSrc


    def getAutocorr(self, records):
        """
        The autocorrelation function as time series to use as input
        All times in seconds
        """

        DataSrc = "Autocorrelation as time series - 1st point=1"

        # a small random component
        mean = 0
        std  = 0.01
        x    = np.random.normal(mean, std, size=records)

        #for a 1 sec cycle time the first 60 records will show a linear down curve
        #for i in range (0, 20):
        #    x[i] = 1 - i * 1./20.

        x[0] = 1


        return x, DataSrc


    def getRectangle(self, records):
        """
        A rectangle 1 min long with 20 samples @ assumed 3sec cycle
        """

        DataSrc = "Rectangle_1min"

        x = np.zeros(records)
        #print x
        for i in range(20):
            x[i] = 1
        print("x:", len(x), x)

        return x, DataSrc



    def getWhiteNoiseSine(self, records, t):
        """
        White noise with Sine data
        All times in seconds
        """

        DataSrc = "WhiteNoiseNormal + Sine"

        pi2 = 2.0 * np.pi

        mean = 2500
        std  = np.sqrt(mean)
        x    = np.random.normal(mean, std, size=records)
        p1   = (100. * 60. + 1.4) / 60.  # 100,0333 min
        print("getWhiteNoiseSinusData: p1:", p1)
        x   +=  40. * std * (np.sin(t * pi2 / p1 ))
        x   +=  10. * std * (np.sin(t * pi2 / 11. ))

        return x, DataSrc


    def getRandomData(self, records, mean, stddev):
        """random data"""

        DataSrc = "Random Data, mean={}, Uniform 0...{}".format(mean, mean*2)

        x = mean * 2 * np.random.rand(records)
        print(DataSrc, x)

        return x, DataSrc

#**Begin Eval_plotFFT *********************************************************

    def Eval_plotFFT(self, type = 'plot'):
        """Plotting FFT and Autocorrelation
        t       = time
        sigt    = Signal in time domain, (CPM/CPS here)
        freq    = Signal in frequency domain

        Has extra function for rectangle and autocorr
        """
        markersize = 0.5#1.0

        if type == 'plot':              # use only data shown in the plot
            #print "gglobs.logTimeDiffSlice:", len(gglobs.logTimeDiffSlice), "\n", gglobs.logTimeDiffSlice
            #print "gglobs.logCPMSlice:", len(gglobs.logCPMSlice), "\n", gglobs.logCPMSlice
            rawt    = gglobs.logTimeDiffSlice
            rawsigt = gglobs.logCPMSlice
            winTitleLabel = " (Data from Plot Only)"
        else:                           # use all data of the file
            #print "gglobs.logTimeDiff", len(), "\n", gglobs.logTimeDiff
            #print "gglobs.logCPM", len(gglobs.logCPM), "\n", gglobs.logCPM
            rawt    = gglobs.logTimeDiff
            rawsigt = gglobs.logCPM
            winTitleLabel = " (Data from complete File )"

        if rawsigt is None:
            self.showStatusMessage("No file available")
            return

        if rawt.size < 20:
            self.showStatusMessage("Not enough data (need 20+)")
            return

        DataSrc = os.path.basename(gglobs.currentFilePath)

        t    = rawt.copy()
        sigt = rawsigt.copy()

        # if CPS selected in Graph, treat sigt data as CPS
        if self.yunit.currentText() == "CPS":
            sigt /= 60.
            yunit = "CPS"
        else:
            yunit = "CPM"

# Window functions ############################################################
        # the only place to activate Window function is here
        use_window_functions = False

        if use_window_functions:
            hamm    = np.hamming (len(t))
            hann    = np.hanning (len(t))
            black   = np.blackman(len(t))
            # Kaiser:
            # "A beta value of 14 is probably a good starting point"
            # beta  Window shape
            # 0     Rectangular
            # 5     Similar to a Hamming
            # 6     Similar to a Hanning
            # 8.6   Similar to a Blackman
            beta    = 5
            kaiser  = np.kaiser(len(t), beta)

            # Select one
            #win     = hamm
            #win     = hann
            #win     = black
            win     = kaiser

            # When using window functions subtract the average in order to avoid
            # spurious low-frequency peaks!
            sigt   = sigt - np.mean(sigt)

            # Time domain signal with Window function applied
            sigt_win = sigt * win

# Prepare variables ###########################################################

        t               = t * 1440.0  # convert days to minutes
        timeunit        = "minutes"
        frequencyunit   = "1/minute"
        cycletime       = (t[-1] - t[0]) / (t.size -1)  # in minutes

        sigt_mean       = np.mean(sigt)
        sigt_var        = np.var(sigt)
        sigt_std        = np.std(sigt)
        sigt_var        = np.var(sigt)
        sigt_err        = sigt_std / np.sqrt(sigt.size)

        print("t:    size:"       , t.size        , "\n", t)
        print("sigt: size:"       , sigt.size     , "\n", sigt)
        #print "sigt_win: size:"  , sigt_win.size , "\n", sigt_win


# figure and canvas ###################################################
        fig3 = plt.figure(3, facecolor = "#C9F9F0") # blueish tint
        plt.clf()
        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        canvas3 = FigureCanvas(fig3)
        canvas3.setFixedSize(1800, 700)
        navtoolbar = NavigationToolbar(canvas3, self)

# Data vs Time ################################################################
        plt.subplot (2,4,2)
        plt.title   ("Time Counts", fontsize=12, loc = 'left')
        plotSubTitle = "Recs:" + str(sigt.size)
        plt.title   (plotSubTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Time ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Count Rate  " + yunit, fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.plot    (t, sigt        ,  linewidth=0.4, color='red'   , label ="Time Domain" , marker="o", markeredgecolor='red'   , markersize=markersize)

# Autocorrelation vs Lag #########################################################
    # calculations
        asigt = sigt - sigt_mean
        #print "np.mean(sigt) , np.var(sigt) :", np.mean(sigt),  np.var(sigt)
        #print "np.mean(asigt), np.var(asigt):", np.mean(asigt), np.var(asigt)

        asigtnorm = np.var(asigt) * asigt.size  # to normalize autocorrelation
        ac = np.correlate(asigt, asigt, mode='full') / asigtnorm
        #ac = ac[ac.size/2:]
        ac = ac[int(ac.size/2):]
        #print "ac: len:", ac.size
        #print "ac:", "\n", ac

    # autocorrelation plot
        aax1 =  plt.subplot(2,4, 5)

        plt.title   ("Autocorrelation (normalized) vs. Lag Period", fontsize=11, loc = 'left', y = 1.08)
        plt.xlabel  ("Lag Period ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Autocorrelation", fontsize=12)
        plt.grid    (True)
        #plt.ticklabel_format(useOffset=False)

        aax2 = aax1.twiny()

        # how many points to show enlarged?
        for i in range(t.size):
            if ac[i] < 0: break

        tindex = min(i, t.size * 0.01)
        tindex = max(25, tindex, 60./(cycletime * 60.))
        tindex = int(tindex)  # Warning: ./geigerlog:3483: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
                              # aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="o", markeredgecolor='blue'  , markersize=markersize*2)
                              # What is the reason ?????
        #print "tindex:", tindex

        tnew = t - t[0]
        aax1.plot(tnew,          ac         , linewidth= 1.0, color='red'  , label ="Full Lag Period - Bottom Scale" , marker="o", markeredgecolor='red'   , markersize=markersize * 2)
        #aax1.legend(loc='upper right', fontsize=12)

        aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="D", markeredgecolor='blue'  , markersize=markersize * 6)
        #print "ac:", ac[:10]

        #plt.legend(loc='upper right', fontsize=12)
        plt.legend(loc='upper right', fontsize=8)

        for a in aax1.get_xticklabels():
            #a.set_color("red")
            #a.set_weight("bold")
            pass

        for a in aax2.get_xticklabels():
            a.set_color("blue")
            a.set_weight("bold")

# FFT plots
    # calculations
        # using amplitude spectrum, not power spectrum; power would be freq^2
        freq                = np.abs(np.fft.rfft(sigt     ))
        #freq2              = np.abs(np.fft.rfft(sigt2    ))
        print("freq:"       , len(freq)     , "\n", freq)
        #for i in range(0,100):  print freq[i]

        if use_window_functions:
            freq_win        = np.abs(np.fft.rfft(sigt_win ))
            #print "freq_win:"   , len(freq_win) , "\n", freq_win
            #for i in range(0,100):  print freq_win[i]

        f = np.fft.rfftfreq(t.size, d = cycletime)
        #print "f:   len:", f.size, "\n", f

        p  = np.reciprocal(f[1:])  # skipping 1st value frequency = 0
        #print "Period: len:", p.size, "\n", p


    # Plot FFT vs Time #########################################################
        plt.subplot(2, 4, 1)
        plt.title("FFT Spectrum vs. Time Period", fontsize=12, loc = 'left')
        plotSubTitle = "Recs:" + str(freq.size)
        plt.title   (plotSubTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel("Time Period ({})".format(timeunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.loglog(p, freq[1:]        , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)

    # Plot FFT vs Frequency ####################################################
        plt.subplot(2, 4, 6)
        #plt.title("FFT Spectrum vs. Frequency", fontsize=12, loc = 'left')
        plt.title("FFT Counts", fontsize=12, loc = 'left')
        plotSubTitle = "Recs:" + str(freq.size)
        plt.title   (plotSubTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], freq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)


# convolution plots ####################################################

        # rect for convolution - nr values of 1, followed by zeros
        nr = int(60 * 0.2)  # nr = 12
        nr = 60

        rect = np.zeros(sigt.size)
        for i in range(nr):
            rect[i] = 1
        print("rect:", len(rect), rect)

        # time axis
        bf = t[:rect.size]

    # Plot Rectangle Signal vs time

        plt.subplot (2, 4, 3)
        plt.title   ("Time Rectangle", fontsize=12, loc = 'left')
        plotSubTitle = "Recs:" + str(rect.size)
        plt.title   (plotSubTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Time ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Signal Value", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)
        plt.plot (bf, rect     , linewidth= 1.0, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize*4)


    # FFT of Signal vs Frequency ####################################################

        cfreq = np.abs(np.fft.rfft(rect     ))
        print("cfreq:   len:", cfreq.size, "\n", cfreq)

        f = np.fft.rfftfreq(t.size, d = cycletime)
        print("f:   len:", f.size, "\n", f)

        p  = np.reciprocal(f[1:])  # skipping 1st value frequency = 0
        print("Period: len:", p.size, "\n", p)

        plt.subplot (2, 4, 7)
        plt.title   ("FFT Rectangle", fontsize=12, loc = 'left')
        plotSubTitle = "Recs:" + str(cfreq.size)
        plt.title   (plotSubTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel  ("FFT Amplitude", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], cfreq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)


# last columns
    # upper

        csigt = scipy.signal.convolve(rect, sigt ) * (60 / nr)
        csigt = csigt[nr:len(sigt) + nr]
        print("csigt:", len(csigt), csigt)

        plt.subplot (2, 4, 4)
        plt.title   ("Time (Counts CNV Rectangle)", fontsize=12, loc = 'left')
        plotSubTitle = "Recs:" + str(csigt.size)
        plt.title   (plotSubTitle, fontsize=10, fontweight='normal', loc = 'right')

        plt.xlabel  ("Time ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Count Rate CPM", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.plot (t[:-nr], csigt[:-nr]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)

    # lower
        ccfreq = cfreq * freq

        plt.subplot (2, 4, 8)
        plt.title   ("FFT (Counts CNV Rectangle)", fontsize=12, loc = 'left')
        plotSubTitle = "Recs:" + str(cfreq.size)
        plt.title   (plotSubTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel  ("FFT Amplitude", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], ccfreq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)



# arrange sub plots
        plt.subplots_adjust(hspace=0.4, wspace=0.3, left=.05, top=0.95, bottom=0.09, right=.97)

# textboxes ################################################################
        labout_left  = QtGui.QTextBrowser() # label to hold some data on left side
        labout_left.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout_left.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout_left.setMinimumHeight(150)

        #labout_left.append("{:22s}= {}"                             .format('File'               , os.path.basename(gglobs.currentFilePath)))
        labout_left.append("{:22s}= {}"                             .format('File'               , DataSrc))
        labout_left.append("{:22s}= {}"                             .format("No of Records"      , t.size))
        labout_left.append("{:22s}= {:4.2f}"                        .format("Count Rate Average" , sigt_mean))
        labout_left.append("{:22s}= {:4.2f} (Std.Dev:{:5.2f}, Std.Err:{:5.2f})"    .format("Count Rate Variance" , sigt_var, sigt_std, sigt_err))
        labout_left.append("{:22s}= {:4.2f} sec (overall average)"  .format("Cycle Time"         , cycletime * 60.)) # t is in minutes
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag=  0   sec)", ac[0]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[1] *60.), ac[1]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[2] *60.), ac[2]))
        #labout_left.append("{:22s}= {:4.2f} "                       .format("Autoc(lag={:5.1f} sec)".format(tnew[3] *60.), ac[3]))

        labout_right  = QtGui.QTextBrowser() # label to hold some data on right side
        labout_right.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout_right.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout_right.setMinimumHeight(120)

        fftmax      = np.max    (freq[1:])
        fftmaxindex = np.argmax (freq[1:]) + 1
        f_max       = f         [fftmaxindex ]

        labout_right.append("{:22s}= {:4.0f}"              .format("FFT(f=0)"         , freq[0]) )
        #labout_right.append("{:22s}= {:4.0f}"              .format("len(t)"         , len(t)) )
        labout_right.append("{:22s}= {:4.2f} (= FFT(f=0)/No of Records)".format("Count Rate Average", freq[0] / len(t)) )
        labout_right.append("{:22s}= {:4.2f}"              .format("Max FFT(f>0)"     , fftmax))
        labout_right.append("{:22s}= {}"                   .format("  @ Index"        , fftmaxindex))
        labout_right.append("{:22s}= {:4.4f}"              .format("  @ Frequency"    , f_max ))
        try:
            labout_right.append("{:22s}= {:4.4f}"              .format("  @ Period"       , p[fftmaxindex] ))
        except:
            labout_right.append("{:22s}= {:s}"              .format("  @ Period"       , "undefined" ))


# Pop Up  #################################################################
        d       = QtGui.QDialog()
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        d.setFont(self.fontstd)
        d.setWindowTitle("FFT & Autocorrelation" + winTitleLabel)
        #d.setMinimumHeight(gglobs.window_height)
        #d.setWindowModality(QtCore.Qt.ApplicationModal)
        #d.setWindowModality(QtCore.Qt.NonModal)
        d.setWindowModality(QtCore.Qt.WindowModal)

        bbox    = QtGui.QDialogButtonBox()
        bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutH   = QtGui.QHBoxLayout()
        layoutH.addWidget(labout_left)
        layoutH.addWidget(labout_right)


        layoutV   = QtGui.QVBoxLayout(d)
        layoutV.addWidget(navtoolbar)
        layoutV.addWidget(canvas3)
        layoutV.addLayout(layoutH)
        layoutV.addWidget(bbox)

        fig3.canvas.draw_idle()
        d.exec_()

#**End Eval_plotFFT ***********************************************************


    def plotFFT(self, type = 'plot'):
        """Plotting FFT and Autocorrelation
        t       = time
        sigt    = Signal in time domain, (CPM/CPS here)
        freq    = Signal in frequency domain
        """

        markersize = 1.0

        if type == 'plot':              # use only data shown in the plot
            #print "gglobs.logTimeDiffSlice:", len(gglobs.logTimeDiffSlice), "\n", gglobs.logTimeDiffSlice
            #print "gglobs.logCPMSlice:", len(gglobs.logCPMSlice), "\n", gglobs.logCPMSlice
            rawt    = gglobs.logTimeDiffSlice
            rawsigt = gglobs.logCPMSlice
            winTitleLabel = " (Data from Plot Only)"
        else:                           # use all data of the file
            #print "gglobs.logTimeDiff", len(), "\n", gglobs.logTimeDiff
            #print "gglobs.logCPM", len(gglobs.logCPM), "\n", gglobs.logCPM
            rawt    = gglobs.logTimeDiff
            rawsigt = gglobs.logCPM
            winTitleLabel = " (Data from complete File )"

        if rawsigt is None:
            self.showStatusMessage("No file available")
            return

        if rawt.size < 20:
            self.showStatusMessage("Not enough data (need 20+)")
            return

        DataSrc = os.path.basename(gglobs.currentFilePath)

        t    = rawt.copy()
        sigt = rawsigt.copy()

        # if CPS selected in Graph, treat sigt data as CPS
        if self.yunit.currentText() == "CPS":
            sigt /= 60.
            yunit = "CPS"
        else:
            yunit = "CPM"


        ####### Window functions ##############################################
        # the only place to activate Window function is this:
        use_window_functions = False

        if use_window_functions:
            hamm    = np.hamming (len(t))
            hann    = np.hanning (len(t))
            black   = np.blackman(len(t))
            # Kaiser:
            # "A beta value of 14 is probably a good starting point"
            # beta  Window shape
            # 0     Rectangular
            # 5     Similar to a Hamming
            # 6     Similar to a Hanning
            # 8.6   Similar to a Blackman
            beta    = 5
            kaiser  = np.kaiser(len(t), beta)

            # Select one
            #win     = hamm
            #win     = hann
            #win     = black
            win     = kaiser

            # When using window functions subtract the average in order to avoid
            # spurious low-frequency peaks!
            sigt   = sigt - np.mean(sigt)
            #sigt2  = sigt - np.mean(sigt)

            # Time domain signal with Window function applied
            sigt_win = sigt * win
        #######################################################################

        t               = t * 1440.0  # convert days to minutes
        timeunit        = "minutes"
        frequencyunit   = "1/minute"
        cycletime       = (t[-1] - t[0]) / (t.size -1)  # in minutes

        sigt_mean       = np.mean(sigt)
        sigt_var        = np.var(sigt)
        sigt_std        = np.std(sigt)
        sigt_var        = np.var(sigt)
        sigt_err        = sigt_std / np.sqrt(sigt.size)


        # FFT calculation #####################################################
        # using amplitude spectrum, not power spectrum; power would be freq^2
        freq         = np.abs(np.fft.rfft(sigt     ))
        #freq2        = np.abs(np.fft.rfft(sigt2    ))

        if use_window_functions:
            freq_win     = np.abs(np.fft.rfft(sigt_win ))

        #print "t:    len:"       , len(t)        , "\n", t
        #print "sigt: len:"       , len(sigt)     , "\n", sigt
        #print "sigt_win:"   , len(sigt_win) , "\n", sigt_win
        #print "freq:"       , len(freq)     , "\n", freq
        #for i in range(0,100):  print freq[i]
        #print "freq_win:"   , len(freq_win) , "\n", freq_win
        #for i in range(0,100):  print freq_win[i]

        f = np.fft.rfftfreq(t.size, d = cycletime)
        #print "f:   len:", f.size, "\n", f

        p  = np.reciprocal(f[1:])  # skipping 1st value frequency = 0
        #print "Period: len:", p.size, "\n", p

        asigt = sigt - sigt_mean
        #print "np.mean(sigt) , np.var(sigt) :", np.mean(sigt),  np.var(sigt)
        #print "np.mean(asigt), np.var(asigt):", np.mean(asigt), np.var(asigt)

        asigtnorm = np.var(asigt) * asigt.size  # to normalize autocorrelation
        ac = np.correlate(asigt, asigt, mode='full') / asigtnorm
        #print( "ac: len:", ac.size)
        ac = ac[int(ac.size/2):]
        #print( "ac: len:", ac.size)
        #print( "ac:", "\n", ac)


# figure and canvas ###################################################
        fig3 = plt.figure(3, facecolor = "#C9F9F0") # blueish tint
        plt.clf()
        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        canvas3 = FigureCanvas(fig3)
        canvas3.setFixedSize(1000, 600)
        navtoolbar = NavigationToolbar(canvas3, self)

# Data vs Time ################################################################
        plt.subplot(2,2,1)
        plt.title("Time Course", fontsize=12, loc = 'left')
        #plotSubTitle = "Recs:" + str(gglobs.sizePlotSlice)
        plotSubTitle = "Recs:" + str(sigt.size)
        plt.title(plotSubTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel("Time ({})".format(timeunit), fontsize=12)
        plt.ylabel("Count Rate  " + yunit, fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.plot(t, sigt        ,  linewidth=0.4, color='red'   , label ="Time Domain" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.plot(t, sigt_win    ,  linewidth=0.4, color='black' , label ="Time Domain" , marker="o", markeredgecolor='black' , markersize=markersize)

# Autocorrelation vs Lag #########################################################
        aax1 =  plt.subplot(2,2,3)

        plt.title("Autocorrelation (normalized) vs. Lag Period", fontsize=12, loc = 'left', y = 1.1)
        plt.xlabel("Lag Period ({})".format(timeunit), fontsize=12)
        plt.ylabel("Autocorrelation", fontsize=12)
        plt.grid(True)
        #plt.ticklabel_format(useOffset=False)

        aax2 = aax1.twiny()

        # how many points to show enlarged?
        for i in range(t.size):
            if ac[i] < 0: break

        tindex = min(i, t.size * 0.01)
        tindex = max(25, tindex, 60./(cycletime * 60.))
        tindex = int(tindex)  # Warning: ./geigerlog:3483: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
                              # aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="o", markeredgecolor='blue'  , markersize=markersize*2)
                              # What is the reason ?????
        #print "tindex:", tindex
        #print "type(tindex):", type(tindex)

        tnew = t - t[0]
        aax1.plot(tnew,          ac         , linewidth= 0.4, color='red'  , label ="Full Lag Period - Bottom Scale" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #aax1.legend(loc='upper right', fontsize=12)

        aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="o", markeredgecolor='blue'  , markersize=markersize * 2)
        #print "ac:", ac[:10]

        #plt.legend(loc='upper right', fontsize=12)
        plt.legend(loc='upper right', fontsize=10)

        for a in aax1.get_xticklabels():
            #a.set_color("red")
            #a.set_weight("bold")
            pass

        for a in aax2.get_xticklabels():
            a.set_color("blue")
#            a.set_weight("bold")

# FFT vs Time #########################################################
        plt.subplot(2,2,2)
        plt.title("FFT Amplitude Spectrum vs. Time Period", fontsize=12, loc = 'left')
        plt.xlabel("Time Period ({})".format(timeunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.loglog(p, freq[1:]        , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.loglog(p, freq2[1:] -freq[1:]       , linewidth= 0.4, color='black'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.loglog(p, freq_win[1:]    , linewidth= 0.4, color='black' , label ="FFT" , marker="o", markeredgecolor='black' , markersize=markersize)

# FFT vs Frequency ####################################################
        plt.subplot(2,2,4)
        plt.title("FFT Amplitude Spectrum vs. Frequency", fontsize=12, loc = 'left')
        plt.xlabel("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], freq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.semilogy (f[1:], freq2[1:] -freq[1:]     , linewidth= 0.4, color='black'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.semilogy (f[1:], freq_win[1:] , linewidth= 0.4, color='black' , label ="FFT" , marker="o", markeredgecolor='black' , markersize=markersize)

        #plt.legend(loc='upper left', fontsize=12)

# arrange sub plots
        plt.subplots_adjust(hspace=0.5, wspace=0.2, left=.08, top=0.95, bottom=0.090, right=.98)

# textboxes ################################################################
        labout_left  = QtGui.QTextBrowser() # label to hold some data on left side
        labout_left.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout_left.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout_left.setMinimumHeight(150)

        labout_left.append("{:22s}= {}"                             .format('File'               , DataSrc))
        labout_left.append("{:22s}= {}"                             .format("No of Records"      , t.size))
        labout_left.append("{:22s}= {:4.2f}"                        .format("Count Rate Average" , sigt_mean))
        labout_left.append("{:22s}= {:4.2f} (Std.Dev:{:5.2f}, Std.Err:{:5.2f})"    .format("Count Rate Variance" , sigt_var, sigt_std, sigt_err))
        labout_left.append("{:22s}= {:4.2f} sec (overall average)"  .format("Cycle Time"         , cycletime * 60.)) # t is in minutes
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag=  0   sec)", ac[0]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[1] *60.), ac[1]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[2] *60.), ac[2]))

        labout_right  = QtGui.QTextBrowser() # label to hold some data on right side
        labout_right.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout_right.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout_right.setMinimumHeight(120)

        fftmax      = np.max    (freq[1:])
        fftmaxindex = np.argmax (freq[1:]) + 1
        f_max       = f         [fftmaxindex ]

        labout_right.append("{:22s}= {:4.0f}"              .format("FFT(f=0)"         , freq[0]) )
        labout_right.append("{:22s}= {:4.2f} (= FFT(f=0)/No of Records)".format("Count Rate Average", freq[0] / len(t)) )
        labout_right.append("{:22s}= {:4.2f}"              .format("Max FFT(f>0)"     , fftmax))
        labout_right.append("{:22s}= {}"                   .format("  @ Index"        , fftmaxindex))
        labout_right.append("{:22s}= {:4.4f}"              .format("  @ Frequency"    , f_max ))
        labout_right.append("{:22s}= {:4.4f}"              .format("  @ Period"       , p[fftmaxindex] ))


# Pop Up  #################################################################
        d       = QtGui.QDialog()
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        d.setFont(self.fontstd)
        d.setWindowTitle("FFT & Autocorrelation" + winTitleLabel)
        #d.setMinimumHeight(gglobs.window_height)
        #d.setWindowModality(QtCore.Qt.ApplicationModal)
        #d.setWindowModality(QtCore.Qt.NonModal)
        d.setWindowModality(QtCore.Qt.WindowModal)

        bbox    = QtGui.QDialogButtonBox()
        bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutH   = QtGui.QHBoxLayout()
        layoutH.addWidget(labout_left)
        layoutH.addWidget(labout_right)


        layoutV   = QtGui.QVBoxLayout(d)
        layoutV.addWidget(navtoolbar)
        layoutV.addWidget(canvas3)
        layoutV.addLayout(layoutH)
        layoutV.addWidget(bbox)

        fig3.canvas.draw_idle()
        d.exec_()



    def btnAlpha(self):
        """EvalFFT"""

        self.Eval_plotFFT()


    def btnBeta(self):
        """createSyn"""

        self.createSyntheticLog()


    def btnGamma(self):
        """PlotCCD"""

        self.btnPlotCCD.setChecked(True)
        self.PlotCCD()
        gglobs.ccdChecked = False
        self.avgbox         .setEnabled(True)
        self.logbox         .setEnabled(True)
        self.mavbox         .setEnabled(True)
        self.mav            .setEnabled(True)
        self.btnMoveLegend  .setEnabled(True)


    def btnDelta(self):
        """PushToWeb"""

        self.pushToWeb()


    def btnEpsilon(self):
        """PrintVars"""

        printVarsStatus(True, origin = "btnEpsilon")


    def btnZeta(self):
        """HelpOpt"""

        self.helpOptions()


    def btnEta(self):
        """ChngOpt"""

        self.changeOptions()


    def btnTheta(self):
        """SysInfo"""

        self.showSystemInfo()


    def btnIota(self):
        """Empty"""

        pass


    def pushToWeb(self):
        """Send countrate info to website"""

        """
        GMCmap:
        from: http://www.gmcmap.com/AutomaticallySubmitData.asp

        Auto submit data URL format:
        http://www.GMCmap.com/log2.asp?AID=UserAccountID&GID=GeigerCounterID &CPM=nCPM&ACPM=nACPM&uSV=nuSV
        At lease one reading data has to be submitted.
            UserAccountID:   user account ID. This ID is assigned once a user registration is completed.
            GeigerCounterID: a global unique ID for each registered Geiger Counter.
            nCPM:  Count Per Minute reading from this Geiger Counter.
            nACPM: Average Count Per Minute reading from this Geiger Counter(optional).
            nuSv:  uSv/h reading from this Geiger Counter(optional).

        Followings are valid data submission examples:
            http://www.GMCmap.com/log2.asp?AID=0230111&GID=0034021&CPM=15&ACPM=13.2&uSV=0.075
            http://www.GMCmap.com/log2.asp?AID=0230111&GID=0034021&CPM=15&ACPM=0&uSV=0
            http://www.GMCmap.com/log2.asp?AID=0230111&GID=0034021&CPM=15&ACPM=0&uSV=0
            http://www.GMCmap.com/log2.asp?AID=0230111&GID=0034021&CPM=15
            http://www.GMCmap.com/log2.asp?AID=0230111&GID=0034021&CPM=15&ACPM=13.2

        The submition result will be returned immediately. Followings are the returned result examples:
            OK.
            Error! User is not found.ERR1.
            Error! Geiger Counter is not found.ERR2.
            Warning! The Geiger Counter location changed, please confirm the location.
         """

        # for TESTING only
        gglobs.calibration = 0.0065

        cpmdata = gglobs.logCPMSlice
        lendata = len(cpmdata)
        CPM     = np.mean(cpmdata)
        ACPM    = CPM
        uSV     = CPM * gglobs.calibration

        #Defintions valid only for GMCmap.com
        data         = {}
        data['AID']  = gglobs.UserID
        data['GID']  = gglobs.CounterID
        data['CPM']  = "{:3.1f}".format(CPM)
        data['ACPM'] = data['CPM']
        data['uSV']  = "{:3.2f}".format(uSV)
        gmcmapURL    = gglobs.GMCmapURL + '?' + urllib.parse.urlencode(data)

        strdata = ""
        mapform = "   {:11s}: {}\n"
        strdata += mapform.format("CPM",        data['CPM'])
        strdata += mapform.format("ACPM",       data['ACPM'])
        strdata += mapform.format("uSV",        data['uSV'])
        strdata += mapform.format("UserID",     data['AID'])
        strdata += mapform.format("CounterID",  data['GID'])
        strdata  = strdata[:-2] # remove last linefeed

        # Dialog Confirm Sending
        msg = QtGui.QMessageBox()
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setIcon(QtGui.QMessageBox.Information)
        msg.setFont(self.fontstd)
        msg.setWindowTitle("Updating Radiation World Maps")
        datatext = "Uploading these data based on {} datapoints:                                          \n\n".format(lendata)
        datatext += strdata + "\n\nPlease confirm with OK, or Cancel"
        msg.setText(datatext)
        msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
        msg.setDefaultButton(QtGui.QMessageBox.Cancel)
        msg.setEscapeButton(QtGui.QMessageBox.Cancel)
        retval = msg.exec_()
        if retval != 1024:   return

        self.print2NotePad(header("Updating Radiation World Maps"))

        dprint(gglobs.debug, "GMCmapURL: " +  gmcmapURL)
        for a in ("AID", "GID", "CPM", "ACPM", "uSV"): # ordered print
            dprint(gglobs.debug, "{:5s}: {}".format(a, data[a]))

        try:
            with urllib.request.urlopen(gmcmapURL) as response:
                answer = response.read()
            dprint(gglobs.debug, "Server Response:", answer)
        except Exception as e:
            answer = b"Bad URL"
            srcinfo = "Bad URL: " + gmcmapURL
            exceptPrint(e, sys.exc_info(), srcinfo)

        # gmcmap server response
        # on wrong credentials:
        # b'\r\n<!--               sendmail.asp-->\r\n\r\nError! User not found.ERR1.'
        # on proper credentials:
        # b'\r\n<!--               sendmail.asp-->\r\n\r\nWarrning! Please update/confirm your location.<BR>OK.ERR0'
        # on proper userid but wrong counter id
        # b'\r\n<!--               sendmail.asp-->\r\n\r\nError! Geiger Counter not found.ERR2.'

        if   b"ERR1" in answer or b"ERR2" in answer :   # wrong userid  or wrong counterid
            self.print2NotePad("Failure updating Radiation World Maps. Website says:")
            self.errprint2NotePad(answer.decode('UTF-8'))

        elif b"ERR0" in answer:
            self.print2NotePad("Successfully updated Radiation World Maps with these data:")
            self.print2NotePad(strdata)
            self.print2NotePad("Website says:")
            self.errprint2NotePad(answer.decode('UTF-8'))

        elif b"Bad URL" in answer:
            self.print2NotePad("Failure updating Radiation World Maps. ERROR:")
            self.errprint2NotePad("Bad URL: " + gmcmapURL)

        else:
            self.print2NotePad("Unexpected response updating Radiation World Maps; Website says:")
            self.errprint2NotePad(answer.decode('UTF-8'))


    def PlotCCD(self):
        """Plot Cum Count Dev"""

        if self.btnPlotCCD.isChecked():
            #print( "button pressed")
            gglobs.ccdChecked   = True
            self.btnPlotCCD     .setStyleSheet("color: blue; font-weight:bold;" )
            self.avgbox         .setEnabled(False)
            self.logbox         .setEnabled(False)
            self.mavbox         .setEnabled(False)
            self.mav            .setEnabled(False)
            self.btnMoveLegend  .setEnabled(False)

        else:
            #print ("button released")
            gglobs.ccdChecked   = False
            self.btnPlotCCD     .setStyleSheet("color:")
            self.avgbox         .setEnabled(True)
            self.logbox         .setEnabled(True)
            self.mavbox         .setEnabled(True)
            self.mav            .setEnabled(True)
            self.btnMoveLegend  .setEnabled(True)

        self.applyGraphOptions()



    def xxxevalAutocorr(self):
        """rewriting a log file to avoid autocorrelation. Omitting all values
        within last minute in CPM mode"""

        # if needed then needs to be rewritten with respect to datestr2num!
        # this is now done using mpld.datestr2num

        dprint(gglobs.debug, "evalAutocorr:")
        debugIndent(1)

        dlg=QtGui.QFileDialog(directory = gglobs.dataPath, caption= "Get Log File for evalAutocorr - select from existing")
        dlg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        dlg.setFileMode(QtGui.QFileDialog.ExistingFile)
        dlg.setViewMode(QtGui.QFileDialog.Detail)
        dlg.setFilter("Logging Files (*.log)")

        if dlg.exec_() == QtGui.QDialog.Accepted: # (=1)
            fnames  = dlg.selectedFiles()
            fn      = str(fnames[0])
            ext     = os.path.splitext(fn)[1]
            if ext != ".log":  fn += ".log"      # forces the ".log" extension

        else: # QtGui.QDialog.Rejected (= 0)
            dprint(gglobs.debug, "evalAutocorr: FileDialog Cancel")
            debugIndent(0)
            return

        # rewriting a log file to avoid autocorrelation

        cdata = readFileLines(fn)
        dprint(gglobs.debug, "file: len:", len(cdata), fn)

        writeFileW(fn + ".short.log", "")
        lasttime = 0
        for a in cdata:
            if a[0] == "#":
                writeFileA(fn + ".short.log", a[:-1])
            else:
                newtime = datestr2num(a[8:27])
                if newtime - lasttime >= 60:
                    writeFileA(fn + ".short.log", a[:-1])
                    lasttime = newtime
                else:
                    pass

        debugIndent(0)

######## class ggeiger ends ###################################################

# Configuration filereading
def readGeigerConfig():
    """reading the configuration file, return if not available.
    Not-available or illegal options are being ignored with only a debug message"""

    dprint(gglobs.debug, "readGeigerConfig: Using config file:", gglobs.configPath)
    debugIndent(1)

    infostr = "INFO: {:25s}: {}"
    while True:
        if not os.path.isfile(gglobs.configPath): # does the config file exist?
            dprint(True, "WARNING: Configuration file '{}' does not exist. Continuing with default values.".format(gglobs.configPath))
            break

        try:
            config = configparser.ConfigParser()
            config.readfp(open(gglobs.configPath))
        except:
            dprint(True, "WARNING: Configuration file '{}' exists, but cannot be read. Continuing with default values.".format(gglobs.configPath))
            dprint(True, "WARNING: Error message:", str(sys.exc_info()))
            break

    # Serial Port
        try:
            gglobs.usbport = config.get("Serial Port", "port")
            dprint(gglobs.debug, infostr.format("Using port", gglobs.usbport))
        except:
            dprint(True, "WARNING: Config Serial Port not available")

        try:
            b = config.getint("Serial Port", "baudrate")
            if b in gglobs.baudrates:
                gglobs.baudrate = b
            dprint(gglobs.debug, infostr.format("Using baudrate", gglobs.baudrate))
        except:
            dprint(True, "WARNING: Config baudrate not available")

        try:
            t = config.getfloat("Serial Port", "timeout")
            if t > 0:
                gglobs.timeout = t
            else:
                gglobs.timeout = 3  # if zero or negative value given, the set to 3

            dprint(gglobs.debug, infostr.format("Using timeout (sec)",gglobs.timeout))
        except:
            dprint(True, "WARNING: Config timeout not available")

        try:
            t = config.get("Serial Port", "ttyS")
            if t.upper() == 'INCLUDE':
                gglobs.ttyS = 'include'
            else:
                gglobs.ttys = 'ignore'
            dprint(gglobs.debug, infostr.format("Ports of ttyS type", gglobs.ttys))
        except:
            dprint(True, "WARNING: Config ttyS not available")

    # Device
        # Device customdevice
        # not needed anymore
        """
        try:
            gglobs.customdevice = config.get("Device", "customdevice")
            dprint(gglobs.debug, "INFO: Custom Device is: ", gglobs.customdevice)
        except:
            gglobs.customdevice = None
            dprint(True, "WARNING: Custom device not available")
        """

        # Device memory
        try:
            t = config.get("Device", "memory")
            if t.upper() == '1MB':
                gglobs.memory     = 2**20

            elif t.upper() == '64KB':
                gglobs.memory     = 2**16

            else:                               # auto
                gglobs.memory   = 'auto'

            dprint(gglobs.debug, infostr.format("Memory", gglobs.memory))
        except:
            dprint(True, "WARNING: Config memory not available")


        # Device SPIRpage
        try:
            t = config.get("Device", "SPIRpage")
            if t.upper() == '2K':
                gglobs.SPIRpage     = 2048
                #gglobs.memoryMode = 'fixed'

            elif t.upper() == '4K':
                gglobs.SPIRpage     = 4096
                #gglobs.memoryMode = 'fixed'

            else:                               # auto
                gglobs.SPIRpage = 'auto'

            dprint(gglobs.debug, infostr.format("SPIRpage", gglobs.SPIRpage))
        except:
            dprint(True, "WARNING: Config SPIRpage not available")

        # Device SPIRbugfix
        try:
            t = config.get("Device", "SPIRbugfix")
            if t.upper() == 'YES':
                gglobs.SPIRbugfix     = True
                #gglobs.memoryMode = 'fixed'

            elif t.upper() == 'NO':
                gglobs.SPIRbugfix     = False
                #gglobs.memoryMode = 'fixed'

            else:                               # auto
                gglobs.SPIRbugfix = 'auto'

            dprint(gglobs.debug, infostr.format("SPIRbugfix", gglobs.SPIRbugfix))
        except:
            dprint(True, "WARNING: Config SPIRbugfix not available")

        # Device configsize
        try:
            t = config.get("Device", "configsize")
            if t.upper() == '256':
                gglobs.configsize     = 256

            elif t.upper() == '512':
                gglobs.configsize     = 512

            else:                               # auto
                gglobs.configsize = 'auto'

            dprint(gglobs.debug, infostr.format("configsize", gglobs.configsize))
        except:
            dprint(True, "WARNING: Config configsize not available")

        # Device calibration
        try:
            t = config.get("Device", "calibration")
            if t.upper() == 'AUTO':
                pass  # default in gglobs is 0.0065

            else:
                if float(t) > 0:
                    gglobs.calibration      = float(t)
                else:
                    pass  # default in gglobs is 0.0065

            dprint(gglobs.debug, infostr.format("Calibration", gglobs.calibration))
        except:
            dprint(True, "WARNING: Config calibration not available")

        # Device voltagebytes
        try:
            t = config.get("Device", "voltagebytes")
            if t.upper() == '256':
                gglobs.voltagebytes     = 256

            elif t.upper() == '512':
                gglobs.voltagebytes     = 512

            else:                               # auto
                gglobs.voltagebytes = 'auto'

            dprint(gglobs.debug, infostr.format("voltagebytes", gglobs.voltagebytes))
        except:
            dprint(True, "WARNING: Config voltagebytes not available")

        # Device endianness
        try:
            t = config.get("Device", "endianness")
            if t.upper() == 'LITTLE':
                gglobs.endianness     = 'little'
                #gglobs.memoryMode = 'fixed'

            elif t.upper() == 'BIG':
                gglobs.endianness     = 'big'
                #gglobs.memoryMode = 'fixed'

            else:                               # auto
                gglobs.endianness = 'auto'

            dprint(gglobs.debug, infostr.format("endianness", gglobs.endianness))
        except:
            dprint(True, "WARNING: Config endianness not available")


    # Folder data
        errmsg = "glaub ich nicht"
        try:
            t = config.get("Folder", "data")
            #print "gglobs.dataPath:", gglobs.dataPath
            #print "t:", t
            if t == "":
                pass    # no change to default
            else:
                if os.path.isabs(t):  # is absolute path?
                    testpath = t
                else:
                    testpath = gglobs.dataPath + "/" + t

                #
                # Make sure that data directory exists; create it if needed
                # ignore if it cannot be made or is not writable
                #
                if os.access(testpath , os.F_OK):
                    # dir exists, ok
                    if not os.access(testpath , os.W_OK):
                        # dir exists, but is not writable
                        errmsg = "Configured data directory '{}' exists, but is not writable".format(testpath)
                        raise NameError
                    else:
                        # dir exists and is writable
                        gglobs.dataPath = testpath
                else:
                    # dir does not exist; make it
                    try:
                        os.mkdir(testpath)
                        gglobs.dataPath = testpath
                    except:
                        # dir cannot be made
                        errmsg = "Could not make configured data directory '{}'".format(testpath)
                        raise NameError

            dprint(gglobs.debug, infostr.format("Data directory", gglobs.dataPath))
        except:
            dprint(True, "WARNING: " + errmsg)

    # Logging
        try:
            t = config.getfloat("Logging", "logcycle")
            if t >= 0.1:
                gglobs.logcycle = t
            dprint(gglobs.debug, infostr.format("Logcycle (sec)", gglobs.logcycle))
        except:
            dprint(True, "WARNING: Config logcycle not available")

    # Graphic
        try:
            t = config.getfloat("Graphic", "mav_initial")
            if t >= 1:
                gglobs.mav_initial = t
            dprint(gglobs.debug, infostr.format("Moving Average (sec)", gglobs.mav_initial))
        except:
            dprint(True, "WARNING: Config mav_initial not available")

    # Plotstyle
        try:
            g1 = config.get("Plotstyle", "linestyle")
            g2 = config.get("Plotstyle", "linecolor")
            g3 = config.get("Plotstyle", "linewidth")
            g4 = config.get("Plotstyle", "markerstyle")
            g5 = config.get("Plotstyle", "markersize")
            gglobs.linestyle           = g1
            gglobs.linecolor           = g2
            gglobs.linewidth           = g3
            gglobs.markerstyle         = g4
            gglobs.markersize          = g5

        except:
            dprint(True, "WARNING: Could not recognize all plot style settings")

    # Window
        try:
            w = config.getint("Window", "width")
            h = config.getint("Window", "height")
            if w > 500 and w < 5000 and h > 100 and h < 5000:
                gglobs.window_width  = w
                gglobs.window_height = h
                dprint(gglobs.debug, infostr.format("Window dimensions", "{} x {} pixel".format(gglobs.window_width, gglobs.window_height)))
            else:
                dprint(True, "WARNING: Config Window dimension out-of-bound; ignored: {} x {} pixel".format(gglobs.window_width, gglobs.window_height))
        except:
            dprint(True, "WARNING: Config Window dimension not available")

    # Window size
        try:
            t = config.get("Window", "size")
            if t.upper() == 'MAXIMIZED':
                gglobs.window_size = 'maximized'
            else:
                gglobs.window_size = None
            dprint(gglobs.debug, infostr.format("Window Size", t))
        except:
            dprint(True, "WARNING: Window size not available")
        """
    # Manual
        try:
            fn = config.get("Manual", "manual_name")
            if fn.upper() != 'AUTO' and fn > '':
                manual_file = getProgPath() + "/" + fn
                #print "readGeigerConfig manual_file:", manual_file
                if os.path.isfile(manual_file): # does the config file exist?
                    # it exists
                    gglobs.manual_filename = fn
                    dprint(gglobs.debug, "INFO: Manual file is: '{}'".format( fn))
                else:
                    # it does not exist
                    gglobs.manual_filename = None
                    dprint(gglobs.debug, "WARNING: Manual file '{}' does not exist".format(fn))
            else:   # entry == auto or no entry
                gglobs.manual_filename = None
                dprint(gglobs.debug, "INFO: Manual file is set to auto or is undefined; it will be searched for")
        except:
            dprint(True, "WARNING: Config for manual file not available")
        """
    # Manual
        try:
            t = config.get("Manual", "manual_name")
            if t.upper() == 'AUTO' or t == "":
                gglobs.manual_filename = 'auto'
                dprint(gglobs.debug, infostr.format("Manual file", gglobs.manual_filename))
            else:
                manual_file = getProgPath() + "/" + t
                #print "readGeigerConfig manual_file:", manual_file
                if os.path.isfile(manual_file): # does the config file exist?
                    # it exists
                    gglobs.manual_filename = t
                    dprint(gglobs.debug, infostr.format("Manual file",t))
                else:
                    # it does not exist
                    gglobs.manual_filename = 'auto'
                    dprint(gglobs.debug, "WARNING: Manual file '{}' does not exist".format(t))
        except:
            dprint(True, "WARNING: Config for manual file not available")


    # Radiation World Maps
        try:
            t = config.get("Worldmaps", "GMCmapURL")
            gglobs.GMCmapURL = t
            dprint(gglobs.debug, infostr.format("Worldmaps GMCmapURL", t ))
        except:
            gglobs.GMCmapURL = ""
            dprint(True, "WARNING: Config for Worldmaps GMCmapURL not available")

        try:
            t = config.get("Worldmaps", "UserID")
            gglobs.UserID = t
            dprint(gglobs.debug, infostr.format("Worldmaps UserID", t ))
        except:
            gglobs.UserID = ""
            dprint(True, "WARNING: Config for Worldmaps UserID not available")

        try:
            t = config.get("Worldmaps", "CounterID")
            gglobs.CounterID = t
            dprint(gglobs.debug, infostr.format("Worldmaps CounterID", t ))
        except:
            gglobs.CounterID = ""
            dprint(True, "WARNING: Config for Worldmaps CounterID not available")

    # Style
        #try:
        #    t = config.get("Style", "style")
        #    s = [a.upper() for a in ('Breeze',  "Cleanlooks", "Windows", "Plastique")]
        #    if t.upper() in s :
        #        gglobs.style = t
        #    else:
        #        gglobs.style = None
        #except:
        #    dprint(True, "Config style not available")

        break

    debugIndent(0)


def strFontInfo(origin, fi):
    """formats font information, returns string"""

    fontinfo = "Family:{}, fixed:{}, size:{}, style:{}, styleHint:{}, styleName:{}, weight:{}"\
    .format(fi.family(), fi.fixedPitch(), fi.pointSize(), fi.style(), fi.styleHint(), fi.styleName(), fi.weight())

    return fontinfo


def version_status():
    """returns versions as list of various components"""

    gglobs.python_version = sys.version.replace('\n', "")

    #https://wiki.python.org/moin/PyQt/Getting%20the%20version%20numbers%20of%20Qt%2C%20SIP%20and%20PyQt
    from PyQt4.QtCore   import QT_VERSION_STR
    from PyQt4.Qt       import PYQT_VERSION_STR
    from sip            import SIP_VERSION_STR

# scipy
    try:
        import scipy
        scipy_version = scipy.__version__
    except:
        scipy_version = "module not available"

# serial
    serial_version = "Version not available, see log for details" # to be replaced
    try:
        serial_version = serial.__version__
    except:
        dprint(True, "ERROR in serial.__version__:" + str(sys.exc_info()))
        try:
            serial_version = serial.VERSION
        except:
            dprint(True, "ERROR in serial.VERSION :" + str(sys.exc_info()))

    version_status = []
    version_status.append(["GeigerLog",    "{}".format(gglobs.__version__)])
    version_status.append(["Python",       "{}".format(gglobs.python_version)])
    version_status.append(["matplotlib",   "{}".format(mplVersion)])
    version_status.append(["numpy",        "{}".format(np.version.version)])
    version_status.append(["Qt version",   "{}".format(QT_VERSION_STR)])
    version_status.append(["SIP version",  "{}".format(SIP_VERSION_STR)])
    version_status.append(["PyQt version", "{}".format(PYQT_VERSION_STR)])
    version_status.append(["pyserial",     "{}".format(serial_version)])
    version_status.append(["scipy",        "{}".format(scipy_version)])

    return version_status


def main():
    global usage, app, media, mediaErr, styles

    # set directories and file names
    gglobs.progName     = getProgName()
    gglobs.progPath     = getProgPath()
    gglobs.gresPath     = getGresPath()
    gglobs.dataPath     = getDataPath()
    gglobs.proglogPath  = getProglogPath()
    gglobs.stdlogPath     = getStdlogPath()
    gglobs.configPath   = getConfigPath()
    gglobs.fileDialogDir= gglobs.dataPath

    #
    # Make sure that data directory exists; create it if needed
    # exit if it cannot be made or is not writable
    #
    if os.access(gglobs.dataPath , os.F_OK):
        # dir exists, ok
        if not os.access(gglobs.dataPath , os.W_OK):
            # dir exists, but is not writable
            print("ERROR: main: Data directory '{}' exists, but is not writable".format(gglobs.dataDirectory))
            return 1
    else:
        # dir does not exist; make it
        try:
            os.mkdir(gglobs.dataPath )
        except:
            # dir cannot be made
            print("ERROR: main: Could not make data directory '{}'".format(gglobs.dataDirectory))
            return 1

    #
    # parse command line options
    # sys.argv[0] is progname
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hdvRVp:b:s:", ["help", "debug", "verbose", "Redirect", "Version", "port=", "baudrate=", "style="])
    except getopt.GetoptError as errmessage :
        # print info like "option -a not recognized", then continue
        dprint(True, "ERROR: '{}', use './geigerlog -h' for help".format(errmessage) )
        return 1

    # processing the options
    for opt, optval in opts:
        if opt in ("-h", "--help"):
            print(usage)
            return

        elif opt in ("-d", "--debug"):
            gglobs.debug = True

        elif opt in ("-v", "--verbose"):
            gglobs.verbose = True

        elif opt in ("-R", "--Redirect"):
            gglobs.redirect = True

        elif opt in ("-V", "--Version"):
            print("Version status:")
            for a in version_status():
                print("   {:13s}: {}".format(a[0], a[1]))
            return

    # processing the args
    for arg in args:
        if arg == "showstyles":
            print("Styles found on system: ")
            for a in list(QtGui.QStyleFactory.keys()): print("   " + a)
            print("See configuration file geigerlog.cfg, section [Style] for details")
            return

        if arg == "keepFF":
            gglobs.keepFF   = True

        if arg == "devel":
            gglobs.devel    = True

        if arg == "fullhist":
            gglobs.fullhist = True

        if arg == "testing":
            gglobs.testing = True

        if arg == "test1":
            gglobs.test1 = True

        if arg == "test2":
            gglobs.test2 = True

        if arg == "test3":
            gglobs.test3 = True

        if arg == "test4":
            gglobs.test4 = True


    clearProgramLogFile() #clear and initialize the program log file 'geigerlog.proglog'

    dprint(gglobs.debug, "Startup:    sys.argv: {}".format(sys.argv))
    dprint(gglobs.debug, "Recognized: options:  {}, commands:{}".format(opts, args))
    dprint(gglobs.debug, "Operating System: {}".format(platform.platform()))
    dprint(gglobs.debug, "Machine: {}, {}".format(platform.machine(), platform.architecture()[0]))
    vs = ""
    for a in version_status(): vs += "{}: {},  ".format(a[0], a[1])
    dprint(True, "Version status:", vs)

    vprint(gglobs.verbose, "progName:     " + gglobs.progName)
    vprint(gglobs.verbose, "progPath:     " + gglobs.progPath)
    vprint(gglobs.verbose, "dataPath:     " + gglobs.dataPath)
    vprint(gglobs.verbose, "gresPath:     " + gglobs.gresPath)
    vprint(gglobs.verbose, "proglogPath:  " + gglobs.proglogPath)
    vprint(gglobs.verbose, "configPath:   " + gglobs.configPath)

    # backend info
    vprint(gglobs.verbose, "matplotlib backend: ", matplotlib.get_backend())

    """
    Phonon:
    Phonon searches the backend in a certain place!
    The backend needs to be in the subdirectory "/phonon_backend/" of the qt library paths
    (find out with: QCoreApplication::libraryPaths();)
    so my solution was to put the backend-files from the "qt/plugins/phonon_backend/"-folder into
    the folder in which I executed the programm - but in the subdirectory "/phonon_backend/"
    NOTE: did not work!
    """
    if len(QtCore.QCoreApplication.libraryPaths()) == 0:
        vprint(gglobs.verbose, "QCoreApplication.libraryPaths(): ", "No Library Paths")
    else:
        for a in QtCore.QCoreApplication.libraryPaths():
            vprint(gglobs.verbose, "QCoreApplication.libraryPaths(): ", a)

    #
    # Styles:
    #
    # QStyleFactory::keys() returns a list of valid keys, typically including
    # "Windows", "Motif", "CDE", "MotifPlus", "Platinum", "SGI" and "Compact".
    # Depending on the platform, "WindowsXP", "Aqua" or "Macintosh" may be available.
    #
    # Returns here: Breeze, Windows, Motif, CDE, Plastique, GTK+, Cleanlooks
    # best is 1)Breeze, 2)Cleanlooks, 3) Plastique, ... 6)Windows, 7)GTK+
    #
    # app.style().metaObject().className() :  returns Style codings:
    #   Breeze            =Breeze::Style,
    #   Cleanlooks        =QCleanlooksStyle,
    #   Plastique         =QPlastiqueStyle
    #   CDE               =QCDEStyle,
    #   Motif             =QMotifStyle,
    #   Windows           =QWindowsStyle,
    #   GTK+              =QGtkStyle

    # order of my preference; first is best
    styles_rank = ['Breeze', 'Cleanlooks', 'Plastique', 'Windows', 'CDE', 'Motif', 'GTK+' ]

    styles = []
    for a in list(QtGui.QStyleFactory.keys()): styles.append(str(a))
    vprint(gglobs.verbose, "Style: found on system: ", styles)

    # Start the GUI
    app = QtGui.QApplication(sys.argv)
    # This makes the program name 'geigerlog' to the application name
    #print "get Application Name:", app.applicationName()
    # setting to desired name
    app.setApplicationName("GeigerLog")
    #print "get Application Name:", app.applicationName()

    # sets the style
    if gglobs.style != None:
        # either defined in config or on command line
        # if both then command line takes precedence
        #print "setting gglobs.style", gglobs.style
        #QtGui.QApplication.setStyle(gglobs.style)
        #app.setStyle(gglobs.style)
        pass
    else:
        for s in styles_rank:       # Default if neither command line nor config
            if s in styles:         # test on availability in order of preference
                #print s
                #QtGui.QApplication.setStyle(s)
                #app.setStyle(s)
                pass
                break

    gglobs.style = app.style().metaObject().className()
    vprint(gglobs.verbose, "Style: active:", gglobs.style)

    # allows copy&Paste also on Win, but makes all Messageboxes as HTML coding
    # cumbersome with using tabs
    #app.setStyleSheet("QMessageBox { messagebox-text-interaction-flags: 5; }")

    # sound file for message
    media = Phonon.MediaObject()
    # Next line results in this message, but seems to be a bug in KDE:
    #   klauncher(3545) kdemain: No DBUS session-bus found.
    #   Check if you have started the DBUS server.
    #   kdeinit4: Communication error with launcher. Exiting!
    audio = Phonon.AudioOutput(Phonon.MusicCategory)
    Phonon.createPath(media, audio)
    # the file could be set elsewhere,
    # but currently only one is needed, so ok to do it here
    #f = os.path.join(gglobs.gresPath, "sonar.ogg")
    f = os.path.join(gglobs.gresPath, "bell.oga")
    media.setCurrentSource(Phonon.MediaSource(f))

    # sound file for Error message
    mediaErr = Phonon.MediaObject()
   # audio = Phonon.AudioOutput(Phonon.MusicCategory) # needed a 2nd time?
    audio2 = Phonon.AudioOutput(Phonon.MusicCategory) # needed a 2nd time?Yes!
    Phonon.createPath(mediaErr, audio2)
    f = os.path.join(gglobs.gresPath, "bell.ogg")
    mediaErr.setCurrentSource(Phonon.MediaSource(f))

    gglobs.media    = media
    gglobs.mediaErr = mediaErr

    # The configuration file may override some default options in gglobs.py
    readGeigerConfig()                       # reads the configuration file

    # command line options may override config options, so must be
    # processed AFTER reading the configuation file!
    # now processing the remaining options; will overwrite any previous setting
    for opt, optval in opts:
        if opt in ("-p", "--port"):
            gglobs.usbport = optval
            dprint(gglobs.debug, "Command line setting for: Port: '{}', overriding GeigerConfig".format(gglobs.usbport))

        elif opt in ("-b", "--baudrate"):
            gglobs.baudrate = optval
            dprint(gglobs.debug, "Command line setting for: Baudrate: '{}', overriding GeigerConfig".format(gglobs.baudrate))

        elif opt in ("-s", "--style"):
            gglobs.style = optval
            dprint(gglobs.debug, "Command line setting for: Style: '{}', overriding GeigerConfig".format(gglobs.style))

    # now starting the GUI
    dprint(gglobs.debug, "Starting the GUI.")
    ex = ggeiger()
    status = app.exec_()
    # just exited the GUI
    #app.closeAllWindows()
    dprint(gglobs.debug, "Exited 'app.exec_()' with status of:", status)

    ## switching off the heartbeat function of the counter
    ## deemed unnecessary
    #if gglobs.ser != None:
    #    rec = gcommands.turnHeartbeatOFF()
    #else:
    #    dprint(gglobs.debug, "Exiting - No serial connection available")

    sys.exit(status)


if __name__ == '__main__':

    msg = """
        This version of GeigerLog requires Python 3!
        Your Python version is: {}

        The preferred way is to upgrade to Python 3. If you can't do that, you can
        download a copy of GeigerLog, which runs on Python 2 from:

        https://sourceforge.net/projects/geigerlog/

        The last version of GeigerLog for Python 2 is GeigerLog 0.9.06. Future
        versions will all be for Python 3.
        """.format(sys.version[:7])

    if sys.version_info[0] < 3:
        bell()
        print (msg)
    else:
        main()
