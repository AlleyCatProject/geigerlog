#! /usr/bin/python3
# -*- coding: utf-8 -*-

"""
GeigerLog - A program with a Graphical User Interface to handle Geiger counters
as well as environmental sensors for Temperature, Pressure, Humidity, and else

Start as 'geigerlog -h' for help on available options and commands
Use GeigerLog-Manual-v<version number>.pdf for further details
"""

###############################################################################
#    This file is part of GeigerLog.
#
#    GeigerLog is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    GeigerLog is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with GeigerLog.  If not, see <http://www.gnu.org/licenses/>.
###############################################################################


__author__          = "ullix"
__copyright__       = "Copyright 2016, 2017, 2018"
__credits__         = [""]
__license__         = "GPL3"


import sys                      # system functions


# testing for Python version; v3 required
# must be up here as some imports are not possible on Py2!
msg = """
    This version of GeigerLog requires Python 3!
    Your Python version is: {}

    The preferred way is to upgrade to Python 3. If you can't do that, you can
    download a copy of GeigerLog, which runs on Python 2 from:

    https://sourceforge.net/projects/geigerlog/

    The last version of GeigerLog for Python 2 is GeigerLog 0.9.06. Future
    versions will all be for Python 3.
    """.format(sys.version[:7])

if sys.version_info[0] < 3:
        print("\7")
        print (msg)
        sys.exit(1)


import os                       # os functions
import platform                 # OS, machine, architecture, ...
import re                       # regex
import getopt                   # parse command line for options and commands
import serial                   # interface to USB-to-serial
import urllib.request           # for use with Radiation World Map
import urllib.parse             # for use with Radiation World Map
import copy                     # make copies of bytes
import random                   # for FFT data
import signal                   # handling signals like CTRL-C and other
import subprocess               # to allow terminal commands tput rmam / tput smam
                                # and openurl commands


from PyQt4 import QtGui, QtCore

import matplotlib
matplotlib.use('Qt4Agg', warn=True, force=False) # use Qt4Agg, not the default TkAgg
import matplotlib.backends.backend_qt4agg # MUST be done BEFORE importing pyplot!

from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QT as NavigationToolbar

import matplotlib.pyplot as plt # MUST import AFTER 'matplotlib.use()' / matplotlib-backend!!!
import matplotlib.dates  as mpld

import numpy as np
import scipy.signal             # a subpackage of scipy; needs separate import
import scipy.stats              # a subpackage of scipy; needs separate import

import gglobs
import gcommands
import ghist
import gplot
import gradmon
from   gutils   import *

class ggeiger(QtGui.QMainWindow):

    def __init__(self):
        super(ggeiger, self).__init__()

        gglobs.ex = self

        #self.setStyleSheet("color: black;") # all colors; black is too black

# font standard
        self.fontstd = QtGui.QFont()
        self.fontstd.setFamily('Monospace')
        #self.fontstd.setFamily('Lucida')
        #self.fontstd.StyleHint(QtGui.QFont.TypeWriter)
        #self.fontstd.StyleHint(QtGui.QFont.Monospace)
        #self.fontstd.StyleHint(QtGui.QFont.Courier)
        self.fontstd.setFixedPitch(True)
        self.fontstd.setPointSize(10)
        self.fontstd.setBold(False)
        #self.fontstd.setWeight(50)
        #self.fontstd.setStyleStrategy(QtGui.QFont.PreferMatch)
        #self.fontstd.Weight(QtGui.QFont.Normal)
        #self.fontstd.Weight(QtGui.QFont.DemiBold)
        #self.fontstd.Weight(QtGui.QFont.Bold)
        self.fontstd.Weight(QtGui.QFont.Black)

# window
        screen_available = QtGui.QDesktopWidget().availableGeometry()

        #print "screen Geometry:", QtGui.QDesktopWidget().screenGeometry() # total hardware screen
        #print "screen_available", screen_available, screen_available.x(), screen_available.y(), "width:", screen_available.width(), "height:", screen_available.height()

        sw = min(gglobs.window_width  -  2, screen_available.width() ) # Frame of 1 pixel left and right
        sh = min(gglobs.window_height - 29, screen_available.height()) # Frame top + bottom + Window bar of 29 pixel
        x  = max(screen_available.width() - sw, 0)                     # should be >0 anyway
        #y  = 0
        y  = screen_available.y()
        if "WINDOWS" in platform.platform().upper(): y += 33           # some correction needed at least on Virtual Win8.1
        self.setGeometry(x, y, sw, sh) # position window in upper right corner of screen
        self.setWindowTitle('GeigerLog v' + gglobs.__version__)
        self.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))

#figure and its toolbar
        # a figure instance to plot on
        #self.figure = plt.figure(facecolor = "#F9F4C9", edgecolor='lightgray', linewidth = 0.0) # light yellow face
        #self.figure, self.ax1 = plt.subplots(figsize=(6, 9), dpi=90, facecolor='#DFDEDD')
        #self.figure, self.ax1 = plt.subplots(figsize=(16, 1), facecolor='#DFDEDD') # figsize has no impact
        self.figure, self.ax1 = plt.subplots(facecolor='#DFDEDD') # lighter gray
        plt.clf()  # must be done - clear figure or it will show an empty figure !!

        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        self.canvas = FigureCanvas(self.figure)
        self.canvas.mpl_connect('motion_notify_event', self.updatecursorposition) # where the cursor is
        self.canvas.mpl_connect('button_press_event' , self.onclick)              # send a mouse click
        #self.canvas.setFixedSize(700,450) # does not increase when maximizing window

        # this is the figure Navigation widget; it takes the Canvas widget and a parent
        self.navtoolbar = NavigationToolbar(self.canvas, self)
        self.navtoolbar.setToolTip("Graph Toolbar")
        self.navtoolbar.setIconSize(QtCore.QSize(32,32))

#menubar and statusbar and toolbar
        menubar = self.menuBar()
        menubar.setFocus()
        #dprint(gglobs.debug, "Fonts: menubar -", strFontInfo("", menubar.fontInfo()))

        self.statusBar = QtGui.QStatusBar()
        self.setStatusBar(self.statusBar)
        self.statusBar.setFont(QtGui.QFont("Helvetica", 12))

        toolbar = self.addToolBar('Main')
        toolbar.setToolTip("Main Toolbar")
        toolbar.setOrientation(QtCore.Qt.Horizontal) # is default; alt: Qt.Vertical
        toolbar.setIconSize(QtCore.QSize(32,32))  # standard size is too small
        #print "toolbar.iconSize()", toolbar.iconSize()

#file menu
        PlotLogAction = QtGui.QAction('Plot Log', self)
        PlotLogAction.setStatusTip('Plot the Log file')
        PlotLogAction.triggered.connect(lambda: self.plotGraph('Log'))

        PlotHisAction = QtGui.QAction('Plot History', self)
        PlotHisAction.setStatusTip('Plot the History file')
        PlotHisAction.triggered.connect(lambda: self.plotGraph('His'))

        PrintSuStAction =  QtGui.QAction('Show Summary Statistics (SuSt)', self)
        PrintSuStAction.setStatusTip("Shows Summary Statistics of all variables and data in the plot")
        PrintSuStAction.triggered.connect(lambda: self.printSuSt())

        PrintStatsAction =  QtGui.QAction('Show Statistics', self)
        PrintStatsAction.setStatusTip("Shows the Statistics of the selected variable plot")
        PrintStatsAction.triggered.connect(lambda: self.printStats())

        PlotPoissonAction =  QtGui.QAction("Show Poisson Test", self)
        PlotPoissonAction.setStatusTip("Shows a Poisson curve on a histogram of the data of the selected variable")
        PlotPoissonAction.triggered.connect(lambda: self.plotPoisson())

        PlotFFTAction =  QtGui.QAction("Show FFT && Autocorrelation", self)
        PlotFFTAction.setStatusTip("Shows the FFT Spectra & an Autocorrelation of the data of the selected variable")
        PlotFFTAction.triggered.connect(lambda: self.plotFFT())

        exitAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_exit.png'))), 'Exit', self)
        exitAction.setShortcut('Ctrl+Q')
        exitAction.setStatusTip('Exit the GeigerLog program')
        exitAction.setToolTip('Exit the GeigerLog program')
        exitAction.triggered.connect(self.close)

        fileMenu = menubar.addMenu('&File')
        fileMenu.addAction(PlotLogAction)
        fileMenu.addAction(PlotHisAction)
        fileMenu.addAction(PrintSuStAction)
        fileMenu.addAction(PrintStatsAction)
        fileMenu.addAction(PlotPoissonAction)
        fileMenu.addAction(PlotFFTAction)
        fileMenu.addAction(exitAction)
        #fileMenu.triggered[QtGui.QAction].connect(self.processtrigger)

        toolbar.addAction(exitAction)

# Device menu
        self.toggleDeviceConnectionAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_open.png'))), 'Connect / Disconnect Devices', self)
        self.toggleDeviceConnectionAction.setStatusTip('Toggle connection of the computer with the devices')
        #self.toggleDeviceConnectionAction.setToolTip('Toggle connection of the computer with the devices')
        self.toggleDeviceConnectionAction.triggered.connect(self.toggleDeviceConnection)

        self.DeviceConnectAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_open.png'))), 'Connect Devices', self)
        self.DeviceConnectAction.setShortcut('Ctrl+C')
        self.DeviceConnectAction.setStatusTip('Connect the computer to the devices')
        self.DeviceConnectAction.triggered.connect(lambda : self.switchConnections("ON"))

        self.DeviceDisconnectAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_closed.png'))), 'Disconnect Devices', self, enabled = False)
        self.DeviceDisconnectAction.setShortcut('Ctrl+D')
        self.DeviceDisconnectAction.setStatusTip('Disconnect the computer from the devices')
        self.DeviceDisconnectAction.triggered.connect(lambda : self.switchConnections("OFF"))

        self.DevicePowerToggle = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power2_off.png'))), 'Switch Device Power', self, enabled=False)
        self.DevicePowerToggle.setToolTip('Toggle GMC Device Power ON / OFF')
        self.DevicePowerToggle.triggered.connect(self.toggleDevicePower)

    # submenu GMC

        self.GMCInfoAction = QtGui.QAction('Show Info', self, enabled=True)
        self.GMCInfoAction.setStatusTip('Show info on GMC device')
        self.GMCInfoAction.triggered.connect(self.printGMCDevInfo)

        self.DeviceInfoAction = QtGui.QAction('Show Extended Info', self, enabled=False)
        self.DeviceInfoAction.setStatusTip('Show extended info on GMC device')
        self.DeviceInfoAction.triggered.connect(self.printGMCDevInfoExtended)

        self.DeviceConfigAction = QtGui.QAction('Show Configuration Memory', self, enabled=False)
        self.DeviceConfigAction.setStatusTip('Show the GMC device configuration memory as binary in human readable format')
        self.DeviceConfigAction.triggered.connect(self.printDevConfig)

        self.DeviceONAction = QtGui.QAction('Switch Power ON', self, enabled=False)
        self.DeviceONAction.setStatusTip('Switch the GMC device power to ON')
        self.DeviceONAction.triggered.connect(lambda: self.switchDevicePower("ON"))

        self.DeviceOFFAction = QtGui.QAction('Switch Power OFF', self, enabled=False)
        self.DeviceOFFAction.setStatusTip('Switch the GMC device power to OFF')
        self.DeviceOFFAction.triggered.connect(lambda: self.switchDevicePower("OFF"))

        self.DeviceAlarmONAction = QtGui.QAction('Switch Alarm ON', self, enabled=False)
        self.DeviceAlarmONAction.setStatusTip('Switch the GMC device alarm ON')
        self.DeviceAlarmONAction.triggered.connect(lambda: self.switchDeviceAlarm("ON"))

        self.DeviceAlarmOFFAction = QtGui.QAction('Switch Alarm OFF', self, enabled=False)
        self.DeviceAlarmOFFAction.setStatusTip('Switch the GMC device alarm OFF')
        self.DeviceAlarmOFFAction.triggered.connect(lambda: self.switchDeviceAlarm("OFF"))

        self.DeviceSpeakerONAction = QtGui.QAction('Switch Speaker ON', self, enabled=False)
        self.DeviceSpeakerONAction.setStatusTip('Switch the GMC device speaker ON')
        self.DeviceSpeakerONAction.triggered.connect(lambda: self.switchDeviceSpeaker("ON"))

        self.DeviceSpeakerOFFAction = QtGui.QAction('Switch Speaker OFF', self, enabled=False)
        self.DeviceSpeakerOFFAction.setStatusTip('Switch the GMC device speaker OFF')
        self.DeviceSpeakerOFFAction.triggered.connect(lambda: self.switchDeviceSpeaker("OFF"))

        self.DeviceSavingStateAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, ''))), 'Set History Saving Mode', self, enabled=False)
        self.DeviceSavingStateAction.setStatusTip('Set History Saving Mode of GMC device to OFF, CPS, CPM, and CPM hourly average')
        self.DeviceSavingStateAction.triggered.connect(self.setHistSaveMode)

        self.DeviceSetTimeAction = QtGui.QAction('Set Date+Time', self, enabled=False)
        self.DeviceSetTimeAction.setStatusTip('Set the Date + Time of the GMC device to the computer time')
        self.DeviceSetTimeAction.triggered.connect(self.deviceSetDateTime)

        self.DeviceREBOOTAction = QtGui.QAction('Reboot', self, enabled=False)
        self.DeviceREBOOTAction.setStatusTip('Send REBOOT command to the GMC device')
        self.DeviceREBOOTAction.triggered.connect(self.doREBOOT)

        self.DeviceFACTORYRESETAction = QtGui.QAction('FACTORYRESET', self, enabled=False)
        self.DeviceFACTORYRESETAction.setStatusTip('Send FACTORYRESET command to the GMC device')
        self.DeviceFACTORYRESETAction.triggered.connect(self.doFACTORYRESET)

    # submenu RadMon
        self.RMInfoAction = QtGui.QAction('Show Info', self, enabled=True)
        self.RMInfoAction.setStatusTip('Show general info on RadMon device')
        self.RMInfoAction.triggered.connect(self.printRMDevInfo)

        # build the Device menu
        deviceMenu = menubar.addMenu('&Device')

    # valid for all devices
        deviceMenu.addAction(self.DeviceConnectAction)
        deviceMenu.addAction(self.DeviceDisconnectAction)

    # valid for GMC only
        deviceSubMenuGMC = deviceMenu.addMenu("GMC Series")
        deviceSubMenuGMC.addAction(self.GMCInfoAction)
        deviceSubMenuGMC.addAction(self.DeviceInfoAction)
        deviceSubMenuGMC.addAction(self.DeviceConfigAction)
        deviceSubMenuGMC.addAction(self.DeviceONAction)
        deviceSubMenuGMC.addAction(self.DeviceOFFAction)
        deviceSubMenuGMC.addAction(self.DeviceAlarmONAction)
        deviceSubMenuGMC.addAction(self.DeviceAlarmOFFAction)
        deviceSubMenuGMC.addAction(self.DeviceSpeakerONAction)
        deviceSubMenuGMC.addAction(self.DeviceSpeakerOFFAction)
        deviceSubMenuGMC.addAction(self.DeviceSavingStateAction)
        deviceSubMenuGMC.addAction(self.DeviceSetTimeAction)
        deviceSubMenuGMC.addAction(self.DeviceREBOOTAction)
        deviceSubMenuGMC.addAction(self.DeviceFACTORYRESETAction)
        #deviceMenu.triggered[QtGui.QAction].connect(self.processtrigger)

    # valid for RadMon only
        deviceSubMenuRM  = deviceMenu.addMenu("RadMon Series")
        deviceSubMenuRM.addAction(self.RMInfoAction)

    # widgets for device in toolbar
        self.connectTextGMC = 'GMC Series'
        self.dbtnDeviceConnect =  QtGui.QPushButton(self.connectTextGMC)
        self.dbtnDeviceConnect.setFixedSize(110,32)
        self.dbtnDeviceConnect.setToolTip ("Shows the type of GMC device connected once connection is made - click for a brief info report")
        self.dbtnDeviceConnect.setStyleSheet("QPushButton: {background-color: #12cc3d; border-radius: 2px; border:1px solid silver; color: black; font-size:14px; font-weight:bold}") # so geht's
        self.dbtnDeviceConnect.setAutoFillBackground(True) # This is important!! Why???
        self.dbtnDeviceConnect.clicked.connect(lambda: self.printGMCDevInfo())

        self.connectTextRM = 'RadMon Series'
        self.dbtnRMplus =  QtGui.QPushButton(self.connectTextRM)
        self.dbtnRMplus.setFixedSize(110,32)
        self.dbtnRMplus.setToolTip ("Shows the type of RadMon device connected once connection is made - click for a brief info report")
        self.dbtnRMplus.setStyleSheet("QPushButton: {background-color: #12cc3d;border-radius: 2px; border:1px solid silver; color: black; font-size:14px; font-weight:bold}") # so geht's
        self.dbtnRMplus.setAutoFillBackground(True) # 'This is important!!'  Why???
        self.dbtnRMplus.clicked.connect(lambda: self.printRMDevInfo())

    # toolbar Devices
        toolbar = self.addToolBar('Devices')
        toolbar.setToolTip("Devices Toolbar")
        toolbar.setIconSize(QtCore.QSize(32,32))    # standard size is too small

        toolbar.addAction(self.DevicePowerToggle)   # GMC power icon
        toolbar.addWidget(self.dbtnDeviceConnect)   # GMC device display
        toolbar.addAction(self.toggleDeviceConnectionAction) # Connect icon
        toolbar.addWidget(self.dbtnRMplus)          # RadMon device display


#Log Menu
        self.logLoadFileAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_log_get.png'))), 'Get Log File or Create New One', self)
        self.logLoadFileAction.setShortcut('Ctrl+F')
        self.logLoadFileAction.setStatusTip('Load file for logging or create new one. Plot data if there are any in the loaded file')
        self.logLoadFileAction.triggered.connect(self.getLogFile)

        self.startloggingAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_log_start.png'))), 'Start Logging', self, enabled=False)
        self.startloggingAction.setShortcut('Ctrl+L')
        self.startloggingAction.setStatusTip('Start logging from devices. Requires: 1) Connection, 2) Device is powered, 3) Log file is loaded')
        self.startloggingAction.triggered.connect(self.startTimer)

        self.stoploggingAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_log_stop.png'))), 'Stop Logging', self, enabled=False)
        self.stoploggingAction.setShortcut('Ctrl+S')
        self.stoploggingAction.setStatusTip('Stop logging from device')
        self.stoploggingAction.triggered.connect(self.stopTimer)

        self.addCommentAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, ''))), 'Add Comment to Log', self, enabled=False)
        self.addCommentAction.setShortcut('Ctrl+A')
        self.addCommentAction.setStatusTip('Add a comment to the current log file')
        self.addCommentAction.triggered.connect(self.addComment)

        self.showLogDataAction = QtGui.QAction('Show Log Data', self)
        self.showLogDataAction.setStatusTip('Show all log data from current log file')
        self.showLogDataAction.triggered.connect(lambda: self.printData2NotePad("Log"))

        self.quickLogAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_quick_log.png'))), 'Quick Log', self, enabled=False)
        self.quickLogAction.setShortcut('Ctrl+K')
        self.quickLogAction.setStatusTip('One-click log. Saves always into file default.log; will be overwritten on next Quick Log click')
        self.quickLogAction.triggered.connect(self.quickLog)

        self.showLogTagsAction = QtGui.QAction('Show Log Comments', self)
        self.showLogTagsAction.setStatusTip('Show only lines from log containing comments')
        self.showLogTagsAction.triggered.connect(self.showLogTags)

        self.showLogExcerptAction = QtGui.QAction('Show Log Data Excerpt', self)
        self.showLogExcerptAction.setStatusTip('Show first and last few lines of current log file')
        self.showLogExcerptAction.triggered.connect(self.showLogDataExcerpt)

        self.logSnapAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_log_snap.png'))), 'Snap a new log record', self, enabled=False)
        self.logSnapAction.setStatusTip('Get a new log record immediately')
        self.logSnapAction.triggered.connect(self.getManualLogValue)

        self.setLogTimingAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_log_options.png'))), 'Set Log Timings', self, enabled=False)
        self.setLogTimingAction.setStatusTip('Set Log Timings')
        self.setLogTimingAction.triggered.connect(self.setLogTimings)

        loggingMenu = menubar.addMenu('&Log')
        loggingMenu.addAction(self.logLoadFileAction)
        loggingMenu.addAction(self.setLogTimingAction)
        loggingMenu.addAction(self.startloggingAction)
        loggingMenu.addAction(self.stoploggingAction)
        loggingMenu.addAction(self.quickLogAction)
        loggingMenu.addAction(self.addCommentAction)
        loggingMenu.addAction(self.showLogDataAction)
        loggingMenu.addAction(self.showLogTagsAction)
        loggingMenu.addAction(self.showLogExcerptAction)
        #loggingMenu.triggered[QtGui.QAction].connect(self.processtrigger)

        toolbar = self.addToolBar('Log')
        toolbar.setToolTip("Log Toolbar")
        toolbar.setIconSize(QtCore.QSize(32,32))  # standard size is too small
        toolbar.addAction(self.logLoadFileAction)
        toolbar.addAction(self.startloggingAction)
        toolbar.addAction(self.quickLogAction)
        toolbar.addAction(self.logSnapAction)
        toolbar.addAction(self.stoploggingAction)


#History Menu
        self.histLoadBinAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_hist_bin_active.png'))), 'Get History from Binary File', self)
        self.histLoadBinAction.setShortcut('Ctrl+B')
        self.histLoadBinAction.setStatusTip('Load history data from binary file and plot')
        self.histLoadBinAction.triggered.connect(lambda: self.getHistory("Binary File"))

        self.histLoadHisAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_hist_his_active.png'))), 'Get History from Parsed File', self)
        self.histLoadHisAction.setShortcut('Ctrl+P')
        self.histLoadHisAction.setStatusTip('Load history data from parsed history file and plot')
        self.histLoadHisAction.triggered.connect(lambda: self.getHistory("Parsed File"))

        self.histDeviceAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_hist_device_active.png'))), 'Get History from Device ', self, enabled=False)
        self.histDeviceAction.setShortcut('Ctrl+H')
        self.histDeviceAction.setStatusTip('Load history data from device and plot; requires Device connection')
        self.histDeviceAction.triggered.connect(lambda: self.getHistory("Device"))

    # bin data
        self.showHistBinDataAction = QtGui.QAction('Show History Binary Data', self)
        self.showHistBinDataAction.setStatusTip('Show history binary data in human readable form')
        self.showHistBinDataAction.triggered.connect(lambda: self.printData2NotePad("HisBin"))

        self.showHistBinDataExcerptAction = QtGui.QAction('Show History Binary Data Excerpt', self)
        self.showHistBinDataExcerptAction.setStatusTip('Show first and last few lines of history binary data in human readable form')
        self.showHistBinDataExcerptAction.triggered.connect(self.showHistBinExcerpt)

    # tags/comments
        self.showHistHisTagsAction = QtGui.QAction('Show History Tags/Comments', self)
        self.showHistHisTagsAction.setStatusTip('Show only lines from history containing tags or comments')
        self.showHistHisTagsAction.triggered.connect(self.showHistHisTags)

    # his data
        self.showHistHisDataAction = QtGui.QAction('Show History Data', self)
        self.showHistHisDataAction.setStatusTip('Show history data parsed from binary data')
        self.showHistHisDataAction.triggered.connect(lambda: self.printData2NotePad("His"))

        self.showHistExcerptAction = QtGui.QAction('Show History Data Excerpt', self)
        self.showHistExcerptAction.setStatusTip('Show first and last few lines of history data parsed from binary data')
        self.showHistExcerptAction.triggered.connect(self.showHistExcerpt)

        historyMenu = menubar.addMenu('Histor&y')
        historyMenu.addAction(self.histDeviceAction)
        historyMenu.addAction(self.histLoadBinAction)
        historyMenu.addAction(self.histLoadHisAction)
        historyMenu.addAction(self.showHistBinDataAction)
        historyMenu.addAction(self.showHistBinDataExcerptAction)
        historyMenu.addAction(self.showHistHisTagsAction)
        historyMenu.addAction(self.showHistHisDataAction)
        historyMenu.addAction(self.showHistExcerptAction)
        #historyMenu.triggered[QtGui.QAction].connect(self.processtrigger)

        toolbar     = self.addToolBar('History')
        toolbar.setToolTip("History Toolbar")
        toolbar.setIconSize(QtCore.QSize(32,32))  # standard size is too small
        toolbar.addAction(self.histDeviceAction)
        toolbar.addAction(self.histLoadBinAction)
        toolbar.addAction(self.histLoadHisAction)

# Web menu
        # menu entry and toolbar button for Map access
        self.WebAction = QtGui.QAction(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_map.png'))), 'Update Radiation World Maps', self, enabled=False)
        self.WebAction.setStatusTip('Update Radiation World Maps using average of data shown in the plot')
        self.WebAction.triggered.connect(self.pushToWeb)

        webMenu = menubar.addMenu('&Web')
        webMenu.addAction(self.WebAction)

        toolbar = self.addToolBar('Web')
        toolbar.setToolTip("Web Toolbar")
        toolbar.setIconSize(QtCore.QSize(32,32))  # standard size is too small
        toolbar.addAction(self.WebAction)


#Help Menu
        self.helpQickStartAction = QtGui.QAction('Quickstart', self)
        self.helpQickStartAction.setStatusTip('Guidance for an easy start')
        self.helpQickStartAction.triggered.connect(self.helpQuickStart)

        self.helpManualUrlAction = QtGui.QAction('GeigerLog Manual', self)
        self.helpManualUrlAction.setStatusTip('Open the GeigerLog Manual (locally if available, or online)')
        self.helpManualUrlAction.triggered.connect(self.openUrl)

        self.helpFirmwareBugAction = QtGui.QAction("Devices' Firmware Bugs", self)
        self.helpFirmwareBugAction.setStatusTip('Info on Firmware Bugs of the Devices and Workarounds')
        self.helpFirmwareBugAction.triggered.connect(self.helpFirmwareBugs)

        self.helpWorldMapsAction = QtGui.QAction('Radiation World Maps', self)
        self.helpWorldMapsAction.setStatusTip('Contributing to the Radiation World Maps')
        self.helpWorldMapsAction.triggered.connect(self.helpWorldMaps)

        self.helpOccupationalRadiationAction = QtGui.QAction('Occupational Radiation Limits', self)
        self.helpOccupationalRadiationAction.setStatusTip('Occupational Radiation Limits in USA and Germany')
        self.helpOccupationalRadiationAction.triggered.connect(self.helpOccupationalRadiation)

        self.DeviceUSBDiscoveryAction = QtGui.QAction('USB Autodiscovery', self)
        self.DeviceUSBDiscoveryAction.setStatusTip('Finding the USB Port and the Baudrate automatically')
        self.DeviceUSBDiscoveryAction.triggered.connect(self.USBautoDiscovery)

        self.helpAboutAction = QtGui.QAction('About GeigerLog', self)
        self.helpAboutAction.setStatusTip('About the GeigerLog program')
        self.helpAboutAction.triggered.connect(self.helpAbout)

        # next entries no longer in menu; visible only on devel as button
        self.helpOptionsAction = QtGui.QAction('Options', self)
        self.helpOptionsAction.setStatusTip('Show command line options')
        self.helpOptionsAction.triggered.connect(self.helpOptions)

        self.changeOptionsAction = QtGui.QAction('Change Options', self)
        self.changeOptionsAction.setStatusTip('Allows to change some command line options during running')
        self.changeOptionsAction.triggered.connect(self.changeOptions)

        self.helpSystemInfoAction = QtGui.QAction('System Info', self)
        self.helpSystemInfoAction.setStatusTip('Show Details on the Current Program Settings and Environment')
        self.helpSystemInfoAction.triggered.connect(self.showSystemInfo)

        helpMenu = menubar.addMenu('&Help')
        helpMenu.addAction(self.helpQickStartAction)
        helpMenu.addAction(self.helpManualUrlAction)
        helpMenu.addAction(self.helpFirmwareBugAction)
        helpMenu.addAction(self.helpWorldMapsAction)
        helpMenu.addAction(self.helpOccupationalRadiationAction)
        helpMenu.addSeparator()
        #    helpMenu.addAction(self.helpOptionsAction)
        #    helpMenu.addAction(self.changeOptionsAction)
        #    helpMenu.addAction(self.helpSystemInfoAction)
        helpMenu.addAction(self.DeviceUSBDiscoveryAction)
        helpMenu.addSeparator()
        helpMenu.addAction(self.helpAboutAction)
        #helpMenu.triggered[QtGui.QAction].connect(self.processtrigger)

        if gglobs.devel:
            develMenu = menubar.addMenu('Devel')
            develAlphaAction = QtGui.QAction(self.btnAlpha    .__doc__, self)
            develAlphaAction.triggered.connect(self.btnAlpha)
            develMenu.addAction(develAlphaAction)

            develBetaAction = QtGui.QAction(self.btnBeta      .__doc__, self)
            develBetaAction.triggered.connect(self.btnBeta)
            develMenu.addAction(develBetaAction)

            develGammaAction = QtGui.QAction(self.btnGamma    .__doc__, self)
            develGammaAction.triggered.connect(self.btnGamma)
            develMenu.addAction(develGammaAction)

            develDeltaAction = QtGui.QAction(self.btnDelta    .__doc__, self)
            develDeltaAction.triggered.connect(self.btnDelta)
            develMenu.addAction(develDeltaAction)

            develEpsilonAction = QtGui.QAction(self.btnEpsilon.__doc__, self)
            develEpsilonAction.triggered.connect(self.btnEpsilon)
            develMenu.addAction(develEpsilonAction)

            develZetaAction = QtGui.QAction(self.btnZeta      .__doc__, self)
            develZetaAction.triggered.connect(self.btnZeta)
            develMenu.addAction(develZetaAction)

            develEtaAction = QtGui.QAction(self.btnEta        .__doc__, self)
            develEtaAction.triggered.connect(self.btnEta)
            develMenu.addAction(develEtaAction)

            develThetaAction = QtGui.QAction(self.btnTheta    .__doc__, self)
            develThetaAction.triggered.connect(self.btnTheta)
            develMenu.addAction(develThetaAction)

            develIotaAction = QtGui.QAction(self.btnIota      .__doc__, self)
            develIotaAction.triggered.connect(self.btnIota)
            develMenu.addAction(develIotaAction)

    # tool buttons connected to stuff (may not be in use) and put into HBox layout
            btnwidth = 65
            self.btna = QtGui.QPushButton('Button Alpha')
            self.btna.setMaximumWidth(btnwidth)
            self.btna.clicked.connect(self.btnAlpha)
            self.btnb = QtGui.QPushButton('Button Beta')
            self.btnb.setMaximumWidth(btnwidth)
            self.btnb.clicked.connect(self.btnBeta)
            self.btnc = QtGui.QPushButton('Button Gamma')
            self.btnc.setMaximumWidth(btnwidth)
            self.btnc.clicked.connect(self.btnGamma)
            self.btnd = QtGui.QPushButton('Button Delta')
            self.btnd.setMaximumWidth(btnwidth)
            self.btnd.clicked.connect(self.btnDelta)
            self.btne = QtGui.QPushButton('Button Epsilon')
            self.btne.setMaximumWidth(btnwidth)
            self.btne.clicked.connect(self.btnEpsilon)
            self.btnf = QtGui.QPushButton('Button Zeta')
            self.btnf.setMaximumWidth(btnwidth)
            self.btnf.clicked.connect(self.btnZeta)
            self.btng = QtGui.QPushButton('Button Eta')
            self.btng.setMaximumWidth(btnwidth)
            self.btng.clicked.connect(self.btnEta)
            self.btnh = QtGui.QPushButton('Button Theta')
            self.btnh.setMaximumWidth(btnwidth)
            self.btnh.clicked.connect(self.btnTheta)
            self.btni = QtGui.QPushButton('Button Iota')
            self.btni.setMaximumWidth(btnwidth)
            self.btni.clicked.connect(self.btnIota)

            # set the button text to the doc string
            self.btna.setText(self.btnAlpha     .__doc__)
            self.btnb.setText(self.btnBeta      .__doc__)
            self.btnc.setText(self.btnGamma     .__doc__)
            self.btnd.setText(self.btnDelta     .__doc__)
            self.btne.setText(self.btnEpsilon   .__doc__)
            self.btnf.setText(self.btnZeta      .__doc__)
            self.btng.setText(self.btnEta       .__doc__)
            self.btnh.setText(self.btnTheta     .__doc__)
            self.btni.setText(self.btnIota      .__doc__)

            # put tool buttons into horizontal layout
            tools_layout = QtGui.QHBoxLayout()
            tools_layout.addWidget(self.btna)
            tools_layout.addWidget(self.btnb)
            tools_layout.addWidget(self.btnc)
            tools_layout.addWidget(self.btnd)
            tools_layout.addWidget(self.btne)
            tools_layout.addWidget(self.btnf)
            tools_layout.addWidget(self.btng)
            tools_layout.addWidget(self.btnh)
            tools_layout.addWidget(self.btni)


# add navigation toolbar as last toolbar
        self.addToolBar(self.navtoolbar)


# DataOptions
    # labels and entry fields
        dltitle  = QtGui.QLabel("Data")
        dltitle.setFont(QtGui.QFont("system", weight=QtGui.QFont.Bold))

        dlcf     = QtGui.QLabel("Files")
        dlcf.setAlignment(QtCore.Qt.AlignCenter)

        dlcy     = QtGui.QLabel("Timings")
        dlcy.setAlignment(QtCore.Qt.AlignCenter)
        dlcy.setFixedWidth(90)

        dlnotepad   = QtGui.QLabel("NotePad")
        dlnotepad.setAlignment(QtCore.Qt.AlignCenter)
        dlnotepad.setFixedWidth(90)

        dllog=QtGui.QLabel("Log:")

        self.dcfLog=QtGui.QLineEdit()
        self.dcfLog.setReadOnly(True)
        self.dcfLog.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")
        self.dcfLog.setToolTip('The full path of the Log-File if any is loaded')

        self.dcycl  = QtGui.QPushButton()
        self.dcycl.setToolTip('Current setting of logging cycle in seconds')
        self.dcycl.clicked.connect(self.setLogTimings)
        self.dcycl.setFixedWidth(90)

        dlhist=QtGui.QLabel("History:")
        self.dcfHis=QtGui.QLineEdit()
        self.dcfHis.setReadOnly(True)
        self.dcfHis.setStyleSheet("QLineEdit { background-color : #DFDEDD; color : rgb(80,80,80); }")
        self.dcfHis.setToolTip('The full path of the History-File if any is loaded')

        dbtnPlotLog =  QtGui.QPushButton('Plot')
        dbtnPlotLog.clicked.connect(lambda: self.plotGraph('Log'))
        dbtnPlotLog.setMaximumWidth(36)
        dbtnPlotLog.setToolTip("Plot the Log File")

        dbtnPlotHis =  QtGui.QPushButton('Plot')
        dbtnPlotHis.clicked.connect(lambda: self.plotGraph('His'))
        dbtnPlotHis.setMaximumWidth(36)
        dbtnPlotHis.setToolTip("Plot the History File")

    # button: clear notepad
        clearbutton    =  QtGui.QPushButton('Clear')
        clearbutton.clicked.connect(self.clearNotePad)
        clearbutton.setToolTip('Delete all content of the NotePad')
        clearbutton.setFixedWidth(90)

    # button: print data excerpt to notepad
        self.printbutton    =  QtGui.QPushButton('DataExcerpt')
        self.printbutton.clicked.connect(lambda: self.printData2NotePad(full=False))
        self.printbutton.setToolTip('Print Log or His Data to the NotePad')
        self.printbutton.setFixedWidth(90)

    # button: select history saving mode
        self.btnHistSaveMode =  QtGui.QPushButton('Mode: ---')
        self.btnHistSaveMode.clicked.connect(self.setHistSaveMode)
        self.btnHistSaveMode.setFixedWidth(90)
        self.btnHistSaveMode.setEnabled(False)
        self.btnHistSaveMode.setToolTip('Select the History Saving Mode')

    # separator lines - vertical
        vlinedB0 = QtGui.QFrame()
        vlinedB0.setFrameShape(QtGui.QFrame.VLine)

    # layout the Data Options
        dataOptions=QtGui.QGridLayout()

        row = 0
        dataOptions.addWidget(dltitle,                 row, 0)
        # 1 is empty
        dataOptions.addWidget(dlcf,                    row, 2)
        dataOptions.addWidget(dlcy,                    row, 3)
        dataOptions.addWidget(vlinedB0,                row, 4, 4, 1)
        dataOptions.addWidget(dlnotepad,               row, 5)

        row = 1
        dataOptions.addWidget(dllog,                   row, 0)
        dataOptions.addWidget(dbtnPlotLog,             row, 1)
        dataOptions.addWidget(self.dcfLog,             row, 2)
        dataOptions.addWidget(self.dcycl,              row, 3)
        # 4 is empty (vline)
        dataOptions.addWidget(self.printbutton,        row, 5)

        row = 2
        dataOptions.addWidget(dlhist,                  row, 0)
        dataOptions.addWidget(dbtnPlotHis,             row, 1)
        dataOptions.addWidget(self.dcfHis,             row, 2)
        dataOptions.addWidget(self.btnHistSaveMode,    row, 3)
        # 4 is empty (vline)
        dataOptions.addWidget(clearbutton,             row, 5)

        # group Data Options into Groupbox
        dataOptionsGroup = QtGui.QGroupBox()
        dataOptionsGroup.setLayout(dataOptions)


# GraphOptions
        ltitle  = QtGui.QLabel("Graph")
        ltitle.setFont(QtGui.QFont("system", weight=QtGui.QFont.Bold))

        lmin    = QtGui.QLabel("Min")
        lmin.setAlignment(QtCore.Qt.AlignCenter)

        lmax    = QtGui.QLabel("Max")
        lmax.setAlignment(QtCore.Qt.AlignCenter)

        lunit   = QtGui.QLabel("Units")
        lunit.setAlignment(QtCore.Qt.AlignCenter)

        ewidth = 120
        lcounts = QtGui.QLabel("Counter")
        ly2     = QtGui.QLabel("Ambient")
        ltime   = QtGui.QLabel("Time")

        self.ymin=QtGui.QLineEdit()
        self.ymin.setToolTip('Minimum setting for Counter axis')

        self.ymax=QtGui.QLineEdit()
        self.ymax.setToolTip('Maximum setting for Counter axis')

        self.yunit = QtGui.QComboBox()
        self.yunit.addItems(["CPM", "µSv/h"])
        self.yunit.setMaximumWidth(70)
        self.yunit.setToolTip('Select the Count Unit for the plot')
        self.yunit.currentIndexChanged.connect(self.changedGraphCountUnit)

        self.y2min=QtGui.QLineEdit()
        self.y2min.setToolTip('Minimum setting for Ambient axis')

        self.y2max=QtGui.QLineEdit()
        self.y2max.setToolTip('Maximum setting for Ambient axis')

        self.y2unit = QtGui.QComboBox()
        self.y2unit.addItems(["°C", "°F"])
        self.y2unit.setMaximumWidth(70)
        self.y2unit.setToolTip('Select the Temperature Unit')
        self.y2unit.currentIndexChanged.connect(self.changedGraphCountUnit)

        self.xmin=QtGui.QLineEdit()
        self.xmin.setToolTip('The minimum (left) limit of the time to be shown. Enter manuallly or by left-mouse-click on the graph')

        self.xmax=QtGui.QLineEdit()
        self.xmax.setToolTip('The maximum (right) limit of the time to be shown. Enter manuallly or by right-mouse-click on the graph')

        self.xunit = QtGui.QComboBox()
        self.xunit.addItems(["Time", "auto", "second", "minute", "hour", "day"])
        self.xunit.setMaximumWidth(70)
        self.xunit.currentIndexChanged.connect(self.changedGraphTimeUnit)
        self.xunit.setToolTip('The time axis to be shown as Time-of-Day (Time) or time since first record in seconds, minutes, hours, days; auto selects most appropriate period')

        self.select = QtGui.QComboBox()
        self.select.setToolTip('The data to be selected for analysis')
        self.select.setEnabled(False)
        for vname in gglobs.varnames:
            self.select.addItems([gglobs.vardict[vname]])
            #print("gglobs.vardict[vname]:", gglobs.vardict[vname])

        self.select.currentIndexChanged.connect(self.changedGraphVariable)

        self.vbox = {}
        for key in gglobs.varnames:
            vshort = gglobs.vardictshort[key]
            vlong  = gglobs.vardict[key]

            self.vbox[key] = QtGui.QCheckBox(vshort)
            self.vbox[key].setChecked(False)
            self.vbox[key].setEnabled(False)
            self.vbox[key].setTristate (False)
            self.vbox[key].setToolTip(vlong)

            # "double lambda needed for closure" WTF???
            self.vbox[key].stateChanged.connect((lambda x: lambda: self.changedGraphOptionsVals(x))(key))

        chk_width = 20

        self.avgbox = QtGui.QCheckBox("Avg")
        self.avgbox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.avgbox.setChecked(gglobs.avgChecked)
        self.avgbox.setTristate (False)
        self.avgbox.setToolTip("If checked, Average and ±95% lines will be shown")
        self.avgbox.stateChanged.connect(self.changedGraphOptionsAvg)

        self.mavbox = QtGui.QCheckBox("MvAvg")
        self.mavbox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.mavbox.setChecked(gglobs.mavChecked)
        self.mavbox.setTristate (False)
        self.mavbox.setToolTip('If checked a Moving Average line will be drawn')
        self.mavbox.stateChanged.connect(self.changedGraphOptionsMav)

        self.mav=QtGui.QLineEdit()
        self.mav.setMinimumWidth(50)
        self.mav.setMaximumWidth(50)
        self.mav.setToolTip('Enter the Moving Average smoothing period in seconds')
        self.mav.setText(str(gglobs.mav_initial))
        self.mav.textChanged.connect(self.changedGraphOptionsMavText)

        btn_width = 50

        btnPoisson =  QtGui.QPushButton('Poiss')
        btnPoisson.clicked.connect(lambda: self.plotPoisson())
        btnPoisson.setFixedWidth(btn_width)
        btnPoisson.setToolTip("Shows a plot of a Poisson curve on a histogram of the data in the current plot")

        btnFFT =  QtGui.QPushButton('FFT')
        btnFFT.clicked.connect(lambda: self.plotFFT())
        btnFFT.setFixedWidth(btn_width)
        btnFFT.setToolTip("Show a plot of FFT spectra & Autocorrelation of the data in the current plot")

        btnPlotStats =  QtGui.QPushButton('Stats')
        btnPlotStats.clicked.connect(lambda: self.printStats())
        btnPlotStats.setFixedWidth(btn_width)
        btnPlotStats.setToolTip("Shows the Statistics of the data in the current plot")

        btnQuickStats =  QtGui.QPushButton('SuSt')
        btnQuickStats.clicked.connect(lambda: self.printSuSt())
        btnQuickStats.setFixedWidth(btn_width)
        btnQuickStats.setToolTip("Shows an All-Variables Overview of the data in the current plot")

        btnReset  = QtGui.QPushButton('Reset')
        btnReset.clicked.connect(self.reset_replotGraph)
        btnReset.setFixedWidth(btn_width)
        btnReset.setToolTip("Reset all Graph Options to Default conditions")

        btnClear  = QtGui.QPushButton('Clear')
        btnClear.clicked.connect(self.clearGraphLimits)
        btnClear.setFixedWidth(btn_width)
        btnClear.setToolTip("Clear the Graph Limit Options to Default conditions")

        btnApplyGraph = QtGui.QPushButton('Apply')
        btnApplyGraph.clicked.connect(self.applyGraphOptions)
        btnApplyGraph.setStyleSheet("background-color: lightblue")
        btnApplyGraph.setFixedWidth(btn_width)
        btnApplyGraph.setMinimumHeight(65)
        btnApplyGraph.setToolTip("Apply the Graph Options and replot")
        btnApplyGraph.setDefault(True)

        self.labelVar = QtGui.QLabel("---")
        self.labelVar.setToolTip("Shows the variable value in additional units when logging")
        self.labelVar.setMinimumWidth(130)
        self.labelVar.setFont(QtGui.QFont('sans', 14, QtGui.QFont.Bold))
        self.labelVar.setStyleSheet('color:darkgray;')
        self.labelVar.setAlignment(QtCore.Qt.AlignCenter)
        #self.labelVar.mousePressEvent=self.getManualLogValue


    # separator lines
        vlineA0 = QtGui.QFrame()
        vlineA0.setFrameShape(QtGui.QFrame.VLine)

        hlineB3 = QtGui.QFrame()
        hlineB3.setFrameShape(QtGui.QFrame.HLine)

    # OFF / ON button
        btn_width = 35
        btnOFF = QtGui.QPushButton('OFF')
        btnOFF .setToolTip("Uncheck all variables")
        btnOFF .clicked.connect(lambda: self.plotVarsOffOn("OFF"))
        btnOFF .setMaximumWidth(btn_width)

        btnON  = QtGui.QPushButton('ON')
        btnON  .setToolTip("Check all avialable variables")
        btnON  .clicked.connect(lambda: self.plotVarsOffOn("ON"))
        btnON  .setMaximumWidth(btn_width)

    # layout of variables check boxes with OFF / ON button
        layoutH = QtGui.QHBoxLayout()
        layoutH.addWidget(btnOFF)
        layoutH.addWidget(btnON)
        for i, vname in enumerate(gglobs.varnames):
            layoutH.addWidget(self.vbox[vname])

    #layout the GraphOptions
        graphOptions=QtGui.QGridLayout()

        # to define the order of stepping through by tab key this is put in front
        row = 1
        graphOptions.addWidget(self.ymin,       row, 1)
        graphOptions.addWidget(self.ymax,       row, 2)
        row = 2
        graphOptions.addWidget(self.y2min,      row, 1)
        graphOptions.addWidget(self.y2max,      row, 2)
        row = 3
        graphOptions.addWidget(self.xmin,       row, 1)
        graphOptions.addWidget(self.xmax,       row, 2)

        row = 0
        graphOptions.addWidget(ltitle,          row, 0)
        graphOptions.addWidget(lmin,            row, 1)
        graphOptions.addWidget(lmax,            row, 2)
        graphOptions.addWidget(btnReset,        row, 3)
        # 3 is empty (Clear, Apply and Reset button)
        graphOptions.addWidget(lunit,           row, 4)
        graphOptions.addWidget(vlineA0,         row, 5, 4, 1)
        graphOptions.addWidget(self.select,     row, 6, 1, 2)
        graphOptions.addWidget(btnQuickStats,   row, 8)

        row = 1
        graphOptions.addWidget(lcounts,         row, 0)
        #graphOptions.addWidget(self.ymin,       row, 1)
        #graphOptions.addWidget(self.ymax,       row, 2)
        graphOptions.addWidget(btnClear,        row, 3)
        graphOptions.addWidget(self.yunit,      row, 4)
        # 5 is empty (vert line)
        graphOptions.addWidget(self.mavbox,     row, 6)
        graphOptions.addWidget(self.mav,        row, 7)
        graphOptions.addWidget(btnPlotStats,    row, 8)

        row = 2
        graphOptions.addWidget(ly2,             row, 0)
        #graphOptions.addWidget(self.y2min,      row, 1)
        #graphOptions.addWidget(self.y2max,      row, 2)
        graphOptions.addWidget(btnApplyGraph,   row, 3, 2, 1)
        graphOptions.addWidget(self.y2unit,     row, 4)
        # 5 is empty (vert line)
        graphOptions.addWidget(self.avgbox,     row, 6)
        graphOptions.addWidget(btnPoisson,      row, 8)

        row = 3
        graphOptions.addWidget(ltime,           row, 0)
        #graphOptions.addWidget(self.xmin,       row, 1)
        #graphOptions.addWidget(self.xmax,       row, 2)
        graphOptions.addWidget(self.xunit,      row, 4)
        # 5 is empty (vert line)
        graphOptions.addWidget(self.labelVar,   row, 6, 1, 2)
        graphOptions.addWidget(btnFFT,          row, 8)

        row = 4
        graphOptions.addWidget(hlineB3,         row, 0, 1, 9)

        row = 5
        graphOptions.addLayout(layoutH,         row, 0, 1, 9)

    # group Graph Options into Groupbox
        graphOptionsGroup = QtGui.QGroupBox()
        graphOptionsGroup.setLayout(graphOptions)
        graphOptionsGroup.setMaximumHeight(200)


# NotePad
        self.notePad = QtGui.QTextEdit()
        self.notePad.setReadOnly(True)
        self.notePad.setFont(self.fontstd)
        self.notePad.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        self.notePad.setStyleSheet("color: rgb(60, 60, 60)") # does it help against all red???

        #set gglobs.notePad (used for fprint in utils)
        gglobs.notePad = self.notePad

# LogPad
        self.logPad = QtGui.QTextEdit()
        self.logPad.setReadOnly(True)
        self.logPad.setFont(self.fontstd)
        self.logPad.setLineWrapMode(QtGui.QTextEdit.NoWrap)

# set the layout - left side
        splitterPad = QtGui.QSplitter(QtCore.Qt.Vertical)
        splitterPad.addWidget(self.notePad)
        splitterPad.addWidget(self.logPad)
        splitterPad.setSizes([800, 300])

        layoutLeft = QtGui.QVBoxLayout()
        layoutLeft.addWidget(dataOptionsGroup)
        layoutLeft.addWidget(splitterPad)
        #if gglobs.devel:                     layoutLeft.addLayout(tools_layout)

# set the layout - right side
        myLayout =  QtGui.QVBoxLayout()     # to show canvas with frame
        myLayout.addWidget(self.canvas)
        myLayout.setMargin(0)

        myGroup = QtGui.QGroupBox()
        myGroup.setLayout(myLayout)

        layoutRight = QtGui.QVBoxLayout()
        layoutRight.addWidget(graphOptionsGroup)
        layoutRight.addWidget(myGroup)

# set the layout - both
        leftWidget = QtGui.QWidget()
        leftWidget.setLayout(layoutLeft)

        rightWidget = QtGui.QWidget()
        rightWidget.setLayout(layoutRight)

        splitterBoth = QtGui.QSplitter(QtCore.Qt.Horizontal)
        splitterBoth.addWidget(leftWidget)
        splitterBoth.addWidget(rightWidget)
        splitterBoth.setSizes([800, 750])

# centralwidget
        self.setCentralWidget(splitterBoth)

#timer for logging
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.getLogValue)

#show
        self.dcfLog.setText(str(gglobs.logFilePath))     # default is None
        self.dcfHis.setText(str(gglobs.hisFilePath))
        self.showTimingSetting (gglobs.logcycle)

        self.show()
        if gglobs.window_size == "maximized":
            self.showMaximized()

        vprint(gglobs.verbose, "Fonts: App     -",       strFontInfo("", app.font()))  # print font info for QApplication
        vprint(gglobs.verbose, "Fonts: logPad  -",       strFontInfo("", self.logPad.fontInfo()))
        vprint(gglobs.verbose, "Fonts: notePad -",       strFontInfo("", self.notePad.fontInfo()))
        vprint(gglobs.verbose, "Fonts: menubar -",       strFontInfo("", menubar.fontInfo()))
        vprint(gglobs.verbose, "Screen: Dimensions: ",   QtGui.QDesktopWidget().screenGeometry()) # gives screen dimensions
        vprint(gglobs.verbose, "Screen: Available:  ",   screen_available)                        # gives screen dimensions available

        # Note on Windows sizes:
        # "On X11, a window does not have a frame until the window manager decorates it."
        # see: http://doc.qt.io/qt-4.8/application-windows.html#window-geometry
        dprint(gglobs.debug, "Window: Dimensions: ", self.geometry(), " w/o Frame") # gives Windows dimensions but has the frame EXCLUDED!
        dprint(gglobs.debug, "Window: Dimensions: ", self.frameGeometry(), " WITH Frame (not valid on X11)") # self.frameGeometry() gives Windows dimensions including frame, but not on X11!

        # copyright message
        message = __copyright__ + ", by " + __author__ + ", License: " + __license__
        self.showStatusMessage(message, timing=0, error=False) # message remains until overwritten by next

        QtGui.QApplication.processEvents()

        vprint(gglobs.verbose, "Data  Options group: height: {}, width: {}".format(dataOptionsGroup.height(), dataOptionsGroup.width()))
        vprint(gglobs.verbose, "Graph Options group: height: {}, width: {}".format(graphOptionsGroup.height(), graphOptionsGroup.width()))

        dprint(gglobs.debug, TGREEN + "Startup complete " + "-" * 110 + TDEFAULT + "\n")

        # Devel Data - start GeigerLog with command 'devel' e.g.: 'geigerlog -dv devel'
        if gglobs.devel1:
            #testFile = gglobs.dataPath + "/testdata/TESTDATA.log"
            testFile = gglobs.dataPath + "/default.log"
            #testFile = gglobs.dataPath + "/COPYduenger1.log"
            #testFile = gglobs.dataPath + "/Synthetic/" + "WhiteNoisePoisson, mean=20.0.log"
            #testFile = gglobs.dataPath + "/Synthetic/" + "WhiteNoisePoisson, mean=2.5, cycle=1.0, mode=CPS.log"

            if os.access(testFile , os.R_OK):
                self.getLogFile(defaultFile = testFile)
            else:
                dprint(True, "Testfile '{}' not found".format(testFile))

        if gglobs.devel2:
            self.switchConnections(new_connection = "ON")


#========== END __init__ ======================================================
#
#========== BEGIN Class Functions =============================================


    def keyPressEvent(self, event):
        """Apply Graph is only Button to accept enter key"""

        # from: http://pyqt.sourceforge.net/Docs/PyQt4/qt.html#Key-enum
        # Qt.Key_Return     0x01000004
        # Qt.Key_Enter      0x01000005  Typically located on the keypad. (= numeric keypad)
        #print("event.key():", event.key())

        # Did the user press the Enter or Return key?
        if event.key() == QtCore.Qt.Key_Enter or event.key() == QtCore.Qt.Key_Return:
            self.applyGraphOptions()


    def plotVarsOffOn(self, newstate="OFF"): # alt: 'ON'
        """checks or unchecks all variables from plotting"""

        gglobs.allowGraphUpdate    = False
        if newstate == "OFF":
            for i, vname in enumerate(gglobs.varnames):
                self.vbox[vname].setChecked(False)
                self.select.model().item(i) .setEnabled(False)
        else:
            for i, vname in enumerate(gglobs.varnames):
                if gglobs.varchecked[vname]:

                    self.vbox[vname].setChecked(True)
                    self.vbox[vname].setEnabled(True)
                    self.select.model().item(i) .setEnabled(True)

        gglobs.allowGraphUpdate    = True
        self.applyGraphOptions(fprintMAV = False)


    def popup(self):

        """ checking radiobuttons
        radio1 = QtGui.QRadioButton("button 1")
        radio2 = QtGui.QRadioButton("button 2")
        radio3 = QtGui.QRadioButton("button 3")

        for i in range(1,4):
            buttonname = "radio" + str(i)           # das geht???????
            if buttonname.isChecked():
                print buttonname + "is Checked"
        """

        if gglobs.ser == None:
            self.showStatusMessage("No Device Connected")
            return

        # https://www.tutorialspoint.com/pyqt/pyqt_qlineedit_widget.htm
        # https://snorfalorpagus.net/blog/2014/08/09/validating-user-input-in-pyqt4-using-qvalidator/

        myLocale = QtCore.QLocale (QtCore.QLocale(QtCore.QLocale.English, QtCore.QLocale.UnitedStates))

        setDefault = False

        while True:
            fbox=QtGui.QFormLayout()
            #fbox.setFieldGrowthPolicy (2)
            fbox.setFieldGrowthPolicy (QtGui.QFormLayout.AllNonFixedFieldsGrow)

            # power
            r01=QtGui.QRadioButton("On")
            r02=QtGui.QRadioButton("Off")
            powergroup = QtGui.QButtonGroup()
            powergroup.addButton(r01)
            powergroup.addButton(r02)
            hbox0=QtGui.QHBoxLayout()
            hbox0.addWidget(r01)
            hbox0.addWidget(r02)
            hbox0.addStretch()
            fbox.addRow(QtGui.QLabel("Power"),hbox0)
            if gcommands.isPowerOn() == 'ON':
                r01.setChecked(True)
            else:
                r02.setChecked(True)

            # alarm
            r11=QtGui.QRadioButton("On")
            r12=QtGui.QRadioButton("Off")
            alarmgroup = QtGui.QButtonGroup()
            alarmgroup.addButton(r11)
            alarmgroup.addButton(r12)

            hbox1=QtGui.QHBoxLayout()
            hbox1.addWidget(r11)
            hbox1.addWidget(r12)
            hbox1.addStretch()
            fbox.addRow(QtGui.QLabel("Alarm"),hbox1)
            if gcommands.isAlarmOn() == 'ON':
                r11.setChecked(True)
            else:
                r12.setChecked(True)

            # Speaker
            r21=QtGui.QRadioButton("On")
            r22=QtGui.QRadioButton("Off")
            speakergroup = QtGui.QButtonGroup()
            speakergroup.addButton(r21)
            speakergroup.addButton(r22)
            hbox2=QtGui.QHBoxLayout()
            hbox2.addWidget(r21)
            hbox2.addWidget(r22)
            hbox2.addStretch()
            fbox.addRow(QtGui.QLabel("Speaker"),hbox2)
            if gcommands.isSpeakerOn() == 'ON':
                r21.setChecked(True)
            else:
                r22.setChecked(True)

            # history Saverdatatapye
            hbox3=QtGui.QHBoxLayout()
            cb1=QtGui.QComboBox()
            cb1.addItems(gglobs.savedatatypes)
            hbox3.addWidget(cb1)
            hbox3.addStretch()
            fbox.addRow(QtGui.QLabel("History Saving Mode"),hbox3)
            if gglobs.ser == None:
                cb1.setCurrentIndex(0)
            else:
                cb1.setCurrentIndex(gglobs.savedataindex)

            # WiFi settings
            l1e=QtGui.QLineEdit()
            l1e.setMaxLength (32)
            l2e=QtGui.QLineEdit()
            l2e.setMaxLength (32)
            l3e=QtGui.QLineEdit()
            l3e.setMaxLength (32)
            l4e=QtGui.QLineEdit()
            l4e.setMaxLength (32)
            l5e=QtGui.QLineEdit()
            l5e.setMaxLength (32)
            l6e=QtGui.QLineEdit()
            l6e.setMaxLength (32)

            # self.calibration
            self.calHead = QtGui.QHBoxLayout()
            self.calHead.addWidget(QtGui.QLabel(" CPM"))
            self.calHead.addWidget(QtGui.QLabel(" µSv/h"))
            self.calHead.addWidget(QtGui.QLabel(" µSv/h / CPM"))

            fbox.addRow("Calibration Units:", self.calHead)

            self.cal0     = QtGui.QHBoxLayout()
            self.cal0_cpm = QtGui.QLineEdit()
            self.cal0_cpm.setValidator (QtGui.QIntValidator(0, 99999))
            #self.cal0_cpm.textChanged.connect(self.textChanged)
            #self.cal0_cpm.textChanged.connect(lambda: self.textChanged("self.cal0_cpm"))
            self.cal0_cpm.editingFinished.connect(lambda: self.editingFinished("self.cal0_cpm"))
            #self.cal0_cpm.textEdited.connect(lambda: self.textChanged("self.cal0_cpm"))
            self.cal0_cpm.setToolTip("Enter an integer from 0 ... 99999")

            self.cal0_usv = QtGui.QLineEdit()
            #self.cal0_usv.setValidator(QtGui.QDoubleValidator(0, 9999, 4))
            #self.cal0_usv.textChanged.connect(lambda: self.textChanged(123))
            self.cal0_usv.editingFinished.connect(lambda: self.editingFinished("self.cal0_usv"))
            #self.cal0_usv.textEdited.connect(lambda: self.textChanged("self.cal0_usv"))
            #self.cal0_usv.textChanged.connect(self.check_state)
            self.cal0_usv.setToolTip("Enter a number from 0 ... 9999 with no more than 4 decimals")

            #self.cal0_fac = QtGui.QLineEdit()
            #self.cal0_fac.setEnabled(False)
            self.cal0_fac = QtGui.QLabel()

            self.cal0.addWidget(self.cal0_cpm)
            self.cal0.addWidget(self.cal0_usv)
            self.cal0.addWidget(self.cal0_fac)
            fbox.addRow("Calibration Point 1", self.cal0)

            self.cal1     = QtGui.QHBoxLayout()
            self.cal1_cpm = QtGui.QLineEdit()
            self.cal1_cpm.setValidator (QtGui.QIntValidator(0, 99999))
            self.cal1_usv = QtGui.QLineEdit()
            #self.cal1_fac = QtGui.QLineEdit()
            #self.cal1_fac.setEnabled(False)
            self.cal1_fac = QtGui.QLabel()

            self.cal1.addWidget(self.cal1_cpm)
            self.cal1.addWidget(self.cal1_usv)
            self.cal1.addWidget(self.cal1_fac)
            fbox.addRow("Calibration Point 2", self.cal1)

            self.cal2     = QtGui.QHBoxLayout()
            self.cal2_cpm = QtGui.QLineEdit()
            self.cal2_cpm.setValidator (QtGui.QIntValidator(0, 99999))
            self.cal2_usv = QtGui.QLineEdit()
            #self.cal2_fac = QtGui.QLineEdit()
            #self.cal2_fac.setEnabled(False)
            self.cal2_fac = QtGui.QLabel()

            self.cal2.addWidget(self.cal2_cpm)
            self.cal2.addWidget(self.cal2_usv)
            self.cal2.addWidget(self.cal2_fac)
            fbox.addRow("Calibration Point 3", self.cal2)

            for i in range(0,3):
                self.calcpm = gglobs.cfgLow["CalibCPM_{}".format(i)]
                self.calusv = gglobs.cfgLow["CalibuSv_{}".format(i)]
                self.calfac = self.calusv / self.calcpm

                if i == 0:
                    self.cal0_cpm.setText("{:1.0f}".format(self.calcpm))
                    self.cal0_usv.setText("{:1.2f}".format(self.calusv))
                    self.cal0_fac.setText("{:1.6f}".format(self.calfac))
                elif i == 1:
                    self.cal1_cpm.setText("{:1.0f}".format(self.calcpm))
                    self.cal1_usv.setText("{:1.2f}".format(self.calusv))
                    self.cal1_fac.setText("{:1.6f}".format(self.calfac))
                elif i == 2:
                    self.cal2_cpm.setText("{:1.0f}".format(self.calcpm))
                    self.cal2_usv.setText("{:1.2f}".format(self.calusv))
                    self.cal2_fac.setText("{:1.6f}".format(self.calfac))


            fbox.addRow("Website",l1e)
            fbox.addRow("URL",l2e)
            fbox.addRow("SSID",l3e)
            fbox.addRow("Password",l4e)
            fbox.addRow("CounterID",l5e)
            fbox.addRow("UserID",l6e)

            if setDefault :
                l1e.setText(gglobs.GMCmap["Website"])
                l2e.setText(gglobs.GMCmap["URL"])
                l3e.setText(gglobs.GMCmap["SSID"])
                l4e.setText(gglobs.GMCmap["Password"])
                l5e.setText(gglobs.GMCmap["CounterID"])
                l6e.setText(gglobs.GMCmap["UserID"])

            else:
                l1e.setText(gglobs.cfgMap["Website"])
                l2e.setText(gglobs.cfgMap["URL"])
                l3e.setText(gglobs.cfgMap["SSID"])
                l4e.setText(gglobs.cfgMap["Password"])
                l5e.setText(gglobs.cfgMap["CounterID"])
                l6e.setText(gglobs.cfgMap["UserID"])

            #fbox.addRow(QtGui.QPushButton("Submit"),QtGui.QPushButton("Cancel"))

            self.dialog = QtGui.QDialog()
            self.dialog.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
            self.dialog.setFont(self.fontstd)
            self.dialog.setWindowTitle("popup")
            #d.setWindowModality(QtCore.Qt.ApplicationModal)
            self.dialog.setWindowModality(QtCore.Qt.WindowModal)
            #d.setMinimumWidth(800)
            #self.dialog.setMinimumHeight(gglobs.window_height + 50)


            # buttonbox: https://srinikom.github.io/pyside-docs/PySide/QtGui/QDialogButtonBox.html
            bbox    = QtGui.QDialogButtonBox()

            bbox.addButton("Apply my Defaults", QtGui.QDialogButtonBox.HelpRole)
            #bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok|QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Reset)
            bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok|QtGui.QDialogButtonBox.Cancel)
            bbox.addButton("My Reset", QtGui.QDialogButtonBox.ResetRole)
            bbox.accepted.connect(lambda: self.dialog.done(0))
            bbox.rejected.connect(lambda: self.dialog.done(1))
            bbox.helpRequested.connect(lambda: self.dialog.done(2))
            bbox.clicked .connect(lambda: self.dialog.done(3))

            layoutV   = QtGui.QVBoxLayout(self.dialog)
            layoutV.addLayout(fbox)
            layoutV.addWidget(bbox)

            ex = self.dialog.exec_()             # both seem to work the same


            print("-------------Ex:", ex)

            if ex == 0:
                pass
                break
            elif ex == 2:
                setDefault = True
            elif ex == 3:
                setDefault = False
            else:
                break


        print("r01 is Checked: ", r01.isChecked())
        print("r02 is Checked: ", r02.isChecked())
        print("r11 is Checked: ", r11.isChecked())
        print("r12 is Checked: ", r12.isChecked())
        print("r21 is Checked: ", r21.isChecked())
        print("r22 is Checked: ", r22.isChecked())
        print("cb1.currentIndex():", cb1.currentIndex())


    def textChanged(self,  number, *args, **kwargs):
        """ Function doc """

        print("textChanged:---------------------------")
        print("len(args):", len(args))
        for a in args:
            print("a:", a)

        print("len(kwargs):", len(kwargs))
        for a in kwargs:
            print("a:", a)
        print("number is:", number)

        print("self.sender:",               self.sender)
        print("self.sender():",             self.sender())
        print("self.sender().text:",        self.sender().text)
        print("self.sender().text():",      self.sender().text())
        print("self.sender().validator:",   self.sender().validator)
        print("self.sender().validator():", self.sender().validator())

        sender = self.sender()
        validator = sender.validator()
        state = validator.validate(sender.text(), 0)[0]
        print("validator.validate(sender.text(), 0):", validator.validate(sender.text(), 0))
        print("validator.validate(sender.text(), 1):", validator.validate(sender.text(), 1))

        print("float(self.sender().text()):",      float(self.sender().text()))



    def enterPress(self, text):
        """ Function doc """
        print("edited, text:", text)

    def editingFinished(self, text, *args, **kwargs):
        """ Function doc """
        print("editingFinished---------------------------")
        print("len(args):", len(args))
        for a in args:
            print("a:", a)

        print("len(kwargs):", len(kwargs))
        for a in kwargs:
            print("a:", a)

        print("self.sender().text:",        self.sender().text)

        try:
            print("float(self.sender().text()):",      float(self.sender().text()))
        except:
            print("float(self.sender().text()):",      "##############################")

        try:
            usv = float(self.cal0_usv.text())
            self.cal0_fac.setText("{:1.6f}".format(usv  / float(self.cal0_cpm.text() )))
        except:
            self.cal0_usv.setFocus()
            self.cal0_usv.setStyleSheet('QLineEdit { background-color: %s }' % 'yellow')


            playMedia(error=True)


    def check_state(self, *args, **kwargs):
        print("check_state:---------------------------")
        print("len(args):", len(args))
        for a in args:
            print("a:", a)

        print("len(kwargs):", len(kwargs))
        for a in kwargs:
            print("a:", a)
        print("self.sender:",               self.sender)
        print("self.sender():",             self.sender())
        print("self.sender().text:",        self.sender().text)
        print("self.sender().text():",      self.sender().text())
        print("self.sender().validator:",   self.sender().validator)
        print("self.sender().validator():", self.sender().validator())

        sender = self.sender()
        validator = sender.validator()
        state = validator.validate(sender.text(), 0)[0]
        print("validator.validate(sender.text(), 0):", validator.validate(sender.text(), 0))
        print("validator.validate(sender.text(), 1):", validator.validate(sender.text(), 1))

        print("float(self.sender().text()):",      float(self.sender().text()))

        if state == QtGui.QValidator.Acceptable:
            #color = '#c4df9b' # green
            color = 'white'
        elif state == QtGui.QValidator.Intermediate:
            color = '#fff79a' # yellow
        else:
            playMedia(error=True)
            color = '#f6989d' # red
        sender.setStyleSheet('QLineEdit { background-color: %s }' % color)


    def getManualLogValue(self, event):
        """Take a measurement when the count rate area is left clicked"""

        vprint(gglobs.verbose, "getManualLogValue:")
        debugIndent(1)

        self.print2NotePad(header("Manually Triggered Log Values"))
        self.getLogValue()
        self.print2NotePad(gglobs.lastRecord)
        vprint(gglobs.verbose, "getManualLogValue: " + gglobs.lastRecord)

        debugIndent(0)


#exit GeigerLog
    def closeEvent(self, event):
        """is called via self.close! Allow to Exit unless Logging is active"""

        # 19: Widget was closed (QCloseEvent).
        dprint(gglobs.debug, "closeEvent: event: type: {}".format(event.type()))
        debugIndent(1)

        if gglobs.logging :
            event.ignore()
            self.showStatusMessage("Cannot exit when logging! Stop logging first")
            dprint(gglobs.debug, "closeEvent: ignore. ", "Cannot exit when logging! Stop logging first")
        else:
            event.accept() # allow closing the window

            # terminate the RadMon client
            #print("gglobs.client:", gglobs.client)
            if gglobs.client != None:   gradmon.terminateRadMon()

            QtGui.QApplication.quit()              # works but keeps prog running, CTRL-C needed
            QtGui.QApplication.closeAllWindows()   # works but keeps prog running, CTRL-C needed

            dprint(gglobs.debug, "closeEvent: accept. About to exit")
            sys.exit(0)                            # sometimes needed to really shut down

        debugIndent(0)


#GraphOptions

    def changedGraphVariable(self):
        """called from the select combo for variables"""

        self.applyGraphOptions(fprintMAV = True)



    def changedGraphOptionsVals(self, value):
        """Graph Option Value select has changed"""

        if not gglobs.allowGraphUpdate: return

        text    = gglobs.vardict[value]
        index   = self.select.findText(text)
        #print("changedGraphOptionsVals: text, index:", text, index)

        if self.vbox[value].isChecked():
            # sets and enables the select combobox to the checked variable
            self.select                     .setCurrentIndex(index)
            self.select.model().item(index) .setEnabled(True)

        else:
            # disables the unchecked variable on the select combobox,
            # and sets it to the first entry
            # !!!! selects CPM even if CPM is disabled !!!!
            self.select.model().item(index) .setEnabled(False)
            if self.select.currentIndex() == index: self.select.setCurrentIndex(0)

        self.applyGraphOptions(fprintMAV = False)


    def changedGraphOptionsAvg(self, i):
        """Graph Option Avg has changed"""

        #print("changedGraphOptionsAvg: i:", i)
        gglobs.avgChecked  = self.avgbox.isChecked()
        self.applyGraphOptions()


    def changedGraphOptionsMav(self, i):
        """Graph Option Mav has changed"""

        #print("changedGraphOptionsMav: i:", i)
        gglobs.mavChecked  = self.mavbox.isChecked()
        if self.mavbox.isChecked(): self.applyGraphOptions(fprintMAV = True)
        else:                       self.applyGraphOptions(fprintMAV = False)


    def changedGraphOptionsMavText(self, i):
        """Graph Option Mav has changed"""

        #print("changedGraphOptionsMavText: i:", i)
        if self.mavbox.isChecked():
            #print("self.mavbox.isChecked():", self.mavbox.isChecked())
            self.applyGraphOptions(fprintMAV = True)
        else:
            #print("self.mavbox.isChecked():", self.mavbox.isChecked())
            self.applyGraphOptions(fprintMAV = False)


    def clearGraphLimits(self, fprintMAV = False):
        """resets all min, max graph options to empty and plots the graph"""

        dprint(gglobs.debug, "clearGraphLimits:")
        debugIndent(1)

        gglobs.Xleft               = None
        gglobs.Xright              = None
        self.xmin.                   setText("")
        self.xmax.                   setText("")

        gglobs.Ymin                = None
        gglobs.Ymax                = None
        self.ymin.                   setText("")
        self.ymax.                   setText("")

        gglobs.Y2min               = None
        gglobs.Y2max               = None
        self.y2min.                  setText("")
        self.y2max.                  setText("")

        gplot.makePlot(fprintMAV = fprintMAV)

        debugIndent(0)


    def reset_replotGraph(self, fprintMAV = False):
        """resets all graph options to start conditions and plots the graph"""

        dprint(gglobs.debug, "reset_replotGraph:")
        debugIndent(1)

        gglobs.allowGraphUpdate    = False

        gglobs.Xleft               = None
        gglobs.Xright              = None
        gglobs.Xunit               = "Time"
        self.xmin.                   setText("")
        self.xmax.                   setText("")
        self.xunit.                  setCurrentIndex(0)

        gglobs.Ymin                = None
        gglobs.Ymax                = None
        gglobs.Yunit               = "CPM"
        self.ymin.                   setText("")
        self.ymax.                   setText("")
        self.yunit.                  setCurrentIndex(0)

        gglobs.Y2min               = None
        gglobs.Y2max               = None
        gglobs.Y2unit              = "°C"
        self.y2min.                  setText("")
        self.y2max.                  setText("")
        self.y2unit.                 setCurrentIndex(0)

        self.select.                 setCurrentIndex(0)
        self.select.                 setEnabled(True)

        gglobs.avgChecked          = False
        self.avgbox.                 setChecked(gglobs.avgChecked)

        gglobs.mavChecked          = False
        self.mavbox.                 setChecked(gglobs.mavChecked)

        gglobs.mav                 = gglobs.mav_initial
        self.mav.                    setText(str(gglobs.mav_initial))

        gglobs.lastValues          = None
        self.updateCountLabel()
        gglobs.allowGraphUpdate    = True
        self.plotVarsOffOn(newstate="ON")
        #gplot.makePlot(fprintMAV = fprintMAV) # is done by self.plotVarsOffOn

        debugIndent(0)


    def applyGraphOptions(self, fprintMAV = False):

        if gglobs.currentFilePath == None: return

        #replace comma with dot, strip outer whitespace
        xmin  = (str(self.xmin.text()).replace(",", ".")).strip()
        xmax  = (str(self.xmax.text()).replace(",", ".")).strip()
        xunit = str(self.xunit.currentText())

        ymin  = (str(self.ymin.text()).replace(",", ".")).strip()
        ymax  = (str(self.ymax.text()).replace(",", ".")).strip()
        yunit = str(self.yunit.currentText())

        y2min  = (str(self.y2min.text()).replace(",", ".")).strip()
        y2max  = (str(self.y2max.text()).replace(",", ".")).strip()

        mav   = (str(self.mav.text()).replace(",", ".") ).strip()

    #    print( "X  xmin, xmax, xunit:", xmin, xmax, xunit)
    #    print( "Y: ymin, ymax, yunit, mav", ymin, ymax, yunit, mav)

        if  xmin == "":
            gglobs.Xleft  = None
        else:
            if gglobs.Xunit == "Time":
                try:
                    gglobs.Xleft = mpld.datestr2num(str(xmin))
                except:
                    gglobs.Xleft = None
                    self.errprint2NotePad("Did not recognize Time Min")
            else:
                try:
                    gglobs.Xleft     = float(xmin)
                except:
                    gglobs.Xleft     = None
                    self.errprint2NotePad("Did not recognize Time Min")

        if  xmax == "":
            gglobs.Xright = None
        else:
            if gglobs.Xunit == "Time":
                try:
                    gglobs.Xright = mpld.datestr2num(str(xmax))
                except:
                    gglobs.Xright = None
                    self.errprint2NotePad("Did not recognize Time Max")
            else:
                try:
                    gglobs.Xright    = float(xmax)
                except:
                    gglobs.Xright    = None
                    self.errprint2NotePad("Did not recognize Time Max")

        #print( "Xleft ", gglobs.Xleft,  ",  Xright", gglobs.Xright)

        if gglobs.Xleft != None and gglobs.Xright != None:
            if gglobs.Xleft >= gglobs.Xright:
                self.errprint2NotePad("Wrong numbers: Time Min must be less than Time Max")
                return

        gglobs.Xunit     = xunit

        try:
            gglobs.Ymin      = float(ymin)
        except:
            gglobs.Ymin      = None

        try:
            gglobs.Ymax      = float(ymax)
        except:
            gglobs.Ymax      = None

        if gglobs.Ymin != None and gglobs.Ymax != None:
            if gglobs.Ymin >= gglobs.Ymax:
                self.errprint2NotePad("Wrong numbers: Count Rate min must be less than Count Rate max")
                return

        gglobs.Yunit     = yunit

        try:
            gglobs.Y2min      = float(y2min)
        except:
            gglobs.Y2min      = None

        try:
            gglobs.Y2max      = float(y2max)
        except:
            gglobs.Y2max      = None

        if gglobs.Y2min != None and gglobs.Y2max != None:
            if gglobs.Y2min >= gglobs.Y2max:
                self.errprint2NotePad("Wrong numbers: Count Rate min must be less than Count Rate max")
                return

        try:
            gglobs.mav     = float(mav)
        except:
            gglobs.mav     = gglobs.mav_initial

        gplot.makePlot(fprintMAV = fprintMAV)
        self.updateCountLabel()


    def plotGraph(self, current = None):

        dprint(gglobs.debug, "plotGraph:")
        debugIndent(1)

        msg = "No file available"

        while True:
            if current == None:
                if gglobs.currentFilePath == None:
                    self.showStatusMessage(msg)
                    break

            elif current == "Log":
                if gglobs.logFilePath == None:
                    self.showStatusMessage(msg)
                    break

                else:
                    gglobs.currentFilePath = gglobs.logFilePath
                    gglobs.currentFileData = gglobs.logFileData
                    self.dcfLog.setText(gglobs.currentFilePath)
                    self.dcfLog.setStyleSheet("QLineEdit { background-color: #F9F4C9; color: rgb(80,80,80); }")
                    self.dcfHis.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")

            elif current == 'His':
                if gglobs.hisFilePath == None:
                    self.showStatusMessage(msg)
                    break

                else:
                    gglobs.currentFilePath = gglobs.hisFilePath
                    gglobs.currentFileData = gglobs.hisFileData
                    self.dcfHis.setText(gglobs.currentFilePath)
                    self.dcfHis.setStyleSheet("QLineEdit { background-color: #F9F4C9; color: rgb(80,80,80); }")
                    self.dcfLog.setStyleSheet("QLineEdit { background-color: #DFDEDD; color: rgb(80,80,80); }")

            else:
                dprint(True, "PROGRAMMING ERROR in geigerlog:plotGraph: var current is:", current)
                sys.exit(1)

            if gglobs.currentFilePath == gglobs.hisFilePath:
                gglobs.varchecked = gglobs.varcheckedHis.copy()
            else:
                gglobs.varchecked = gglobs.varcheckedLog.copy()

            gglobs.allowGraphUpdate    = False
            for i, vname in enumerate(gglobs.varnames):
                value  = gglobs.varchecked[vname]   # bool
                #print("vname, values in gglobs.varchecked.items():", vname, value)
                self.vbox[vname].           setChecked(value)
                self.vbox[vname].           setEnabled(value)
                self.select.model().item(i).setEnabled(value)
            gglobs.allowGraphUpdate    = True

            self.print2NotePad(header("Plot Data"))
            self.print2NotePad("from: {}".format(gglobs.currentFilePath))

            self.figure.set_facecolor('#F9F4C9') # change color from gray to light yellow
            self.reset_replotGraph()

            break

        debugIndent(0)


    def changedGraphCountUnit(self, i):
        """counter unit Graph Options for left Y-axis was changed"""

        oldYunit            = gglobs.YunitCurrent
        gglobs.YunitCurrent = str(self.yunit.currentText())
        newYunit            = gglobs.YunitCurrent
        #print("changedGraphCountUnit: i:", i, ",  oldYunit:", oldYunit, ",  newYunit:", newYunit)

        # convert Y to CPM unit if not already CPM
        if oldYunit == "µSv/h":
            if gglobs.Ymin != None: gglobs.Ymin = gglobs.Ymin / gglobs.calibration
            if gglobs.Ymax != None: gglobs.Ymax = gglobs.Ymax / gglobs.calibration

        # convert Y to µSv/h unit if not already µSv/h
        if newYunit == "µSv/h":
            if gglobs.Ymin != None: gglobs.Ymin = gglobs.Ymin * gglobs.calibration
            if gglobs.Ymax != None: gglobs.Ymax = gglobs.Ymax * gglobs.calibration

        if gglobs.Ymin == None: self.ymin.setText("")
        else:                   self.ymin.setText("{:.5g}".format(gglobs.Ymin))

        if gglobs.Ymax == None: self.ymax.setText("")
        else:                   self.ymax.setText("{:.5g}".format(gglobs.Ymax))

        self.applyGraphOptions()


    def changedGraphTimeUnit(self, i):
        """recalc xmin, xmax on Time unit changes"""

        #print("changedGraphTimeUnit: i:", i)

        #if gglobs.logTime == None: return
        if np.all(gglobs.logTime) == None: return

        oldXunit = gglobs.XunitCurrent
        #print "oldXunit", oldXunit

        # convert all entries to days since start
        if   oldXunit == "Time":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft - gglobs.logTimeFirst
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright - gglobs.logTimeFirst

        elif oldXunit == "day": # no changes all in days
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright

        elif oldXunit == "hour":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft / 24.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright / 24.

        elif oldXunit == "minute":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft / 1440.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright / 1440.

        elif oldXunit == "second":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft / 86400.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright / 86400.

        gglobs.XunitCurrent = str(self.xunit.currentText())
        newXunit            = gglobs.XunitCurrent

        if newXunit == "auto":
            l = gglobs.logTime.max() - gglobs.logTime.min()
            #print "l=", l
            if   l > 3:          Xunit = "day"
            elif l * 24. > 3:    Xunit = "hour"
            elif l * 1440. > 3:  Xunit = "minute"
            else:                Xunit = "second"

            newXunit = Xunit

        gglobs.XunitCurrent = newXunit
        gglobs.Xunit        = newXunit
        #print "newXunit", newXunit

        if newXunit == "Time":
            if gglobs.Xleft  != None: gglobs.Xleft =  (str(mpld.num2date((gglobs.Xleft  + gglobs.logTimeFirst))))[:19]
            if gglobs.Xright != None: gglobs.Xright = (str(mpld.num2date((gglobs.Xright + gglobs.logTimeFirst))))[:19]

        elif newXunit == "day": # no changes all in days
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright

        elif newXunit == "hour":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft * 24.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright * 24.

        elif newXunit == "minute":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft * 1440.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright * 1440.

        elif newXunit == "second":
            if gglobs.Xleft  != None: gglobs.Xleft = gglobs.Xleft * 86400.
            if gglobs.Xright != None: gglobs.Xright = gglobs.Xright * 86400.

        if gglobs.Xleft == None:
            self.xmin.setText("")
        else:
            try:
                xl = "{:1.8f}".format(float(gglobs.Xleft))
            except:
                xl = gglobs.Xleft
            self.xmin.setText(xl)

        if gglobs.Xright == None:
            self.xmax.setText("")
        else:
            try:
                xr = "{:1.8f}".format(float(gglobs.Xright))
            except:
                xr = gglobs.Xright
            self.xmax.setText(xr)

        self.applyGraphOptions()


    def updatecursorposition(self, event):
        """when cursor inside plot, get position and print to statusbar"""
        # see: https://matplotlib.org/api/backend_bases_api.html#matplotlib.backend_bases.MouseEvent

        # calc based on:
        # gglobs.y1_limit = ax1.get_ylim    defined in gplot.py
        # gglobs.y2_limit = ax2.get_ylim

        if event.inaxes:
            x = event.xdata
            y2 = event.ydata
            #print x,y
            y1 = (y2 - gglobs.y2_limit[0]) / (gglobs.y2_limit[1] - gglobs.y2_limit[0]) * (gglobs.y1_limit[1] - gglobs.y1_limit[0]) + gglobs.y1_limit[0]

            if gglobs.Xunit == "Time":
                tod = (str(mpld.num2date(x)))[:19]          # time of day
                t   = gplot.getTsr(gglobs.logTimeFirst, x)

            else:
                tod = gplot.getToD(gglobs.logTimeFirst, x, gglobs.XunitCurrent)
                t   = "{:0.3f} {}s".format(x, gglobs.XunitCurrent)

            message = "Time since 1st record: {}, Time: {}, Counter: {:0.1f}, Ambient: {:0.1f}".format(t, tod, y1, y2)
            self.showStatusMessage(message, timing=0, error=False) # message remains until overwritten by next


    def onclick(self, event):
        """on mouseclick in graph enter time coords into xmin, xmax
        left click = xmin, right click = xmax"""

        if event.inaxes:
            x = event.xdata
            y = event.ydata
            b = event.button
            #print event, x,y,b

            if gglobs.Xunit == "Time":
                t = (str(mpld.num2date(x)))[:19]
            else:
                #t = str(x)
                t = "{:0.6f}".format(x)

            if b == 1:                  # left click, xmin
                self.xmin.setText(t)
            elif b == 3:                # right click, xmax
                self.xmax.setText(t)
            else:
                pass


#history
    def getHistory(self, source = "Binary File"):
        """getHistory either from binary file or from parsed file or from device"""

        if source == "Binary File":
            # there must be an existing '*.bin' file and must be allowed to write .lst, .his files
            dlg=QtGui.QFileDialog(caption = "Get History from existing Binary File")
            dlg.setFileMode(QtGui.QFileDialog.ExistingFile)
            dlg.setFilter("History Files (*.bin)")

        elif source == "Parsed File":
            # there must be an existing '*.his' file
            dlg=QtGui.QFileDialog(caption= "Get History from Parsed File")
            dlg.setFileMode(QtGui.QFileDialog.ExistingFile)
            dlg.setFilter("History Files (*.his)")

        else: # source is device
            if gglobs.logging:
                playMedia(error=True)
                lheader = header("Get History from Device")
                self.print2NotePad(lheader)
                fprint("Cannot load History when logging. Stop Logging first", error=True)
                return

            # may use existing or new file, but must be allowed to write new files (.bin, .lst, .his)
            dlg=QtGui.QFileDialog(caption = "Get History from Device - enter new filename or select from existing")
            dlg.setFileMode(QtGui.QFileDialog.AnyFile)
            dlg.setFilter("History Files (*.bin)")

        dlg.setViewMode     (QtGui.QFileDialog.Detail)
        dlg.setWindowIcon   (QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        dlg.setDirectory    (gglobs.fileDialogDir)


        if dlg.exec_() == QtGui.QDialog.Accepted:
            gglobs.fileDialogDir = dlg.directory().path()
            #print("fileDialogDir:", gglobs.fileDialogDir)

            fnames  = dlg.selectedFiles()
            fn      = str(fnames[0])
            #print "fn=", fn
            ext     = os.path.splitext(fn)[1]
            #print "extension=", ext
            fn_base     = os.path.splitext(fn)[0]
            #print "fn_base=", fn_base

            if ext not in  (".bin", ".his", "lst"):
                # if neither ext is given, attach ext to all 3 files
                gglobs.binFilePath = fn + ".bin"
                gglobs.lstFilePath = fn + ".lst"
                gglobs.hisFilePath = fn + ".his"
            else:
                # if either is given, assume basename for all 3 files
                gglobs.binFilePath = fn_base + ".bin"
                gglobs.lstFilePath = fn_base + ".lst"
                gglobs.hisFilePath = fn_base + ".his"
        else: # QtGui.QDialog.Rejected =    0
            return

        dprint(gglobs.debug, "gglobs.binFilePath:", gglobs.binFilePath)
        dprint(gglobs.debug, "gglobs.lstFilePath:", gglobs.lstFilePath)
        dprint(gglobs.debug, "gglobs.hisFilePath:", gglobs.hisFilePath)

        if source == "Binary File":

            lheader = header("Get History from Binary File")

            # Reading ok?
            if not os.access(gglobs.binFilePath, os.R_OK) :
                err_mesg = "Cannot read file - check permission of file: {}".format(gglobs.binFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing into directory ok?
            if not os.access(gglobs.dataPath,    os.W_OK) :
                err_mesg = "Cannot write files - check permission of directory: {}".format(gglobs.dataPath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing *.lst file ok?
            if os.path.isfile(gglobs.lstFilePath) and not os.access(gglobs.lstFilePath, os.W_OK) :
                err_mesg = "Cannot write file - check permission of file: {}".format(gglobs.lstFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing *.his file ok?
            if os.path.isfile(gglobs.hisFilePath) and not os.access(gglobs.hisFilePath, os.W_OK) :
                err_mesg = "Cannot write file - check permission of file: {}".format(gglobs.hisFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

        elif source == "Parsed File":
            lheader = header("Get History from Parsed File")
            if not os.access(gglobs.hisFilePath, os.R_OK) :
                err_mesg = "Cannot read file - check permission of file: {}".format(gglobs.hisFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            gglobs.currentFilePath = gglobs.hisFilePath
            gglobs.binFilePath = None
            gglobs.lstFilePath = None

        else:
            lheader = header("Get History from Device")
            if os.path.isfile(gglobs.binFilePath):
                msg = QtGui.QMessageBox()
                msg.setIcon(QtGui.QMessageBox.Critical)
                msg.setWindowTitle("CAUTION")
                critical  = """You selected an existing file, which will be <b>OVERWRITTEN</b> if you continue. Please confirm with OK.
<br><br>Otherwise click Cancel and enter a new filename in the Get History from Device dialog."""
                msg.setText(critical)
                msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
                msg.setDefaultButton(QtGui.QMessageBox.Cancel)
                msg.setEscapeButton(QtGui.QMessageBox.Cancel)
                retval = msg.exec_()

                if retval == 1024:
                    if not os.access(gglobs.binFilePath, os.W_OK):
                        err_mesg = "Cannot write file - check permission of file: " + gglobs.binFilePath
                        self.print2NotePad(lheader)
                        self.errprint2NotePad(err_mesg)
                        return
                else:
                    return

            # writing to directory ok?
            if not os.access(gglobs.dataPath,    os.W_OK) :
                err_mesg = "Cannot write files - check permission of directory: {}".format(gglobs.dataPath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing bin file ok?
            if os.path.isfile(gglobs.binFilePath) and not os.access(gglobs.binFilePath, os.W_OK) :
                err_mesg = "Cannot write file - check permission of file: {}".format(gglobs.binFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing lst file ok?
            if os.path.isfile(gglobs.lstFilePath) and not os.access(gglobs.lstFilePath, os.W_OK) :
                err_mesg = "Cannot write file - check permission of file: {}".format(gglobs.lstFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

            # writing his file ok?
            if os.path.isfile(gglobs.hisFilePath) and not os.access(gglobs.hisFilePath, os.W_OK) :
                err_mesg = "Cannot write file - check permission of file: {}".format(gglobs.hisFilePath)
                self.print2NotePad(lheader)
                self.errprint2NotePad(err_mesg)
                return

        self.print2NotePad(lheader)
        self.print2NotePad("History file basename: {}".format(os.path.splitext(gglobs.hisFilePath)[0]))

        dprint(gglobs.debug, "getHistory: history file basename:{} (*.bin, *.lst, *.his)".format(os.path.splitext(gglobs.hisFilePath)[0]))
        debugIndent(1)

        self.setBusyCursor()
        error, message = ghist.makeHIST(source, gglobs.binFilePath, gglobs.lstFilePath, gglobs.hisFilePath)
        self.setNormalCursor()

        if error == 0 or error == 1:
            gglobs.currentFilePath = gglobs.hisFilePath
            self.dcfHis.setText(gglobs.currentFilePath)
            gglobs.hisFileData     = self.getFileData()
            gglobs.varcheckedHis   = gglobs.varchecked.copy()
            gglobs.currentFileData = gglobs.hisFileData

            self.plotGraph("His")
            self.clearLogPad()
        else:
            self.errprint2NotePad(message)

        debugIndent(0)


    def myconverter(self, datestr):
        """datestring to number for numpy genfromtxt"""

        py3string_date = datestr.strip().decode("UTF-8") # required by Py3
        datenum = mpld.datestr2num(py3string_date)
        #print("datestr:", datestr, "datenum:", datenum)

        return datenum


    def getFileData(self):
        """
        read the data from currentFilePath into numpy array per numpy-genfromtxt,
        and create array with timestamp, CPM, CPS, CPM1st, CPM2nd
        may fail due to lack of data or encoding issues, hence try
        """

        # handling text files with encodings
        # http://python-notes.curiousefficiency.org/en/latest/python3/text_file_processing.html
        # mystring.decode('iso-8859-1').encode('utf8')
        # For Python 3: bytes(apple,'iso-8859-1').decode('utf-8')
        # Using encoding="latin-1" should NEVER give an exception:
        #   with open(gglobs.currentFilePath, "rt", encoding="latin-1") as cfghandle:
        #        llines = cfghandle.readlines()      # llines is list of lines

        start = time.time()
        self.setBusyCursor()

        if os.path.splitext(gglobs.currentFilePath)[1] == ".log": # is Log *.log file
            isLogFile = True
        else: # is History *.his file
            isLogFile = False

        with open(gglobs.currentFilePath, "rb") as cfghandle: # read BINARY
            llines = cfghandle.readlines()   # llines is list of lines of bytes
        #for i in range(10): print("llines[{}]: {}".format(i,llines[i]))

        datetimeCol    = 1 # DateTime
        errorflagIndex = False
        errorflagOther = False

# get the data using numpy
        # -- on numpy < 1.14 MUST use 'file', like:
        #    origFileData = np.genfromtxt(gglobs.currentFilePath, delimiter=",", converters = {1:self.myconverter})
        # -- on numpy >=1.14 can use 'list' of lines
        #    origFileData = np.genfromtxt(llines, delimiter=",", converters = {datetimeCol:self.myconverter})
        try:
            # get data from list of bytes, requiring numpy >=1.14
            origFileData = np.genfromtxt(llines, delimiter=",", converters = {datetimeCol:self.myconverter})

        except IndexError as e:
            # File is without data
            errorflagIndex = True
            srcinfo        = "getFileData: IndexError in np.genfromtxt"
            exceptPrint(e, sys.exc_info(), srcinfo)

        except Exception as e:
            # np.genfromtxt conversion has failed
            errorflagOther = True
            srcinfo        = "getFileData: unexpected ERROR in np.genfromtxt; check log for encoding issues"
            exceptPrint(e, sys.exc_info(), srcinfo)

        # Expected outcome of conversion with np.genfromtxt
        #
        # Example File:
        # Line1: #  Index,                DateTime,    CPM,    CPS, CPM1st, CPM2nd
        # Line2:        1, 2018-06-24 14:45:13.406,     28,      0,     28,     28
        # Line3:        2, 2018-06-24 14:45:16.405,     27,      0,     27,     27
        # Line4:        3, 2018-06-24 14:45:19.407,     23,      0,     23,     23
        #
        # case A:   file consisting of only the comment Line1, i.e. no data
        #           np.genfromtxt will raise an IndexError
        #
        # case B:   file consisting of Line1 and Line2, i.e. one comment, one data record
        #           np.genfromtxt produces this result:
        #           origFileData: [1.00000000e+00 7.36869615e+05 2.80000000e+01 0.00000000e+00 2.80000000e+01 2.80000000e+01]
        #           origFileData.shape: (6,)
        #           len(origFileData.shape): 1
        #           convert to array of arrays by using: new1 = np.array([origFileData]):
        #           origFileData: [[1.00000000e+00 7.36869615e+05 2.80000000e+01 0.00000000e+00 2.80000000e+01 2.80000000e+01]]
        #
        # case C:   file consisting of Line1, Line2, and Line3 or more lines, i.e. one comment, two or more data records
        #           origFileData: [[1.00000000e+00 7.36869615e+05 2.80000000e+01 0.00000000e+00  2.80000000e+01 2.80000000e+01]
        #                          [2.00000000e+00 7.36869615e+05 2.70000000e+01 0.00000000e+00  2.70000000e+01 2.70000000e+01]]
        #           origFileData.shape: (2, 6)
        #           len(origFileData.shape): 2
        #
        # case X:   error in np.genfromtxt; should only be possible due to encoding error

# create the data arrays
        try:
            if errorflagIndex:                                      # case A
                # create an empty array in the default shape
                datacols     = gglobs.datacolsDefault
                n            = 0
                cols         = 0
                dataArray    = np.empty([n, datacols])

                log_ok       = True
                for a in llines:
                    astrp = a.strip()
                    if astrp     == b""  : continue
                    if astrp[:1] != b'#' : # must be data if not starting with '#'
                        log_ok = False
                        break

                if log_ok:
                    loggingBlocked = False  # logging not blocked; no data in file
                else:
                    loggingBlocked = True  # logging blocked on error
                    msg = "ERROR: Cannot interpret logfile"

            elif errorflagOther:                                    # case X
                # create an empty array
                datacols     = gglobs.datacolsDefault
                n            = 0
                cols         = 0
                dataArray    = np.empty([n, datacols])
                loggingBlocked = True        # logging blocked on error
                msg = "ERROR: Cannot interpret logfile"

            else: # no error                                     # case B or case C
                #print("origFileData:", origFileData)
                #print("origFileData.shape:", origFileData.shape, ", len:", len(origFileData.shape))

                if len(origFileData.shape) == 1:                 # case B
                    # prepare for an array with one record
                    origFileData = np.array([origFileData])      # note the '[]'
                    #print("origFileData:", origFileData)
                    #print("origFileData.shape:", origFileData.shape, ", len:", len(origFileData.shape))
                    n            = origFileData.shape[0]
                    cols         = origFileData.shape[1]

                else:                                            # case C
                    # prepare for an array with two or more records
                    n            = origFileData.shape[0]
                    cols         = origFileData.shape[1]

                # fill the dataArray with the data from 5 columns:
                # datacols: index, datetime, cpm, cps, cpm1st, cpm2nd
                # if there aren't 5 columns create data from the existing columns
                # there must be at least 3 columns of data (index, DateTime, CPM)
                # like when file was produced from pre-0.9.8 version of GeigerLog

                # improper data file; must have at least 3 columns
                if cols < 3:
                    datacols              = gglobs.datacolsDefault
                    loggingBlocked = True        # block logging; not enough columns
                    msg = "INFO: File has only {} value columns, not a GeigerLog file".format(cols - 2)
                    dataArray             = np.empty([0, datacols]) # set data file to empty

                # assume a classic log file with the 3 values: index, DateTime, CPM
                # if CPM was recorded as 'CPS * 60', then a CPS data column may
                # be calculated from CPM and added as CPS. So we get either:
                #   2 data columns: datetime, cpm
                #   3 data columns: datetime, cpm, cps
                elif cols == 3:
                    # tests whether the file has been a CPS recording as opposed
                    # to a normal CPM recording. If CPS, then the data were stored
                    # as CPS*60. Therefore there should not be a remainder after
                    # dividing by 60.
                    # If a file was recorded in mixed CPS and CPM mode, it will
                    # be considered CPM mode
                    cpsfile = True
                    test    = origFileData[:, 2] / 60
                    #print("test: len:", len(test), test)
                    for i in range(0, len(test)):
                        if int(test[i]) == test[i] : # divisible w/o remainder?
                            continue
                        else:
                            cpsfile = False
                            break

                    if cpsfile:  # a file recorded as CPS, but stored as CPS*60
                        datacols              = 3
                        loggingBlocked = True        # block logging; is old-style logfile
                        msg = "INFO: File has only {} value columns".format(cols - 2)
                        dataArray           = np.empty([n, datacols])
                        dataArray[:, 0]     = origFileData[:, 1]          # DateTime
                        dataArray[:, 1]     = origFileData[:, 2]          # CPM
                        dataArray[:, 2]     = test                        # CPS derived from CPM

                    else:       # a file recorded as CPM (at least part of it) or a *.his file
                        datacols              = 2
                        loggingBlocked = True        # block logging; is old-style logfile
                        fn                    = gglobs.currentFilePath
                        #print("os.path.splitext(fn)[1]:", os.path.splitext(fn)[1])
                        if os.path.splitext(fn)[1] == ".his": # is History *.his file
                            pass
                        else:
                            msg = "INFO: File has only {} value columns".format(cols - 2)

                        dataArray           = np.empty([n, datacols])
                        dataArray[:, 0]     = origFileData[:, 1]          # DateTime
                        dataArray[:, 1]     = origFileData[:, 2]          # CPM

                # assume a log file with at least 4 columns: index, DateTime, CPM, CPS
                elif cols >= 4 :
                    datacols              = cols - 1
                    if datacols < 11:
                        loggingBlocked = True  # block logging; not suited for new format
                        msg = "INFO: File has only {} value columns".format(cols - 2)
                    else:
                        loggingBlocked = False
                        msg = "INFO: File has full complement of data columns"

                    dataArray             = np.empty([n, datacols])
                    for i in range(0, datacols):
                        dataArray[:, i]       = origFileData[:, i + 1]


                if loggingBlocked:
                    if isLogFile:
                        fprint(msg, error=True)
                        dprint(gglobs.debug, msg, ", Cols: ", cols)
                        fprint("INFO: Cannot log into this file", error=True)
                else:
                    fprint(msg, error=False)
                    dprint(gglobs.debug, msg, ", Cols: ", cols)
                    fprint("INFO: Can log into this file", error=False)


                # prevent updating while selections are made
                gglobs.allowGraphUpdate    = False

                # first, clear all settings
                for i, key in enumerate(gglobs.varnames):
                    gglobs.varchecked[key]      = False
                    gglobs.ex.vbox[key]         .setChecked(False)
                    gglobs.ex.vbox[key]         .setEnabled(False)
                    self.select.model().item(i) .setEnabled(False)

                # second, set all except time
                for i in range(1, datacols): # all except time
                    #print("New Settings: i:", i, self.select, type(self.select))
                    vname = gglobs.varnames[i - 1]
                    for a in dataArray[:, i]:
                        if not np.isnan(a):
                            #print("i:", i, a, type(a))
                            gglobs.varchecked   [vname]     = True
                            gglobs.ex.vbox      [vname]     .setChecked(True)
                            gglobs.ex.vbox      [vname]     .setEnabled(True)
                            self.select.model().item(i - 1) .setEnabled(True)
                        #    break # ??? what for???

                gglobs.allowGraphUpdate    = True

        except Exception as e:
            # dataarray filling has failed
            errorflag = True
            srcinfo   = "getFileData: ERROR filling dataarray; check log for encoding issues"
            exceptPrint(e, sys.exc_info(), srcinfo)

            datacols         = 9
            loggingBlocked   = True                     # logging allowed
            dataArray        = np.empty([0, datacols])

            fprint("ERROR: Cannot read Logfile; cannot show data and cannot log into this file", error=True)
            fprint("ERROR: Logfile may have wrong or missing DateTime column at position 2", error=True)

        if isLogFile:  # not relevant for history files, as they are blocked anyway
            gglobs.loggingBlocked   = loggingBlocked

        #print( "getFileData: dataArray:\n", dataArray)
        gglobs.varlabels        = {}                       # clear labels for legend
        resetVars()                                        # setting all data arrays back to start condition

        self.setNormalCursor()
        dprint(gglobs.debug,   "getFileData: created data array from {} records with {} values each".format(n, cols))
        vprint(gglobs.verbose, "getFileData: {:6.1f}ms file loading and parsing into numpy array, " .format((time.time() - start) * 1000.))

        return dataArray


    def showHistBinExcerpt(self):

        if gglobs.lstFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Excerpt of History Bin Data"))
        self.print2NotePad("from: {}\n".format(gglobs.lstFilePath))
        self.printExcerptLines(gglobs.lstFilePath)


    def showHistExcerpt(self):

        if gglobs.hisFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Excerpt of History Data"))
        self.print2NotePad("from: {}\n".format(gglobs.hisFilePath))
        self.printExcerptLines(gglobs.hisFilePath)


    def showHistHisData(self):
        """print HIST parsed data"""

        if gglobs.hisFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Parsed History Data"))
        self.print2NotePad("from: {}\n".format(gglobs.hisFilePath))

        self.setBusyCursor()
        data = readFileLines(gglobs.hisFilePath)
        gglobs.stopPrinting = False
        for a in data:
            self.print2NotePad(a[:-1])
            if gglobs.stopPrinting: break
        gglobs.stopPrinting = False
        self.setNormalCursor()


    def showHistHisTags(self):
        """print comments only from HIST parsed data"""

        if gglobs.hisFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Parsed History Tags and Comments"))
        self.print2NotePad("from: {}\n".format(gglobs.hisFilePath))

        self.setBusyCursor()
        data = readFileLines(gglobs.hisFilePath)
        for a in data:
            if a[0] == '#':
                self.print2NotePad(a[:-1])
        self.setNormalCursor()


    def showHistBinData(self):
        """print HIST binary data in human readable form:'bytenumber: hex = dec'"""

        if gglobs.lstFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Binary History Data"))
        self.print2NotePad("from: {}\n".format(gglobs.lstFilePath))

        self.setBusyCursor()
        gglobs.stopPrinting = False
        data = readFileLines(gglobs.lstFilePath)
        for a in data:
            self.print2NotePad(a[:-1])
            if gglobs.stopPrinting: break

        gglobs.stopPrinting = False
        self.setNormalCursor()


    def printExcerptLines(self, path, lmax = 15):
        """print first and last lines of the file"""

        if path == None:
            self.showStatusMessage("No file available")
            return

        self.setBusyCursor()

        lines_all = readFileLines(path)
        lenall    = len(lines_all)

        if "ERROR" in lines_all[0][:6]:  # error message instead of data
            self.print2NotePad(lines_all[0])
            return

        if   lenall == 0:
            self.print2NotePad("No records")

        elif lenall < 30:
            for i in range(0, lenall):
                self.print2NotePad(lines_all[i][:-1])  # omit the closing '/n'

        else:
            for a in lines_all[0:lmax]:
                self.print2NotePad(a[:-1]) # omit the closing '/n'

            self.print2NotePad("     ...")

            for a in lines_all[-lmax:]:
                self.print2NotePad(a[:-1])

        self.setNormalCursor()

        return

        recs_found = False
        for i in range(0, len(lines_all)):
            if lines_all[i][0] != "#": # any records other than comments?
                recs_found = True
                break

        if recs_found :
            for i in lines_all[0:lmax]:
                self.print2NotePad(i[:-1]) # omit the closing '/n'


            if len(lines_all) > lmax:
                self.print2NotePad("...")
                for i in lines_all[-lmax:]:
                    self.print2NotePad(i[:-1])
        else:
            self.print2NotePad("No records")

        self.setNormalCursor()


    def setLogTimings(self):
        """Set logcycle"""

        dprint(gglobs.debug, "setLogTimings:")
        debugIndent(1)

        lctime     = QtGui.QLabel("Log Cycle [s]\n(at least 0.1s)")
        lctime.setAlignment(QtCore.Qt.AlignLeft)

        self.ctime  = QtGui.QLineEdit()
        validator = QtGui.QDoubleValidator(0.1, 9999, 1, self.ctime)
        self.ctime.setValidator(validator)
        self.ctime.setToolTip('The logging cycle in seconds')
        self.ctime.setText("{:0.3g}".format(gglobs.logcycle))

        graphOptions=QtGui.QGridLayout()
        graphOptions.addWidget(lctime,                  0, 0)
        graphOptions.addWidget(self.ctime,              0, 1)

        graphOptionsGroup = QtGui.QGroupBox()
        graphOptionsGroup.setLayout(graphOptions)

        d = QtGui.QDialog(self) # set parent self to popup in center of geigerlog window
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        d.setFont(self.fontstd)
        d.setWindowTitle("Set Log Timings")
        d.setWindowModality(QtCore.Qt.ApplicationModal)
        #d.setWindowModality(QtCore.Qt.NonModal)
        #d.setWindowModality(QtCore.Qt.WindowModal)

        self.bbox = QtGui.QDialogButtonBox()
        self.bbox.setStandardButtons(QtGui.QDialogButtonBox.Cancel | QtGui.QDialogButtonBox.Ok )
        self.bbox.accepted.connect(lambda: d.done(0))
        self.bbox.rejected.connect(lambda: d.done(99))

        gglobs.btn = self.bbox.button(QtGui.QDialogButtonBox.Ok)
        gglobs.btn.setEnabled(True)

        layoutV = QtGui.QVBoxLayout(d)
        layoutV.addWidget(graphOptionsGroup)
        layoutV.addWidget(self.bbox)

        self.ctime.textChanged.connect(self.check_state) # last chance
        self.ctime.textChanged.emit   (self.ctime.text())

        if gglobs.logging:
            gglobs.btn.setEnabled(False)
            self.ctime.setEnabled(False)
            self.ctime.setStyleSheet('QLineEdit { background-color: %s;  }' % ("#e0e0e0",))
            #for key in gglobs.varnames:
            #    self.sLbox[key].setEnabled  (False)

        retval = d.exec_()
        #print("reval:", retval)

        if retval == 99:
            dprint(gglobs.debug, "setLogTimings: Escape, cycle time unchanged: ", gglobs.logcycle)
        else:
            # change the cycle time
            oldlogcycle = gglobs.logcycle
            logcycle    = self.ctime.text().replace(",", ".")  #replace comma with dot
            try:    lc  = round(float(logcycle), 1)
            except: lc  = oldlogcycle

            gglobs.logcycle = lc
            self.showTimingSetting(gglobs.logcycle)
            dprint(gglobs.debug, "setLogTimings: ok, new cycle time: ", gglobs.logcycle)

        debugIndent(0)


    def check_state(self, *args, **kwargs):
        sender = self.sender()

        #print("sender.text():", sender.text())
        #print("args:", args)
        #print("kwargs:", kwargs)

        try:
            v = float(sender.text().replace(",", "."))
            if v < 0.1:
                state = 0       # too low
            else:
                state = 2       # ok
        except:
            state = 0           # wrong

        #print("QtGui.QValidator.Acceptable:", QtGui.QValidator.Acceptable)

        # Value: QtGui.QValidator.Acceptable == 2
        if state == QtGui.QValidator.Acceptable:
            #bgcolor = '#c4df9b' # green
            bgcolor = 'white' # white
            color   = 'black'
            gglobs.btn.setEnabled(True)
        #elif state == QtGui.QValidator.Intermediate:
        #    color = '#fff79a' # yellow
        else:
            bgcolor = '#f6989d' # red
            bgcolor = '#fff79a' # yellow
            color   = 'red'
            self.ctime.setFocus()
            gglobs.btn.setEnabled(False)

        sender.setStyleSheet('QLineEdit { background-color: %s; color: %s }' % (bgcolor, color))


#logging
    def startTimer(self):
        """Starts the logging"""

        dprint(gglobs.debug, "startTimer:")
        debugIndent(1)

        self.print2NotePad(header("Start Logging"))

        while True:

            # None of the devices is connected
            if gglobs.ser == None and gglobs.client == None:
                self.errprint2NotePad("ALERT: Cannot log; no connected device")
                break

            # A logfile is not loaded
            if gglobs.logFilePath == None:
                self.errprint2NotePad("ALERT: Cannot log; Logfile is not loaded")
                break

            # Logfile is not writeable
            if not os.access(gglobs.logFilePath, os.W_OK):
                # cannot write to file
                self.errprint2NotePad("ALERT: Cannot log; Logfile is not available for writing!")
                break

            # Logfile is blocked for writing (old version?)
            if gglobs.loggingBlocked == True:
                self.errprint2NotePad("ALERT: Cannot log; Logfile is blocked for writing!")
                break

            # can log to GMC
            if gglobs.ser       != None:
                devGMC = True
                devGMCtext = gglobs.deviceDetected
                if gcommands.isPowerOn() == "OFF":
                    self.errprint2NotePad("ALERT: Cannot log using GMC device; Power is switched OFF")
                    devGMC = False
                    devGMCtext = "N.A."

                elif gcommands.isPowerOn() != "ON":
                    self.errprint2NotePad("ALERT: Cannot determine power state of GMC device; it may be switched OFF; observe logging output")
                    devGMC = True

            # can NOT log to GMC
            else:
                self.errprint2NotePad("ALERT: Cannot log using GMC device; device not connected")
                devGMCtext = "N.A."
                devGMC = False

            # can log to RM
            if gglobs.client    != None:
                devRM       = True
                devRMtext   = gglobs.RMdevice

            # can NOT log to RM
            else:
                self.errprint2NotePad("ALERT: Cannot log using RadMon device; device not connected")
                devRM       = False
                devRMtext   = "N.A."

            # can NOT log to either device
            if devGMC == False and devRM == False:
                self.errprint2NotePad("ALERT: Cannot log; neither device allows logging")
                break

            resetVarSettings()

            # inactivate all vars which cannot be logged
            for a in ("T", "P", "H", "R"):
                if devRM  == False:
                    gglobs.varlog[a] = False
                else:
                    gglobs.varlog[a] = gglobs.vardevice[a]
            #print("nach RM: varlog:", gglobs.varlog)

            for a in ("CPM", "CPS", "CPM1st", "CPM2nd", "CPS1st", "CPS2nd"):
                if devGMC == False:
                    gglobs.varlog[a] = False
                else:
                    gglobs.varlog[a] = gglobs.vardevice[a]
            #print("nach GMC: varlog:", gglobs.varlog)

            logvars = ""
            for key in gglobs.varnames:
                if gglobs.varlog[key]: logvars += key + ", " # remove last 2 chars!

            w1  = "#LOGGING, {}, Start: Log cycle: {} sec, Log variables: {}"    .format(stime(), gglobs.logcycle, logvars[:-2])
            #w1a = "#LOGGING, {}, Log variables: {}"             .format(stime(), )
            w2  = "#LOGGING, {}, Connected GMC Device:    '{}'" .format(stime(), devGMCtext)
            w2a = "#LOGGING, {}, Connected RadMon Device: '{}'" .format(stime(), devRMtext)
            #for a in (w1, w1a, w2, w2a):
            for a in (w1, w2, w2a):
                writeFileA          (gglobs.logFilePath,   a)
                self.print2LogPad   (a)
                self.print2NotePad  (a)

            dprint(gglobs.debug, "startTimer: Cleaning pipeline before logging")
            gcommands.getExtraByte()

            self.timer.start(gglobs.logcycle * 1000.0) # timer time is in ms; logcycle in sec
            dprint(gglobs.debug, "startTimer: Logging now; Timer is started with cycle {} sec.".format(gglobs.logcycle))
            gglobs.logging              = True
            gglobs.cpm_counter          = 0
            gglobs.currentFilePath      = gglobs.logFilePath

            self.checkLoggingState()
            gglobs.lastValues = None    # reset
            self.getLogValue()  # first call now; timer fires only AFTER 1st period!

            break

        #print("bei exit starttimer: varlog:", gglobs.varlog)
        debugIndent(0)


    def stopTimer(self):
        """Stops the logging"""

        dprint(gglobs.debug, "stopTimer:")
        debugIndent(1)

        self.print2NotePad(header("Stop Logging"))
        self.timer.stop()
        gglobs.logging = False

        writestring  = "#LOGGING,{}, Stop".format(stime())
        writeFileA(gglobs.logFilePath, writestring)
        self.print2LogPad(writestring)
        self.print2NotePad(writestring)

        dprint(gglobs.debug, "stopTimer: Cleaning pipeline after logging")
        gcommands.getExtraByte()

        self.checkLoggingState()
        self.labelVar.setStyleSheet('color:darkgray;')

        dprint(gglobs.debug, "stopTimer: Logging is stopped")
        debugIndent(0)


    def getLogValue(self):
        """
        Reads variables CPM, CPS, CPM1st, CPM2nd, Temperature, Pressure, Humidity
        and R from devices, saves it in log file, and prints record into LogPad.
        Called by the timer once the timer is started
        """
        #print( "currentFilePath",       gglobs.currentFilePath)
        #print("logFileData:",           gglobs.logFileData)
        #print("logFileData.shape:",     gglobs.logFileData.shape)

        if not gglobs.logging:          return
        if gglobs.logFilePath == None:  return

        vprint(gglobs.verbose, "getLogValues: and save to:", gglobs.logFilePath)
        debugIndent(1)

        timetag  = stime()                              # DateTime: '2018-07-14 12:00:52.251'
        lv       = {}                                   # logvalue dict
        nulldata = (gglobs.NAN, 0, "")                  # default
        for a in gglobs.varnames: lv[a] = nulldata      # set all to default

        # set the variables to log
        varnames_list = []
        for a in gglobs.varnames:
            if gglobs.varlog[a]:   varnames_list.append(a)
        #print("varnames_list:",varnames_list)

        # get the values
        for a in varnames_list:
            #print("a:",a)
            if   a == "CPM":    lv[a]   = gcommands.getCPM()   # counts per MINUTE
            elif a == "CPS":    lv[a]   = gcommands.getCPS()   # counts per SECOND

            elif a == "CPM1st": lv[a]   = gcommands.getCPML()  # CPM from 1st tube, normal tube
            elif a == "CPM2nd": lv[a]   = gcommands.getCPMH()  # CPM from 2nd tube, extra tube

            elif a == "CPS1st": lv[a]   = gcommands.getCPSL()  # CPS from 1st tube, normal tube
            elif a == "CPS2nd": lv[a]   = gcommands.getCPSH()  # CPS from 2nd tube, extra tube

            else:               lv[a]   = gradmon.getRadMonData(a) # RadMon data
        #print("getLogValue: lv: ", lv)

        # create the printstring
        # timetag: use time only  '2018-07-14 12:00:52' --> '12:00:52'
        #printstring = "{:0.7g} {:8s} " .format(gglobs.cpm_counter, timetag[11:])
        printstring = "{:2.7g} {:8s} " .format(gglobs.cpm_counter, timetag[11:])
        for vname in gglobs.varnames:
            #print("vname: ", vname, lv[vname], lv[vname][0])
            printstring += "  {}=".format(gglobs.vardictshort[vname])
            if np.isnan(lv[vname][0]):  pass
            else:                       printstring += "{}".format(lv[vname][0])

        # create the writestring
        writestring = " {:7d}, {:19s}" .format(gglobs.cpm_counter, timetag)
        nanOnly     = True
        for a in gglobs.varnames:
            #print("a::", a, type(a))
            if np.isnan(lv[a][0]):
                writestring += ",         "
            else:
                writestring += ", {:8.8g}".format(lv[a][0])
                nanOnly      = False

        # write to log, print to logpad
        #w3  = "#  Index,            DateTime,     CPM,     CPS,  CPM1st,  CPM2nd,  CPS1st,  CPS2nd,    Temp,   Press,   Humid,   RMCPM"
        w3  = "#  Index,            DateTime,      CPM,      CPS,   CPM1st,   CPM2nd,   CPS1st,   CPS2nd,     Temp,    Press,    Humid,    RMCPM"
        #if (gglobs.cpm_counter % 100) == 0 :    writeFileA(gglobs.logFilePath, w3)
        if gglobs.cpm_counter == 0 :        writeFileA(gglobs.logFilePath, w3) # only once
        if not nanOnly:                     writeFileA(gglobs.logFilePath, writestring)
        self.print2LogPad(printstring)

        # update the logFileData array
        if not nanOnly:
            gglobs.logFileData = np.append(gglobs.logFileData, [[mpld.datestr2num(timetag), lv["CPM"][0], lv["CPS"][0], lv["CPM1st"][0], lv["CPM2nd"][0], lv["CPS1st"][0], lv["CPS2nd"][0], lv["T"][0], lv["P"][0], lv["H"][0], lv["R"][0]]], axis=0)

        # update the lastValues, lastRecord and CountLabel
        if gglobs.lastValues == None:
            gglobs.lastValues = lv      # only after start
        else:
            for a in lv:
                if not np.isnan(lv[a][0]):          # update only when new
                    gglobs.lastValues[a] = lv[a]    # value  is not nan
        #print("gglobs.lastValues:",gglobs.lastValues)

        gglobs.lastRecord   = printstring

        self.updateCountLabel()

        # update graph - only if it is the current one!
        if gglobs.currentFilePath == gglobs.logFilePath:
            gglobs.currentFileData  = gglobs.logFileData

            # for now ALWAYS do a full plot, not just an update
            if True or (gglobs.cpm_counter < 10 and gglobs.sizePlotSlice < 10) or (gglobs.cpm_counter % 10 == 0):
                gplot.makePlot()
                #print("getLogValue: nach makeplt: varlog:", gglobs.varlog)
            else:
                gplot.updatePlot(gglobs.logFilePath, timetag, cpm)

        gglobs.cpm_counter   += 1

        debugIndent(0)


    def showTimingSetting(self, logcycle):
        """update the Timings shown under Data"""

        self.dcycl.setText("Cycle: {:0.3g} s".format(logcycle))


    def updateCountLabel(self):
        """update the variable value displayed in the Graph area"""

        if gglobs.lastValues == None:
            self.labelVar.setText(" --- ")
            self.labelVar.setToolTip("Shows Last Values when logging")
            self.labelVar.setStatusTip("Shows Last Values when logging")
            return

        # when logging with black on yellow background, else with dark.grey on grey
        if gglobs.logging: self.labelVar.setStyleSheet('color: black; background-color: #F4D345;')

        selVar    = self.select.currentText()         # selected variable
        selUnit1  = self.yunit .currentText()
        selUnit2  = self.y2unit.currentText()
        varText   = " --- "
        statusTip = ""

        if gglobs.calibration    == "auto":  scale1st = gglobs.DEFcalibration
        else:                                scale1st = gglobs.calibration

        if gglobs.calibration2nd == "auto":  scale2nd = gglobs.DEFcalibration2nd
        else:                                scale2nd = gglobs.calibration2nd

        if gglobs.RMcalibration  == "auto":  scaleRM  = gglobs.DEFRMcalibration
        else:                                scaleRM  = gglobs.RMcalibration

        #print("scale1st:", scale1st)
        #print("scale2nd:", scale2nd)
        #print("scaleRM:" , scaleRM)

        while True:
            if   selVar == "CPM":
                value    = gglobs.lastValues["CPM"][0]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText ="{:0.0f} CPM".format(value)
                else:
                    varText = "{:0.1f} µSv/h".format(value * scale1st)

                statusTip  = "{:0.0f} CPM"     .format(value)
                statusTip += " = {:0.1f} CPS"  .format(value / 60)
                statusTip += " = {:0.1f} µSv/h".format(value * scale1st)
                statusTip += " = {:0.0f} mSv/a".format(value * scale1st / 1000 * 24 * 365.25)

            elif selVar == "CPS":
                value    = gglobs.lastValues["CPS"][0]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.0f} CPS".format(value)
                else:
                    varText = "{:0.1f} µSv/h".format(value * 60 * scale1st)

                statusTip  = "{:0.0f} CPS"     .format(value)
                statusTip += " = {:0.1f} CPM"  .format(value * 60)
                statusTip += " = {:0.1f} µSv/h".format(value * 60 * scale1st)
                statusTip += " = {:0.0f} mSv/a".format(value * 60 * scale1st / 1000 * 24 * 365.25)

            elif selVar == "CPM1st":
                value    = gglobs.lastValues["CPM1st"][0]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.0f} CPM".format(value)
                else:
                    varText = "{:0.1f} µSv/h".format(value * scale1st)

                statusTip  = "{:0.0f} CPM"     .format(value)
                statusTip += " = {:0.1f} CPS"  .format(value / 60)
                statusTip += " = {:0.1f} µSv/h".format(value * scale1st)
                statusTip += " = {:0.0f} mSv/a".format(value * scale1st / 1000 * 24 * 365.25)

            elif selVar == "CPM2nd":
                value    = gglobs.lastValues["CPM2nd"][0]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.0f} CPM".format(value)
                else:
                    varText = "{:0.1f} µSv/h".format(value * scale2nd)

                statusTip  = "{:0.0f} CPM"     .format(value)
                statusTip += " = {:0.1f} CPS"  .format(value / 60)
                statusTip += " = {:0.1f} µSv/h".format(value * scale2nd)
                statusTip += " = {:0.0f} mSv/a".format(value * scale2nd / 1000 * 24 * 365.25)

            elif selVar == "CPS1st":
                value    = gglobs.lastValues["CPS1st"][0]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.0f} CPS".format(value)
                else:
                    varText = "{:0.1f} µSv/h".format(value * scale1st)

                statusTip  = "{:0.0f} CPS"     .format(value)
                statusTip += " = {:0.1f} CPM"  .format(value * 60)
                statusTip += " = {:0.1f} µSv/h".format(value * 60 * scale1st)
                statusTip += " = {:0.0f} mSv/a".format(value * 60 * scale1st / 1000 * 24 * 365.25)

            elif selVar == "CPS2nd":
                value    = gglobs.lastValues["CPS2nd"][0]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.0f} CPM".format(value)
                else:
                    varText = "{:0.1f} µSv/h".format(value * scale2nd)

                statusTip  = "{:0.0f} CPS"     .format(value)
                statusTip += " = {:0.1f} CPM"  .format(value * 60)
                statusTip += " = {:0.1f} µSv/h".format(value * 60 * scale2nd)
                statusTip += " = {:0.0f} mSv/a".format(value * 60 * scale2nd / 1000 * 24 * 365.25)

            elif selVar == "Temperature":
                value    = gglobs.lastValues["T"][0]
                if np.isnan(value):   break

                if selUnit2 == "°C":
                    varText = "{:0.1f} °C".format(value)
                else:
                    varText = "{:0.1f} °F".format(value / 5 * 9 + 32)

                statusTip  = "{:0.1f} °C"     .format(value)
                statusTip += " = {:0.1f} °F"  .format(value / 5 * 9 + 32)

            elif selVar == "Pressure":
                value    = gglobs.lastValues["P"][0]
                if np.isnan(value):   break

                varText = "{:0.1f} hPa".format(value)

                statusTip  = "{:0.1f} hPa"     .format(value)
                statusTip += " = {:0.1f} mbar"  .format(value)

            elif selVar == "Humidity":
                value       = gglobs.lastValues["H"][0]
                if np.isnan(value):   break
                varText    = "{:0.1f} %".format(value)
                statusTip  = "{:0.1f} %"  .format(value)

            elif selVar == "RadMon CPM":
                value    = gglobs.lastValues["R"][0]
                if np.isnan(value):   break

                if selUnit1 == "CPM":
                    varText = "{:0.0f} CPM".format(value)
                else:
                    varText = "{:0.1f} µSv/h".format(value * scaleRM)

                statusTip  = "{:0.0f} CPM"     .format(value)
                statusTip += " = {:0.1f} CPS"  .format(value / 60)
                statusTip += " = {:0.1f} µSv/h".format(value * scaleRM)
                statusTip += " = {:0.0f} mSv/a".format(value * scaleRM / 1000 * 24 * 365.25)

            break

        self.labelVar.setText(varText)
        self.labelVar.setToolTip(statusTip)
        self.labelVar.setStatusTip(statusTip)


    def quickLog(self):
        """Reads CPM or CPS from device and displays in Toolbar
        Called by the timer, once the timer is started"""

        dprint(gglobs.debug, "quickLog:")
        debugIndent(1)

        self.print2NotePad(header("Quick Log"))
        self.clearLogPad()

        gglobs.logFilePath      = os.path.join(gglobs.dataPath, "default.log")
        gglobs.currentFilePath  = gglobs.logFilePath
        dprint(gglobs.debug, "quickLog: filename:", gglobs.logFilePath)

        line = "#HEADER , using Quick Log file: default.log"
        self.print2LogPad(line)
        writeFileW(gglobs.logFilePath, line)

        gglobs.currentFilePath = gglobs.logFilePath
        self.print2NotePad("Logfile: {}".format(gglobs.currentFilePath))

        gglobs.loggingBlocked   = False
        gglobs.logFileData      = np.empty([0, gglobs.datacolsDefault])
        gglobs.currentFileData  = gglobs.logFileData

#        for vname in gglobs.varnames: gglobs.varchecked[vname] = True # new file, will have all columns
        resetVarSettings()
        gglobs.varcheckedLog = gglobs.varchecked.copy()

        gglobs.lastValues = None
        self.plotGraph("Log")

        self.checkLoggingState()
        self.showTimingSetting(gglobs.logcycle)
        self.startTimer()

        debugIndent(0)


    def getLogFile(self, defaultFile = False):
        """Load existing file for logging, or create new one"""

        if defaultFile == False:    df = "None provided"
        else:                       df = defaultFile
        dprint(gglobs.debug, "getLogFile: defaultFile: '{}'".format(df))
        debugIndent(1)

        if defaultFile == False:
            dlg=QtGui.QFileDialog(caption= "Get Log File - enter new filename or select from existing")
            dlg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
            dlg.setFileMode(QtGui.QFileDialog.AnyFile)
            dlg.setViewMode(QtGui.QFileDialog.Detail)
            dlg.setFilter("Logging Files (*.log)")
            dlg.setDirectory(gglobs.fileDialogDir)
            #print("gglobs.fileDialogDir:", gglobs.fileDialogDir)

            if dlg.exec_() == QtGui.QDialog.Accepted: # (=1)
                #print("dlg.directory():", dlg.directory())
                #print("dlg.directory().path():", dlg.directory().path())
                gglobs.fileDialogDir = dlg.directory().path()

                fnames  = dlg.selectedFiles()
                fn      = str(fnames[0])
                ext     = os.path.splitext(fn)[1]
                if ext != ".log":  fn += ".log"      # forces the ".log" extension

            else: # QtGui.QDialog.Rejected (= 0)
                dprint(gglobs.debug, "getLogFile: FileDialog Escape")
                debugIndent(0)
                return

            if os.path.isfile(fn):
                msg = QtGui.QMessageBox()
                msg.setIcon(QtGui.QMessageBox.Warning)
                msg.setWindowTitle("CAUTION")
                critical  = """You selected an existing file, which will be modified \
    when logging by <b>APPENDING</b> new data to it. Please confirm with OK.
    <br><br>Otherwise click Cancel and enter a new filename in the Get Log File dialog."""
                msg.setText(critical)
                msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
                msg.setDefaultButton(QtGui.QMessageBox.Cancel)
                msg.setEscapeButton(QtGui.QMessageBox.Cancel)
                retval = msg.exec_()

                if retval != 1024:
                    dprint(gglobs.debug, "getLogFile: Existing File Escape")
                    debugIndent(0)
                    return

            gglobs.logFilePath = fn
        else:
            gglobs.logFilePath = defaultFile

        if gglobs.logging:   self.stopTimer()

        gglobs.currentFilePath  = gglobs.logFilePath
        self.dcfLog.setText(gglobs.currentFilePath)

        self.print2NotePad(header("Get Logfile"))
        self.print2NotePad("Logfile: {}".format(gglobs.currentFilePath))
        dprint(gglobs.debug, "getLogFile: log filename:", gglobs.currentFilePath)
        self.clearLogPad()

        if not os.path.isfile(gglobs.logFilePath):
            # File does not exist; create new one
            self.print2NotePad("Logfile newly created - available for writing")
            line = "#HEADER , {}, Logfile newly created as '{}'".format(stime(), os.path.basename(gglobs.logFilePath))
            self.print2LogPad(line)
            writeFileW(gglobs.logFilePath, line)

            # data array for the variables
            gglobs.logFileData = np.empty([0, gglobs.datacolsDefault])
            resetVarSettings()

            gglobs.loggingBlocked = False                # block only if file is read-only

        else:
            # File does exist
            if os.access(gglobs.logFilePath, os.W_OK):
                # can read and write
                self.print2NotePad("Logfile opened - available for writing")
                gglobs.loggingBlocked = False # block only if file is read-only

            elif os.access(gglobs.logFilePath, os.R_OK):
                # can read only
                self.errprint2NotePad("Logfile opened - ALERT: available ONLY FOR READING")
                gglobs.loggingBlocked = True  # block if file is read-only

            gglobs.logFileData   = self.getFileData()

        gglobs.varcheckedLog = gglobs.varchecked.copy()

        gglobs.currentFileData  = gglobs.logFileData
        gglobs.lastValues = None

        self.plotGraph("Log")
        self.checkLoggingState()

        debugIndent(0)


    def addComment(self):
        """Adds a comment in the current log file"""

        d = QtGui.QInputDialog()
        info = "Enter your comment:" + " "*100
        text, ok = d.getText(self, 'Add a Comment', info)
        text = str(text)

        if ok:
            line = "#COMMENT, {}, {}".format(stime(), text)
            self.print2LogPad(line)
            writeFileA(gglobs.logFilePath, line)

        vprint(gglobs.verbose, "Add a Comment:", "text=", text, ",  ok=", ok)


    def showLogData(self):
        """ print logged data to notepad"""

        if gglobs.logFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Log Data"))
        self.print2NotePad("from: {}\n".format(gglobs.logFilePath))

        self.setBusyCursor()
        data = readFileLines(gglobs.logFilePath)
        gglobs.stopPrinting = False
        for a in data:
            self.print2NotePad(a[:-1]) # remove \n at end
            if gglobs.stopPrinting: break
        gglobs.stopPrinting = False

        self.setNormalCursor()


    def showLogTags(self):
        """print comments only from log data"""

        if gglobs.logFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Log Comments"))
        self.print2NotePad("from: {}\n".format(gglobs.logFilePath))

        self.setBusyCursor()
        data = readFileLines(gglobs.logFilePath)
        for a in data:
            if a[0] == '#':
                self.print2NotePad(a[:-1]) # remove \n at end
        self.setNormalCursor()


    def showLogDataExcerpt(self):
        """show first and last lmax lines of the log file"""

        if gglobs.logFilePath == None:
            self.showStatusMessage("No file available")
            return

        self.print2NotePad(header("Show Log Data Excerpt"))
        self.print2NotePad("from: {}\n".format(gglobs.logFilePath))

        self.setBusyCursor()
        self.printExcerptLines(gglobs.logFilePath)
        self.setNormalCursor()

#device
    def doREBOOT(self):
        """reboot the device"""

        msg = QtGui.QMessageBox()
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setIcon(QtGui.QMessageBox.Warning)
        msg.setWindowTitle("Reboot Device")
        msg.setText("Rebooting your device.\nPlease confirm with OK, or Cancel")
        msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
        msg.setDefaultButton(QtGui.QMessageBox.Cancel)
        msg.setEscapeButton(QtGui.QMessageBox.Cancel)
        retval = msg.exec_()

        if retval != 1024:   return

        self.print2NotePad(header("Device Reboot"))
        rec, err, errmessage = gcommands.setREBOOT()
        if err == 0 or err == 1:
            self.print2NotePad("REBOOT completed")
        else:
            self.print2NotePad("ERROR in doREBOOT: " + errmessage)


    def doFACTORYRESET(self):
        """Does a FACTORYRESET of the device"""

        d = QtGui.QInputDialog()
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        warning ="""
CAUTION - You are about to reset the device to factory condition!
All data and your changes of settings will be lost. \n
If you want to proceed, enter the word 'FACTORYRESET' (in all capital)
and press OK"""

        text, ok = d.getText(self, 'FACTORYRESET', warning)

        vprint(gglobs.verbose, "Factory Reset:", "text=", text, ",  ok=", ok)
        if ok:
            self.print2NotePad(header("Device FACTORYRESET"))
            if text == "FACTORYRESET":
                rec, err, errmessage = gcommands.setFACTORYRESET()
                if err == 0 or err == 1: self.print2NotePad("FACTORYRESET completed")
                else:                    self.print2NotePad("ERROR in doFACTORYRESET: " + message)
            else:
                self.print2NotePad("Entry '{}' not matching 'FACTORYRESET' - Reset NOT done".format(text))


    def toggleDeviceConnection(self):
        """if no connection exists, then make connection else disconnect"""

        if gglobs.logging:
            self.showStatusMessage("Cannot change when logging! Stop logging first")
            return

        if gglobs.ser == None and gglobs.client == None:
            self.switchConnections(new_connection = "ON")
        else:
            self.switchConnections(new_connection = "OFF")


    def switchConnections(self, new_connection = "ON"):
        """
        if new_connection = ON and no connection exists, then try to make
        USB connection (with verification of communication with device)
        else disconnect (unless already disconnected)
        """

        if gglobs.logging:
            self.showStatusMessage("Cannot change when logging! Stop logging first")
            return

        dprint(gglobs.debug, "switchConnections: --> {}. ".format(new_connection))
        debugIndent(1)

        GMC_connection = self.switchGMC_Connection (new_connection = new_connection)
        RM_connection  = self.switchRM_Connection  (new_connection = new_connection)

        # mark as 'connection made' if at least one device is connected
        #print("gglobs.ser, gglobs.client::", gglobs.ser, gglobs.client)
        if gglobs.ser != None or gglobs.client != None:
            self.toggleDeviceConnectionAction.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_closed.png'))))
        else:
            self.toggleDeviceConnectionAction.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_plug_open.png'))))

        # create the variables list for logging using the config for the devices
        # remove any white space from var names
        gmcv = gglobs.GMCvariables.split(",")
        for i in range(0, len(gmcv)): gmcv[i] = gmcv[i].strip()

        rmv  = gglobs.RMvariables.split(",")
        for i in range(0, len(rmv)):  rmv[i] = rmv[i].strip()
        #print("gmcv, rmv::", gmcv, rmv )

        # vardevice is False as default
        # set only those to True, which are configured via config
        for key in gglobs.varnames:
            if key in gmcv:             gglobs.vardevice[key] = True
            if key in rmv:              gglobs.vardevice[key] = True
        #print("gglobs.vardevice:", gglobs.vardevice)

        # set all variables cleared for logging to ok for logging
        for key in gglobs.varnames:
            if gglobs.vardevice[key]:   gglobs.varlog[key] = True
            else:                       gglobs.varlog[key] = False
        #print("gglobs.varlog:   ", gglobs.varlog)

        playMedia()
        self.checkLoggingState()
        self.showTimingSetting(gglobs.logcycle)
        self.notePad.setFocus() # to avoid having the GMC/RM buttons in blue
        debugIndent(0)


    def switchGMC_Connection(self, new_connection = "ON"):
        """
        if new_connection = ON and no connection exists, then try to make
        USB connection (with verification of communication with device)
        else disconnect (unless already disconnected)
        """

        dprint(gglobs.debug, "switchGMC_Connection: --> {}. ".format(new_connection))
        debugIndent(1)

        self.setBusyCursor()

        if new_connection == "ON":
            self.print2NotePad(header("Connect GMC Device"))
            dprint(gglobs.debug, "Connect GMC Device")
            #QtGui.QApplication.processEvents()

            if gglobs.ser != None:
                self.print2NotePad("GMC Device is already connected")

            else:

                # try to open the port; this is the ONLY place calling serialOPEN!
                # gglobs.ser is None on errors, otherwise a proper connection
                gglobs.ser, errmessage = gcommands.serialOPEN()

                if gglobs.ser != None:  # device is connected, and communication had been verified with getVER()

                    self.dbtnDeviceConnect.setText(gglobs.deviceDetected[4:])
                    self.dbtnDeviceConnect.setStyleSheet("QPushButton { background-color : #12cc3d;  border-radius: 2px; border:1px solid silver;color: black; font-size:14px; font-weight:bold}");
                    self.setEnableDeviceActions(new_enable = True)
                    gcommands.getDeviceProperties()

                    gcommands.fprintDeviceInfo()

                    if gglobs.cfg == None or len(gglobs.cfg) != gglobs.configsize:
                        self.errprint2NotePad("Could not read device configuration correctly")
                        self.errprint2NotePad("Configuration dependent commands in menu Device are being inactivated!")
                        self.setDisableDeviceActions()

                    PowerState = gcommands.isPowerOn()
                    if PowerState == "ON":
                        self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power2_on.png'))))
                    elif PowerState == "OFF":
                        self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power2_off.png'))))
                    else:
                        self.DevicePowerToggle.         setEnabled(False)

                else:
                    playMedia(error=True)
                    self.errprint2NotePad(errmessage)
                    self.dbtnDeviceConnect.setText(self.connectTextGMC)
                    self.dbtnDeviceConnect.setStyleSheet("QPushButton { }");
                    fprint("")
                    fprint("If you know that a GMC device is connected:<br>\
                            - Run 'USB Autodiscovery' from menu Help and check for proper port and baudrate<br>\
                            - Look into topic: 'Help'->'Geiger Counter Firmware Bugs' for bugs and workarounds.", error=True, errsound=False)

                    fprint("\nINFO: These USB-to-Serial ports are found on your system:")
                    fprint("    {:15s} {:25s}  {:s}".format("Device", "Name", "Linked?"))
                    # https://github.com/pyserial/pyserial/blob/master/documentation/tools.rst
                    lp = serial.tools.list_ports.comports(include_links=True)
                    for p in lp:
                        if "LINK=" in p.hwid:
                            link = "yes, to: " + p.hwid[p.hwid.find("LINK=") + 5:]
                        else:
                            link = "no"
                        self.print2NotePad("    {:15s} {:25s}  {:s}".format(p.device, p.description, link))

                self.getHistSaveMode()

        else: # new_connection == OFF

            self.print2NotePad(header("Disconnect GMC Device"))
            #QtGui.QApplication.processEvents()

            if gglobs.ser == None:
                self.print2NotePad("No connected Device")


                self.dbtnDeviceConnect.setText(self.connectTextGMC)
                self.dbtnDeviceConnect.setStyleSheet("QPushButton { }")
                PowerState = gcommands.isPowerOn()
                #if PowerState == "ON":
                #    self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power2_on.png'))))
                #elif PowerState == "OFF":
                #    self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power2_off.png'))))
                #else:
                self.DevicePowerToggle.         setEnabled(False)

            else:
                gcommands.serialCLOSE()
                gglobs.cfg = None

                msg = ("Device disconnected successfully:", gglobs.deviceDetected)
                self.print2NotePad(msg[0], msg[1])
                self.setEnableDeviceActions(new_enable = False)
                self.dbtnDeviceConnect.setText(self.connectTextGMC)
                self.dbtnDeviceConnect.setStyleSheet("QPushButton { }")

                self.DevicePowerToggle.         setEnabled(False)


                dprint(gglobs.debug, "switchGMC_Connection: OFF: " + msg[0] + msg[1])

            self.getHistSaveMode()

        debugIndent(0)
        self.setNormalCursor()


    def switchRM_Connection(self, new_connection = "ON"):
        """
        if new_connection = ON and no connection exists, then try to connect
        if new_connection = OFF and a connection exists, then disconnect
        """

        dprint(gglobs.debug, "switchRM_Connection: --> {}. ".format(new_connection))
        debugIndent(1)

        if new_connection == "ON":
            msg = "Connect RadMon Device"
            self.print2NotePad(header(msg))
            dprint(gglobs.debug, msg)
            #debugIndent(1)

            if gglobs.RMserverIP == None:
                msg = "A RadMon server is not configured"
                fprint(msg, error=True)
                dprint(True, msg)
                debugIndent(0)
                return "No device"

            gglobs.RMdevice = gradmon.initRadMon()
            #print("switchConnections: gglobs.RMdevice:", gglobs.RMdevice)

            if gglobs.RMdevice != "":
                # successful connect
                self.dbtnRMplus.setStyleSheet("QPushButton { background-color : #12cc3d;  border-radius: 2px; border:1px solid silver;color: black; font-size:14px; font-weight:bold}");
                self.dbtnRMplus.setText(gglobs.RMdevice)
                self.print2NotePad(gradmon.getRadMonInfo())
                dprint(gglobs.debug, "switchConnections: ON: for device:{} with message: {}".format("RadMon+", gglobs.RMconnect[1]))

            else:
                # failure in connection
                #self.print2NotePad("Connection Error with Device:", "{}".format("RadMon+"))
                self.print2NotePad("", gglobs.RMconnect[1])


        else: # new_connection == OFF
            self.print2NotePad(header("Disconnect RadMon Device"))
            if gglobs.RMdevice != "":
                termAnswer = gradmon.terminateRadMon()

                if termAnswer != "":
                    # successful dis-connect
                    self.dbtnRMplus.setStyleSheet("QPushButton { }");
                    msg = ("Device disconnected successfully: ", str(termAnswer))
                    self.print2NotePad(msg[0], msg[1])
                    self.dbtnRMplus.setText(self.connectTextRM)
                    dprint(gglobs.debug, "switchRM_Connection: OFF: " + msg[0] + msg[1])

                else:
                    self.print2NotePad("Disconnection Error with Device:", "RadMon+")
                    self.print2NotePad("", gglobs.RMdisconnect[1])

            else:
                self.print2NotePad("")
                self.print2NotePad("No connected device")

        debugIndent(0)

        return gglobs.RMdevice


    def checkLoggingState(self):
        """some cleanup of status"""

        if gglobs.ser == None:
            self.startloggingAction.    setEnabled(False)
            self.stoploggingAction.     setEnabled(False)
            self.quickLogAction.        setEnabled(False)
            self.histDeviceAction.      setEnabled(False)
            self.logSnapAction.         setEnabled(False)

        else:
            if gcommands.isPowerOn() != "OFF": # ON or undefined
                self.quickLogAction.       setEnabled(True)

                if gglobs.logFilePath != None :
                    self.startloggingAction.    setEnabled(True)
            else:
                self.quickLogAction.    setEnabled(False)
                self.startloggingAction.setEnabled(False)

            self.histDeviceAction.      setEnabled(True)

        if gglobs.client == None:
            pass
        else:
            self.quickLogAction.    setEnabled(True)
            if gglobs.logFilePath != None :
                self.startloggingAction.setEnabled(True)


        if gglobs.logging == True:
            self.histDeviceAction.      setEnabled(False)
            self.logLoadFileAction.     setEnabled(False)
            self.startloggingAction.    setEnabled(False)
            self.quickLogAction.        setEnabled(False)

            self.stoploggingAction.     setEnabled(True)
            self.WebAction.             setEnabled(True)
            self.logSnapAction.         setEnabled(True)
        else:
            self.stoploggingAction.     setEnabled(False)
            self.WebAction.             setEnabled(False)
            self.logSnapAction.         setEnabled(False)

            self.logLoadFileAction.     setEnabled(True)

        if gglobs.logFilePath != None:
            self.addCommentAction.      setEnabled(True)
        else:
            self.addCommentAction.      setEnabled(False)

        if gglobs.loggingBlocked:
            self.startloggingAction.    setEnabled(False)


    def setEnableDeviceActions(self, new_enable = True):

        # Device
        self.DeviceConnectAction.       setEnabled(not new_enable)
        self.DeviceDisconnectAction.    setEnabled(new_enable)
        self.setLogTimingAction.           setEnabled(new_enable)

        # submenu GMC
        self.DeviceInfoAction.          setEnabled(new_enable)
        self.DeviceConfigAction.        setEnabled(new_enable)
        #self.DeviceSettingAction.       setEnabled(new_enable)
        self.DeviceONAction.            setEnabled(new_enable)
        self.DeviceOFFAction.           setEnabled(new_enable)
        self.DeviceSetTimeAction.       setEnabled(new_enable)
        self.DeviceREBOOTAction.        setEnabled(new_enable)
        self.DeviceFACTORYRESETAction.  setEnabled(new_enable)


        # Device functions using the config
        self.DeviceSpeakerONAction.     setEnabled(new_enable)
        self.DeviceSpeakerOFFAction.    setEnabled(new_enable)
        self.DeviceAlarmONAction.       setEnabled(new_enable)
        self.DeviceAlarmOFFAction.      setEnabled(new_enable)
        self.DeviceSavingStateAction.   setEnabled(new_enable)
        self.btnHistSaveMode.           setEnabled(new_enable)

        # submenu RadMon
        #self.RMInfoAction.              setEnabled(new_enable)

        #toolbar toggle
        self.DevicePowerToggle.         setEnabled(new_enable)

        # History
        self.histDeviceAction.          setEnabled(new_enable)


    def setDisableDeviceActions(self):

        # when config is not usable
        self.DeviceSpeakerONAction.     setEnabled(False)
        self.DeviceSpeakerOFFAction.    setEnabled(False)
        self.DeviceAlarmONAction.       setEnabled(False)
        self.DeviceAlarmOFFAction.      setEnabled(False)
        self.DeviceSavingStateAction.   setEnabled(False)


    def toggleDevicePower(self):
        """Toggle Device Power ON / OFF"""

        if gglobs.logging:
            self.DevicePowerToggle.setChecked(True)
            self.showStatusMessage("Cannot change when logging! Stop logging first")
            return

        if gcommands.isPowerOn() == "ON":
            self.switchDevicePower("OFF")
        else:
            self.switchDevicePower("ON")


    def switchDevicePower(self, newstate = "ON"):
        """Switch Device power to ON or OFF"""

        debugIndent(1)

        msg = "Switch Device Power {}".format(newstate)
        self.print2NotePad(header(msg))
        dprint(gglobs.debug, "switchDevicePower: " + msg)

        self.setBusyCursor()
        if newstate == "ON":
            if gcommands.isPowerOn() != "ON":
                gcommands.setPOWERON()
                time.sleep(3) # takes some time to settle!
        else:
            if gcommands.isPowerOn() == "ON":
                if gglobs.logging:
                    self.stopTimer()
                gcommands.setPOWEROFF()
                time.sleep(3) # takes some time to settle!

        cfg, error, errmessage     = gcommands.getCFG()     # read config after power change
        gglobs.cfg = cfg

        ipo = gcommands.isPowerOn()
        self.print2NotePad("Power State of device is: ",  ipo)

        if   ipo == "ON":
            self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power2_on.png'))))
        elif ipo == "OFF":
            self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power2_off.png'))))
        else:
            self.DevicePowerToggle.setIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_power2_on.png'))))

        self.checkLoggingState()
        self.setNormalCursor()
        debugIndent(0)


    def printGMCDevInfo(self):
        """prints basic info on the GMC device"""

        self.setBusyCursor()

        fprint(header("GMC Device Info"))
        gcommands.fprintDeviceInfo()

        self.setNormalCursor()


    def printGMCDevInfoExtended(self):
        """prints basic info on the GMC device"""

        self.setBusyCursor()

        fprint(header("GMC Device Info Extended"))
        gcommands.fprintDeviceInfoExtended()

        self.setNormalCursor()


    def printRMDevInfo(self):
        """prints basic info on the RadMon device"""

        self.setBusyCursor()

        self.print2NotePad(header("RadMon Device Info"))
        self.print2NotePad(gradmon.getRadMonInfo())

        self.setNormalCursor()


    def printDevConfig(self):
        """prints the 256 or 512 bytes of device configuration"""

        dprint(gglobs.debug, "printDevConfig: ")
        debugIndent(1)

        self.setBusyCursor()

        self.print2NotePad(header("Device Configuration"))
        pdc = gcommands.ftextCFG()
        self.print2NotePad(pdc)
        dprint(gglobs.debug, "printDevConfig:\n" + pdc)

        self.setNormalCursor()

        debugIndent(0)


    def deviceSetDateTime(self):
        """ set date and time on device to computer date and time"""

        dprint(gglobs.debug, "deviceSetDateTime:")
        debugIndent(1)

        self.print2NotePad(header("Set Date&Time of Device"))
        rec, error, errmessage = gcommands.getDATETIME()
        if error < 0:
            self.print2NotePad("Communication problem with device:", errmessage)

            fprint("Trying to force setting Date&Time")
            gcommands.setDATETIME()

            rec, error, errmessage = gcommands.getDATETIME()
            deviceTime = str(rec)
            self.print2NotePad("New Date and Time from device is:", str(deviceTime))

        else:
            computerTime = stime()
            deviceTime   = str(rec)
            deltat       = datestr2num(computerTime) - datestr2num(deviceTime)
            if deltat == 0:
                dtxt = "Device time is same as computer time"
            elif deltat > 0:
                dtxt = "Device is slower than computer by {:0.0f} sec".format(deltat)
            else:
                dtxt = "Device is faster than computer by {:0.0f} sec".format(abs(deltat))

            self.print2NotePad("Date and Time from device is:", deviceTime)
            self.print2NotePad("Date and Time from computer is:", "{}".format(computerTime))
            self.print2NotePad("", "{}\n".format(dtxt))

            self.print2NotePad("Setting device time to computer time")
            gcommands.setDATETIME()

            rec, error, errmessage = gcommands.getDATETIME()
            deviceTime = str(rec)
            self.print2NotePad("New Date and Time from device is:", str(deviceTime))


        debugIndent(0)


    def setHistSaveMode(self):
        """sets the History Saving Mode"""

        dprint(gglobs.debug, "setHistSaveMode:")
        debugIndent(1)

        while True:
            # get current config
            cfg, error, errmessage = gcommands.getCFG()
            gglobs.cfg = cfg
            if error < 0:
                self.print2NotePad("Error:" + errmessage)
                break

            SDT, SDTtxt = gcommands.getSaveDataType()
            gglobs.savedatatype = SDTtxt

            # setup dialog and get new config setting
            selection   = gglobs.savedatatypes
            text, ok    = QtGui.QInputDialog().getItem(self, 'Set History Saving Mode', "Select new history saving mode and press ok:   ", selection, SDT, False )
            vprint(gglobs.verbose, "Set History Saving Mode:", "text=", text, ",  ok=", ok)

            if not ok: break      # user has selected Cancel

            self.print2NotePad(header("Set History Saving Mode"))

            newSDT = selection.index(text)
            #print "newSDT:", newSDT
            self.setBusyCursor()

            # write the new config data
            gcommands.writeConfigData(gglobs.cfgOffsetSDT, newSDT)

            self.setNormalCursor()

            # read the config to verify
            self.print2NotePad(*self.getHistSaveMode()) # getHistSaveMode returns tuple

            break

        debugIndent(0)


    def getHistSaveMode(self):
        """gets the History Saving Mode"""

        dprint(gglobs.debug, "getHistSaveMode:")
        debugIndent(1)

        self.setBusyCursor()

        HistSaveMode = "N.A."
        while True:
            # if no connection
            if gglobs.ser == None:
                self.btnHistSaveMode.setText("Mode: ---")
                break

            # read the config
            cfg, error, errmessage = gcommands.getCFG()
            gglobs.cfg             = cfg
            if error < 0:
                self.errprint2NotePad("Error:" + errmessage)
                break

            SDT, SDTtxt = gcommands.getSaveDataType()
            HistSaveMode = "Device History Saving Mode:", "{}".format(SDTtxt)
            gglobs.savedatatype = SDTtxt

            SMText = ("OFF", "CPS", "CPM", "CPMh", "CPSTh", "CPMTh")[SDT]
            self.btnHistSaveMode.setText("Mode: " + SMText)

            break

        self.setNormalCursor()
        debugIndent(0)

        return HistSaveMode # returns a tuple


    def switchDeviceSpeaker(self, newstate = "ON"):
        """Switch Device Speaker to ON or OFF"""

        self.setBusyCursor()
        self.print2NotePad(header("Switch Device Speaker {}".format(newstate)))

        while True: # to allow jumping to exit
            # get current config
            cfg, error, errmessage = gcommands.getCFG()
            if error < 0:
                self.errprint2NotePad("Error:" + errmessage)
                break

            if newstate == "ON":
                st = 1
            else:
                st = 0

            # write the new config data
            gcommands.writeConfigData(gglobs.cfgOffsetSpeaker, st)

            # check config for success
            cfg, error, errmessage = gcommands.getCFG()
            if error < 0:
                self.errprint2NotePad("Error:" + errmessage)
                break

            if cfg[gglobs.cfgOffsetSpeaker] == 1:
                ipo = "ON"
            else:
                ipo = "OFF"

            self.print2NotePad("Device Speaker State is: ",  ipo)
            break

        self.setNormalCursor()


    def switchDeviceAlarm(self, newstate = "ON"):
        """Switch Device Alarm to ON or OFF"""

        self.setBusyCursor()
        self.print2NotePad(header("Switch Device Alarm {}".format(newstate)))

        while True: # to allow jumping to exit
            # get current config
            cfg, error, errmessage = gcommands.getCFG()
            if error < 0:
                self.errprint2NotePad("Error:" + errmessage)
                break

            if newstate == "ON":
                st = 1
            else:
                st = 0

            # write the new config data
            gcommands.writeConfigData(gglobs.cfgOffsetAlarm, st)

            time.sleep(1.0)

            # check config for success
            cfg, error, errmessage = gcommands.getCFG()
            gglobs.cfg = cfg

            self.print2NotePad("Device Alarm State is: ",  gcommands.isAlarmOn())
            break

        self.setNormalCursor()


#help
    def helpQuickStart(self):
        """Quickstart item on the Help menu"""

        msg = QtGui.QMessageBox(self)
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - Quickstart")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpQuickstart)
        msg.setStandardButtons(QtGui.QMessageBox.Ok)
        msg.setDefaultButton(QtGui.QMessageBox.Ok)
        msg.setEscapeButton(QtGui.QMessageBox.Ok)
        msg.setWindowModality(QtCore.Qt.WindowModal)

        # none of this size stuff works; looks like a bug
        # size does not work; use invisible button as spacer instead
        #msg.resize(800, 800)
        #msg.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        #msg.updateGeometry()
        #msg.setMinimumWidth(900)
        #msg.setBaseSize(900,900)
        #msg.setFixedSize(900, 900)

        btn = QtGui.QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def helpFirmwareBugs(self):
        """Geiger Counter Firmware Bugs info on the Help menu"""

        msg = QtGui.QMessageBox(self)
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - Firmware Bugs")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpFirmwareBugs)
        msg.setStandardButtons(QtGui.QMessageBox.Ok)
        msg.setDefaultButton(QtGui.QMessageBox.Ok)
        msg.setEscapeButton(QtGui.QMessageBox.Ok)
        msg.setWindowModality(QtCore.Qt.WindowModal)

        btn = QtGui.QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def helpWorldMaps(self):
        """Using the Radiation World Map"""

        msg = QtGui.QMessageBox(self)
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - Radiation World Maps")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpWorldMaps)
        msg.setStandardButtons(QtGui.QMessageBox.Ok)
        msg.setDefaultButton(QtGui.QMessageBox.Ok)
        msg.setEscapeButton(QtGui.QMessageBox.Ok)
        msg.setWindowModality(QtCore.Qt.WindowModal)

        btn = QtGui.QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def helpOccupationalRadiation(self):
        """Occupational Radiation Limits"""

        msg = QtGui.QMessageBox(self)
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - Occupational Radiation Limits")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpOccupationalRadiation)
        msg.setStandardButtons(QtGui.QMessageBox.Ok)
        msg.setDefaultButton(QtGui.QMessageBox.Ok)
        msg.setEscapeButton(QtGui.QMessageBox.Ok)
        msg.setWindowModality(QtCore.Qt.WindowModal)

        btn = QtGui.QPushButton()# to become invisible button
        btn.setMinimumWidth(700) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def helpOptions(self):
        """Options item on the Help menu"""

        msg = QtGui.QMessageBox(self)
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - Options")
        msg.setFont(self.fontstd)
        msg.setText(gglobs.helpOptions)
        msg.setStandardButtons(QtGui.QMessageBox.Ok)
        msg.setDefaultButton(QtGui.QMessageBox.Ok)
        msg.setEscapeButton(QtGui.QMessageBox.Ok)
        msg.setWindowModality(QtCore.Qt.WindowModal)

        btn = QtGui.QPushButton()# invisible button
        btn.setMinimumWidth(450) # determines width of box
        btn.setMaximumHeight(0)  # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def changeOptions(self):
        """Switches State of some options"""

        options       = ("Verbose  = False",
                         "Verbose  = True",
                         "Debug    = False",
                         "Debug    = True",
                         "Redirect = False",
                         "Redirect = True",
                         "testing  = False",
                         "testing  = True",
                         )

        index         = 0
        text, ok      = QtGui.QInputDialog().getItem(self, 'Switch Option', "Select new option setting and press ok:   ", options, index, False )
        vprint(gglobs.verbose, "changeOptions: text= '{}', ok={}".format( text, ok))

        if not ok: return      # user has selected Cancel

        newIndex    = options.index(text)

        self.print2NotePad(header("Change Options"))
        self.print2NotePad("New Option setting:", "{}".format(options[newIndex]))

        if   newIndex == 0:
            gglobs.verbose  = False
        elif newIndex == 1:
            gglobs.verbose  = True

        elif newIndex == 2:
            gglobs.debug    = False
        elif newIndex == 3:
            gglobs.debug    = True

        elif newIndex == 4:
            gglobs.redirect = False
        elif newIndex == 5:
            gglobs.redirect = True

        elif newIndex == 6:
            gglobs.testing  = False
        elif newIndex == 7:
            gglobs.testing  = True
        else:
            pass


    def showSystemInfo(self):
        """System Info on the Help Menu"""

        screen           = QtGui.QDesktopWidget().screenGeometry()
        screen_available = QtGui.QDesktopWidget().availableGeometry()
        geom             = self.geometry()
        geom_frame       = self.frameGeometry()

        fmt              = "\n{:33s}{}"
        si               = ""   # system info
        si += fmt.format("Device:",                           "")
        si += fmt.format("  Model connected:",                str(gglobs.deviceDetected))
        try: # fails if gglobs.memory is still 'auto'
            si += fmt.format("  Memory (bytes):",                "{:,}".format(gglobs.memory))
        except:
            si += fmt.format("  Memory (bytes):",                "{:}".format(gglobs.memory))

        try: # fails if gglobs.SPIRpage is still 'auto'
            si += fmt.format("  SPIRpage Size (bytes):",         "{:,}"    .format(gglobs.SPIRpage))
        except:
            si += fmt.format("  SPIRpage Size (bytes):",         "{:}"    .format(gglobs.SPIRpage))
        si += fmt.format("  SPIRbugfix:",                    "{:}"    .format(gglobs.SPIRbugfix))
        si += fmt.format("  configsize (bytes):",            "{:}"    .format(gglobs.configsize))
        si += fmt.format("  Calibration (µSv/h / CPM):",     str(gglobs.calibration))
        si += fmt.format("  Calibration 2nd (µSv/h / CPM):",     str(gglobs.calibration2nd))
        si += fmt.format("  voltagebytes (bytes):",         "{:}"    .format(gglobs.voltagebytes))
        si += fmt.format("  endianness:",                   "{:}"    .format(gglobs.endianness))
        si += fmt.format("  History Saving Mode:",           str(gglobs.savedatatype))
        si += fmt.format("USB Port Settings:",                "")
        si += fmt.format("  Port:",                          str(gglobs.usbport))
        si += fmt.format("  Baudrate:",                      "{:,}".format(int(gglobs.baudrate)))
        si += fmt.format("  Timeout:",                       str(gglobs.timeout))
        si += fmt.format("  ttyS:",                          str(gglobs.ttyS))
        si += fmt.format("Runtime settings:",                 "")
        si += fmt.format("  Flag Debug:",                    str(gglobs.debug))
        si += fmt.format("  Flag Verbose:",                  str(gglobs.verbose))
        si += fmt.format("  Flag KeepFF:",                   str(gglobs.keepFF))
        si += fmt.format("  Flag Redirect:",                 str(gglobs.redirect))
        si += fmt.format("  Flag Development:",              str(gglobs.devel))
        si += fmt.format("  Flag Development #1:",           str(gglobs.devel1))
        si += fmt.format("  Flag Development #2:",           str(gglobs.devel2))
        si += fmt.format("  Flag Testing:",                  str(gglobs.testing))
        si += fmt.format("  GeigerLog Program Directory:",   str(getProgPath()))
        si += fmt.format("  GeigerLog Data Directory:",      str(gglobs.dataPath))
        si += fmt.format("  GeigerLog Resource Directory:",  str(gglobs.gresPath))
        si += fmt.format("  GeigerLog Manual:",              str(gglobs.manual_filename))
        si += fmt.format("Worldmaps Settings:", "")
        for key in ("Website", "URL", "UserID", "CounterID", "SSID", "Password", "Period"):
            si += fmt.format("  " + key, gglobs.GMCmap[key])
        si += fmt.format("GUI:",                              "")
        si += fmt.format("  Monitor:",                        "")
        si += fmt.format("   Screen size - Hardware:",       "{}x{}".format(screen.width(), screen.height()))
        si += fmt.format("   Screen size - Available:",      "{}x{}, at position: x={}, y={}".format(screen_available.width(), screen_available.height(), screen_available.x(), screen_available.y()))
        si += fmt.format("   Current window size:",           "{}x{} including window frame (w/o frame: {}x{})".format(geom_frame.width(), geom_frame.height(), geom.width(), geom.height()))
        si += fmt.format("  Styles:",                         "")
        si += fmt.format("   Styles available on System:",    styles)
        si += fmt.format("   Active Style (internal name):",  str(gglobs.style))
        si += fmt.format("  Fonts:",                          "")
        si += fmt.format("   Active Font - Application:",     strFontInfo("", app.font()))
        si += fmt.format("   Active Font - NotePad:",         strFontInfo("", self.notePad.fontInfo()))
        si += fmt.format("Version status:",                   "")
        for a in version_status():
            si += fmt.format( "  {:}:".format(a[0]),          "{}".format( a[1]))
        si += fmt.format("Platform:",                         "")
        si += fmt.format("  Operating System:",               "{}".format(platform.platform()))
        si += fmt.format("  Machine:",                        "{}, {}".format(platform.machine(), platform.architecture()[0]))

        msg = QtGui.QMessageBox()
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setWindowTitle("Help - System Info")
        msg.setFont(self.fontstd)
        msg.setText(si)
        msg.setStandardButtons  (QtGui.QMessageBox.Ok)
        msg.setDefaultButton    (QtGui.QMessageBox.Ok)
        msg.setEscapeButton     (QtGui.QMessageBox.Ok)
        msg.setWindowModality   (QtCore.Qt.WindowModal)
        #msg.setMinimumWidth(1600) #not working
        ###msg.setTextInteractionFlags(Qt.TextSelectableByMouse)

        btn = QtGui.QPushButton() # to become invisible button defining width of dialog box
        btn.setMinimumWidth(1200) # determines width of box; width is limited by other stuff
        btn.setMaximumHeight(0)   # invisible at height zero!

        msg.addButton(btn, QtGui.QMessageBox.YesRole)
        msg.exec_()


    def openUrl(self):
        """Show the GeigerLog Manual, either the local version, or if not
        possble, then the version on SourceForge"""

        manual_file = None

        #if gglobs.manual_filename != None:
        if gglobs.manual_filename != 'auto':
            # if filename defined in config file, use that name
            # but if file does not exist, it has already been overwritten with
            # None when reading the config
            manual_file = getProgPath() + "/" + gglobs.manual_filename
        else:
            # if NOT defined in config file, use first found file which begins
            # with 'GeigerLog-Manual'
            path = getProgPath() + "/"
            for filename in os.listdir(path):
                #print filename
                if re.match("GeigerLog-Manual", filename):
                    #print "filename", filename
                    manual_file = getProgPath() + "/" + filename
                    break
        #print "manual_file", manual_file

        if manual_file != None:

            try:
                #a = 1/0
                #import subprocess
                if sys.platform.startswith('linux'):
                    subprocess.call(["xdg-open", manual_file])
                    dprint(gglobs.debug, "Showing '{}' via xdg-open on Linux".format(manual_file))
                else:
                    os.startfile(manual_file)
                    dprint(gglobs.debug, "Showing '{}' via os.startfile on other OS".format(manual_file))

                return
            except:
                print(sys.exc_info())
                dprint(gglobs.debug, "Failure Showing '{}' via xdg-open on Linux or via os.startfile on other OS".format(manual_file))

            try:
                #a=1/0
                #import subprocess
                if sys.platform.startswith('linux'):
                    subprocess.call(["firefox", manual_file])
                    dprint(gglobs.debug, "Showing '{}' via firefox on Linux".format(manual_file))
                else:
                    os.startfile(manual_file)
                    dprint(gglobs.debug, "Showing '{}' via os.startfile on other OS".format(manual_file))

                return
            except:
                print(sys.exc_info())
                dprint(gglobs.debug, "Failure Showing '{}' via firefox on Linux or via os.startfile on other OS".format(manual_file))

            try:
                #a = 1/0
                import webbrowser
                webbrowser.open(manual_file)
                dprint(gglobs.debug, "Showing '{}' via import webbrowser".format(manual_file))
                return
            except:
                print(sys.exc_info())
                dprint(gglobs.debug, "Failure Showing '{}' via import webbrowser".format(manual_file))


        try:
            #a=1/0
            shortv = gglobs.__version__.split("_")[0]
            url = QtCore.QUrl('https://sourceforge.net/projects/geigerlog/files/GeigerLog-Manual-v{}.pdf'.format(shortv))
            if not QtGui.QDesktopServices.openUrl(url):
                QtGui.QMessageBox.warning(self, 'GeigerLog Manual', 'Could not open GeigerLog Manual.pdf')
                dprint(gglobs.debug, "Failure Showing manual with QtCore.QUrl")
            else:
                dprint(gglobs.debug, "Showing '{}' via QtCore.QUrl".format(manual_file))
        except:
            print(sys.exc_info())
            dprint(gglobs.debug, "Failure Showing manual with QtCore.QUrl")

        self.errprint2NotePad("WARNING: Could not find GeigerLog-Manual, neither locally nor online!")
        self.print2NotePad("The file 'GeigerLog-Manual-xyz', with xyz being a version number, is missing")
        self.print2NotePad("from the GeigerLog working directory 'geigerlog'.")


    def USBautoDiscovery(self):
        """USB Autodiscovery with option to select any found connection"""

        dprint(gglobs.debug, "USBautoDiscovery:")
        debugIndent(1)

        if gglobs.ser != None:
            self.switchConnections(new_connection = "OFF")
            QtGui.QApplication.processEvents()

        self.setBusyCursor()
        rec, errmessage = gcommands.autoPORT()
        self.setNormalCursor()

        msg = QtGui.QMessageBox(self)
        msg.setWindowTitle("USB Autodiscovery")
        msg.setIcon(QtGui.QMessageBox.Information)
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))

        if rec == None:
            flag = "fail"
            txt1 = errmessage + "\n\nIs device connected? Check cable and plugs! Re-run in a few seconds."
        else:
            if len(rec) == 1:
                flag  = "success"
                txt1  = "A Geiger Counter was found at:\n"
                txt1 += "     Port: " + str(rec[0][0]) + "              Baudrate: " + str(rec[0][1])
                txt1 += "\n\nPress OK to make this your new setting and connect, Cancel otherwise."
                txt1 += "\n\nTo make this permanent edit the configuration file geigerlog.cfg\nand enter above settings in Section 'Serial Port'."

            else:
                flag  = "fail"
                txt1  = "The following ports and baudrates have connected Geiger Counters:\n"
                for i in rec:
                    txt1 += "\n     Port: " + str(i[0]) + "              Baudrate: " + str(i[1])
                txt1 += "\n\nGeigerLog can handle only a single connected Geiger Counter."
                txt1 += "\n\nEither remove all counters except one now and re-run 'USB Autodiscovery', or "
                txt1 += "edit the configuration file geigerlog.cfg in Section 'Serial Port' to define your counter."

        msg.setText(txt1)

        txt1  = "-" * 100
        txt1 += "\nThe current settings of GeigerLog are:"
        txt1 += "\n     Port: " + gglobs.usbport + "                Baudrate: " + str(gglobs.baudrate)
        msg.setInformativeText(txt1)

        if flag == "fail":
            msg.setStandardButtons(QtGui.QMessageBox.Cancel)
        else:
            msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
        msg.setDefaultButton(QtGui.QMessageBox.Cancel)
        msg.setEscapeButton(QtGui.QMessageBox.Cancel)

        retval = msg.exec_()

        if retval == 1024:
            dprint(gglobs.debug, "USBautoDiscovery: Accepting autodiscovered port settings; connecting now")
            gglobs.usbport = str(rec[0][0])
            gglobs.baudrate = str(rec[0][1])
            self.switchConnections(new_connection = "ON")
        else:
            dprint(gglobs.debug, "USBautoDiscovery: Not accepting autodiscovered port settings; cancelling now")

        debugIndent(0)


    def helpAbout(self):
        """About item on the Help menu"""

        description = gglobs.helpAbout.format(__author__, gglobs.__version__, __copyright__, __license__)

        licon   = QtGui.QLabel() # label to hold the geigerlog icon
        licon.setPixmap(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png')))

        ltext   = QtGui.QLabel() # label to hold the 'eigerlog' text as picture
        ltext.setPixmap(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'eigerlog.png')))

        labout  = QtGui.QTextBrowser() # label to hold the description
        labout.setLineWrapMode(QtGui.QTextEdit.WidgetWidth)
        labout.setText(description)
        labout.setOpenExternalLinks(True) # to open links in a browser
        labout.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        #labout.setMinimumWidth(800)
        labout.setMinimumWidth(600)

        d       = QtGui.QDialog(self)
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        d.setFont(self.fontstd)
        d.setWindowTitle("Help - About GeigerLog")
        #d.setWindowModality(QtCore.Qt.ApplicationModal)
        d.setWindowModality(QtCore.Qt.WindowModal)
        #d.setMinimumWidth(800)
        d.setMinimumHeight(gglobs.window_height + 50)
        #d.setMinimumHeight(gglobs.window_height)

        bbox    = QtGui.QDialogButtonBox()
        bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutTop = QtGui.QHBoxLayout()
        layoutTop.addWidget(licon)
        layoutTop.addWidget(ltext)
        layoutTop.addStretch()      # to keep the icons on the left

        layoutV   = QtGui.QVBoxLayout(d)
        layoutV.addLayout(layoutTop)
        layoutV.addWidget(labout)
        layoutV.addWidget(bbox)

        d.exec_()


#utilities in Class
    def errprint2NotePad(self, *args):
        """print into Notepad area an error text in red and make sound"""

        fprint(*args, error=True)


    def print2NotePad(self, *args):
        """print all args in NotePad area"""

        fprint(*args)


    def clearNotePad(self):
        """Clear the notepad"""

        self.notePad.append("<span style='color:black;'></span>")
        self.notePad.clear()


    def printData2NotePad(self, data=None, full=True):
        """Print Log and His Data to notepad, as full file or excerpt"""

        textprintButtonOff = "DataExcerpt"
        textprintButtonOn  = "STOP"

        if self.printbutton.text() == textprintButtonOn:
            gglobs.stopPrinting = True
            return

        self.printbutton.setText(textprintButtonOn)
        self.printbutton.setStyleSheet('QPushButton {color: blue; background-color:white; font:bold;}')

        if data == None:
            if   gglobs.currentFilePath == gglobs.logFilePath:
                data = "Log"
            elif gglobs.currentFilePath == gglobs.hisFilePath:
                data = "His"

        if   data == "Log":
            if full:
                self.showLogData()
            else:
                self.showLogDataExcerpt()

        elif data == "His":
            if full:
                self.showHistHisData()
            else:
                self.showHistExcerpt()

        elif data == "HisBin":
            if full:
                self.showHistBinData()
            else:
                self.showHistBinExcerpt()

        self.printbutton.setStyleSheet('QPushButton {}')
        self.printbutton.setText(textprintButtonOff)


    def print2LogPad(self, *args):
        """print all args in logPad area"""

        line = "{:35s}".format(args[0])
        for s in range(1, len(args)):
            line += "{}".format(args[s])

        self.logPad.append(line)
        QtGui.QApplication.processEvents()


    def clearLogPad(self):
        """Clear the logpad"""

        self.logPad.clear()


    def setBusyCursor(self):

        QtGui.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        #QtGui.QApplication.processEvents()


    def setNormalCursor(self):

        QtGui.QApplication.restoreOverrideCursor()
        #QtGui.QApplication.processEvents()


    def showStatusMessage(self, message, timing=0, error=True):
        """shows message by flashing the Status Bar red for 0.5 sec, then switches back to normal"""

        if error == False:
            self.statusBar.setStyleSheet("QStatusBar { }") # reset to default colors
            self.statusBar.showMessage(message, msecs=timing) # message remains until overwritten by next status
        else:
            playMedia(error=True)
            self.statusBar.showMessage(message, msecs=timing) # message remains until overwritten by next status
            self.statusBar.setStyleSheet("QStatusBar { background-color:red; color:white; }")
            QtGui.QApplication.processEvents()             # assure that things are visible
            QtGui.QApplication.processEvents()             # MUST do twice to make it work, strange!
            time.sleep(0.5)                                # stays red for 0.5 sec
            self.statusBar.setStyleSheet("QStatusBar { }") # reset to default colors


    def printSuSt(self):
        """Prints an overview of data from all variables"""

        try:
            if gglobs.logTimeSlice == None: return
        except:
            pass

        fprint(header("Summary Statistics of Variables selected in Plot"))
        fprint("File      = {}".format(gglobs.currentFilePath))
        fprint("Filesize  = {:10,.0f} Bytes".format(os.path.getsize(gglobs.currentFilePath)))
        fprint("Records   = {:10,.0f} shown in Plot" .format(gglobs.logTimeSlice.size))

        fprint("          [Unit]      Avg  StdDev     Variance          Range         Last Value")
        for i in range(0,gglobs.varcount):
            vname = gglobs.varnames[i]
            try:
                fprint( gglobs.varlabels[vname])
            except:
                pass


    def printStats(self):
        """Printing statistics - will always show only data in the plot"""

        vindex = gglobs.ex.select.currentIndex()
        vname  = gglobs.varnames[vindex]        # var name like CPM, T, P,...
        vnameFull = gglobs.vardict[vname]
        vunit  = gglobs.Yunit                   # CPM, or µSv/h

        try:
            logTime = gglobs.logTimeSlice           # time data
            logVar  = gglobs.logSliceMod[vname]     # var data
        except:
            return

        if logVar is None:
            self.showStatusMessage("No file available") # when called without a loaded file
            return

        labout  = QtGui.QTextBrowser()      # label to hold the description
        labout.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        #labout.setMinimumHeight(700)       # sizing done via QtGui.QDialog()
        #labout.setMinimumWidth(700)
        labout.append("==== Data as shown in the plot for selected variable: {} =============================".format(vnameFull))
        labout.append("from file: {}\n".format(gglobs.currentFilePath))

        logSize          = logTime.size

        logVar_max       = np.nanmax    (logVar)
        logVar_min       = np.nanmin    (logVar)
        logVar_avg       = np.nanmean   (logVar)
        logVar_med       = np.nanmedian (logVar)
        logVar_var       = np.nanvar    (logVar)
        logVar_std       = np.nanstd    (logVar)

        logVar_err       = logVar_std / np.sqrt(logVar.size)
        logVar_sqrt      = np.sqrt(logVar_avg)
        logVar_95        = logVar_std * 1.96   # 95% confidence range

        if vname in ("CPM", "CPS", "1st", "2nd"):
            logVar_text      = "Variable: {} (in units of: {})".format(vnameFull, gglobs.Yunit)
        else:
            logVar_text      = "Variable: {}".format(vnameFull)

        logtime_size     = logTime.size
        logtime_max      = logTime.max()
        logtime_min      = logTime.min()
        logtime_delta    = logtime_max - logtime_min # in days

        labout.append("Totals")
        labout.append("  Filesize  = {:10,.0f} Bytes".format(os.path.getsize(gglobs.currentFilePath)))
        labout.append("  Records   = {:10,.0f}".format(logSize))
        if   gglobs.Yunit == "CPM" and (vname == "CPM" or vname == "1st" or vname == "2nd"):
            labout.append("  Counts    = {:10,.0f}  Counts calculated as: Average CPM * Log-Duration[min]\n".format(logVar_avg * logtime_delta * 24 * 60))
        elif gglobs.Yunit == "CPM" and vname == "CPS" :
            labout.append("  Counts    = {:10,.0f}  Counts calculated as: Average CPS * Log-Duration[sec]\n".format(logVar_avg * logtime_delta * 24 * 60 * 60))
        else:
            labout.append("")

        labout.append("{:<5s}".format(logVar_text))
        labout.append("                       % of avg")
        labout.append("  Average   ={:8.2f}      100%       Min  ={:8.2f}        Max  ={:8.2f}" .format(logVar_avg,                              logVar_min,          logVar_max)          )
        labout.append("  Variance  ={:8.2f} {:8.2f}%"                                          .format(logVar_var,  logVar_var  / logVar_avg * 100.))
        labout.append("  Std.Dev.  ={:8.2f} {:8.2f}%       LoLim={:8.2f}        HiLim={:8.2f}" .format(logVar_std,  logVar_std  / logVar_avg * 100.,  logVar_avg-logVar_std,  logVar_avg+logVar_std)  )
        labout.append("  Sqrt(Avg) ={:8.2f} {:8.2f}%       LoLim={:8.2f}        HiLim={:8.2f}" .format(logVar_sqrt, logVar_sqrt / logVar_avg * 100.,  logVar_avg-logVar_sqrt, logVar_avg+logVar_sqrt) )
        labout.append("  Std.Err.  ={:8.2f} {:8.2f}%       LoLim={:8.2f}        HiLim={:8.2f}" .format(logVar_err,  logVar_err  / logVar_avg * 100.,  logVar_avg-logVar_err,  logVar_avg+logVar_err) )
        labout.append("  Median    ={:8.2f} {:8.2f}%       P_5% ={:8.2f}        P_95%={:8.2f}" .format(logVar_med,  logVar_med  / logVar_avg * 100., np.nanpercentile(logVar, 5), np.nanpercentile(logVar, 95)))
        labout.append("  95% Conf*)={:8.2f} {:8.2f}%       LoLim={:8.2f}        HiLim={:8.2f}" .format(logVar_95,   logVar_95   / logVar_avg * 100.,  logVar_avg-logVar_95,   logVar_avg+logVar_95)   )
        labout.append("")
        labout.append("  *) Approx. valid for a Poisson Distribution when Average > 10\n")

        oldest   = (str(mpld.num2date(logtime_min)))[:19]
        youngest = (str(mpld.num2date(logtime_max)))[:19]

        labout.append("Time")
        labout.append("  Oldest rec    = {}  (time={:.3g} d)".format(oldest,   0))
        labout.append("  Youngest rec  = {}  (time={:.3g} d)".format(youngest, logtime_max - logtime_min))
        labout.append("  Duration      = {:.4g} s   ={:.4g} m   ={:.4g} h   ={:.4g} d".format(logtime_delta *86400., logtime_delta*1440., logtime_delta *24., logtime_delta))
        labout.append("  Cycle average = {:0.2f} s".format(logtime_delta *86400./ (logSize -1)))

        # print the first and last up to 7 lines
        with open(gglobs.currentFilePath, 'rt') as f:
            lines = f.readlines()

        r = min (len(lines), 7)
        labout.append("\nFirst and last {} records:".format(r))
        for i in range(0, r):
            labout.append(lines[i][:-1])

        labout.append("...")
        for i in range(len(lines) - r, len(lines)):
            labout.append(lines[i][:-1])

        d = QtGui.QDialog()
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        d.setFont(self.fontstd)
        d.setWindowTitle("Statistics on Variable: " + vnameFull)
        #d.setWindowModality(QtCore.Qt.ApplicationModal)
        #d.setWindowModality(QtCore.Qt.NonModal)
        d.setWindowModality(QtCore.Qt.WindowModal)
        d.setMinimumWidth(1100)
        d.setMinimumHeight(750)

        bbox    = QtGui.QDialogButtonBox()
        bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutV = QtGui.QVBoxLayout(d)
        layoutV.addWidget(labout)
        layoutV.addWidget(bbox)

        d.exec_()


    def plotPoisson(self):
        """Plotting a Poisson Fit to a histogram of the data"""

        vindex      = gglobs.ex.select.currentIndex()
        vname       = gglobs.varnames[vindex]
        vnameFull   = gglobs.vardict[vname]

        try:
            t0 = gglobs.logTimeDiffSlice
            x0 = gglobs.logSliceMod[vname]
        except:
            return


        if x0 is None:
            self.showStatusMessage("No file available")
            return

        #print("t0, x0: len:", len(t0), len(x0))
        t = np.ndarray(0)
        x = np.ndarray(0)
        for i in range(0,len(t0)):
            if np.isnan(x0[i]):
                #print("i, x0[i]:", i, x0[i])
                continue
            else:
                #print("i, x[i]:", i, x0[i])
                t = np.append(t, t0[i])
                x = np.append(x, x0[i])
        #print("t, x: len:", len(t), len(x))

        DataSrc     = os.path.basename(gglobs.currentFilePath)
        cycletime   = (t[-1] - t[0]) / (t.size - 1)  # in minutes

        ######################################
        # to show histogram of delta between 2 consecutive counts
        if False:
        #if True:
            dx = x[:-1].copy()
            for i in range(0, len(dx)):
                dx[i] = abs(x[i+1] - x[i])
                #if dx[i] > 10: print i, dx[i]
            #print x, len(x)
            #print dx, len(dx)
            x = dx
            yunit = "Differences between 2 consecutive CPM!"
        #######################################

        yunit = vnameFull

        # switch off interactive mode
        #plt.ioff()

        fig2 = plt.figure(2, facecolor = "#E7F9C9")
        plt.clf()
        plt.title("Histogram with Poisson Fit\n", fontsize=12, loc='center')
        subTitle = DataSrc + "  Recs:" + str(x.size)
        plt.title(subTitle, fontsize=10, fontweight='normal', loc = 'right')

        plt.xlabel("Variable {}".format(yunit), fontsize=12)
        plt.ylabel("Frequency of Occurence", fontsize=12)
        plt.grid(True)
        plt.subplots_adjust(hspace=None, wspace=.2 , left=.17, top=0.85, bottom=0.15, right=.97)
        plt.ticklabel_format(useOffset=False)

        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        canvas2 = FigureCanvas(fig2)
        canvas2.setFixedSize(550,400)
        navtoolbar = NavigationToolbar(canvas2, self)

        labout  = QtGui.QTextBrowser() # label to hold the description
        labout.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout.setMinimumHeight(250)

        d       = QtGui.QDialog()
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        d.setFont(self.fontstd)
        d.setWindowTitle("Poisson Test")
        #d.setMinimumHeight(gglobs.window_height)
        #d.setWindowModality(QtCore.Qt.ApplicationModal)
        #d.setWindowModality(QtCore.Qt.NonModal)
        d.setWindowModality(QtCore.Qt.WindowModal)

        bbox    = QtGui.QDialogButtonBox()
        bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutV   = QtGui.QVBoxLayout(d)
        layoutV.addWidget(navtoolbar)
        layoutV.addWidget(canvas2)
        layoutV.addWidget(labout)
        layoutV.addWidget(bbox)

        lenx        = len(x)
        sumx        = np.nansum (x)
        avgx        = np.nanmean(x)
        varx        = np.nanvar (x)
        stdx        = np.nanstd (x)
        minx        = np.nanmin (x)
        maxx        = np.nanmax (x)
        #print("count data: len:{}, sum:{:5.0f}, avg:{:5.3f}, var:{:5.3f}, std:{:5.3f}\n{}\n".format(lenx, sumx, avgx, varx, stdx, x))

        std95       = np.sqrt(avgx) * 1.96
        edge_min    = int(max(0,    min(minx , avgx - (std95 * 1.5))))
        edge_max    = int(max(30,   max(maxx , avgx + (std95 * 1.5))))
        delta       = edge_max - edge_min
        step        = int(delta / 20)
        edge_min    = max(0, edge_min - step)
        edge_max    = edge_max + step
        #print("step: {}, edge_min: {}, edge_max: {}, delta: {}".format(step, edge_min, edge_max, delta))

        bin_edges   = list(range(edge_min, edge_max, step)) # 3 extra steps beyond max value
        #print( "step=", step,  ",len(bin_edges)=", len(bin_edges), ", bin_edges=", bin_edges)

        # CREATE histogram
        # If bins is a sequence, it defines the bin edges, including the
        # rightmost edge, allowing for non-uniform bin widths.
        hist, bins = np.histogram(x, bins=bin_edges)
        #hist, bins = np.histogram(x, bins='auto') # gives bins as rational numbers
        #hist, bins = np.histogram(x, bins='sqrt') # used in Excel; bins as rational numbers
        #print( "hist=\n", hist, len(hist))
        #print( "bins returned by numpy=\n", bins, len(bins))


        # sum up the Poisson dist for the bins from above histogram
        pdfs = []
        #for i in range(0, bin_edges[-1], step):
        for i in range(bin_edges[0], bin_edges[-1], step):
            stepsum = 0
            for j in range(0,step):
                stepsum += scipy.stats.poisson.pmf(i + j, avgx)
            pdfs.append(stepsum * lenx)

        labout.append("No.   Count Rate    Frequency    % of   Poisson-Fit    Residuals")
        labout.append("      from ... to  (blue col)   Total    (red line) (Freq - Fit)")
        for i in range(0, len(hist)):
            labout.append("{:3d}   {:4d} ... <{:<4d} {:8d}   {:5.2f}%   {:10.1f}   {:+10.1f}".format( i, bins[i], bins[i+1], hist[i], hist[i]*100./lenx, pdfs[i], hist[i] - pdfs[i]))
        labout.append("Total count=       {:10d}  100.00%   {:10.1f}".format(sum(hist), sum(pdfs)))

# chi squared stuff  ----------------------------------------------------------

        chi2    = -99
        pchi2   = -99
        fchi2   = -99
        obs     = hist
        exp     = pdfs
        mini    = 0
        maxi    = len(obs)

        # find where obs and exp are both > 5
        for i in range(len(obs)):
            #print("i={}, obs={:9.0f}, exp={:9.2f}".format(i, obs[i], exp[i] ))
            if obs[i] >=5 and exp[i] >= 5:
                #print("mini--> i={}, obs= {}, exp={}".format(i, obs[i], exp[i]))
                mini = i
                break

        for i in range(mini, len(obs) ):
            #print("i={}, obs={:9.0f}, exp={:9.2f}".format(i, obs[i], exp[i] ))
            if obs[i] <= 5 or exp[i] <= 5:
                #print("maxi--> i={}, obs= {}, exp={}".format(i, obs[i], exp[i]))
                maxi = i
                break

        for i in range(maxi, len(obs) ):
            pass
            #print("i={}, obs={:9.0f}, exp={:9.2f}".format(i, obs[i], exp[i] ))

        #print("mini, maxi, diff:", mini, maxi, maxi - mini)

        # cut out only the part where obs and exp are both > 5
        obs = obs[mini:maxi]
        exp = exp[mini:maxi]

        # print data used for chi2 calc
        sumchi = 0
        for i in range(0, len(obs)):
            v = (obs[i] - exp[i])**2/exp[i]
            sumchi += v
            #print("i={:4d}, obs={:11.4f}, exp={:11.4f}, obs-exp={:11.4f}, chi={:11.4f}, sumchi={:11.4f}".format(i, obs[i], exp[i], obs[i] - exp[i], v, sumchi))

        fchi2 = len(obs) -2

        # calc chi2
        # use one extra degree of freedom for avg estimate
        chi2, pchi2 = scipy.stats.chisquare(obs, f_exp=exp, ddof=1, axis=None)
        #print("axis= default, ddof=1,  len(obs):", len(obs),  ",  chisquare, p:", chi2, pchi2, "p[%]: {:5.5f}".format(pchi2 * 100) )

# END chi squared stuff  ------------------------------------------------------

        width = step * 0.8

        # plot histogram ##########################################################
        #plt.bar(bins[:-1], hist, align='center', width=width)
        plt.bar(bins[:-1], hist, align='edge', width=width, label ="avg = {:0.2f}\nvar = {:0.2f}".format(avgx, varx))
        #plt.xlim(xmin = 0, xmax = bins[-1] + step)

        #plt.hist(x, bins=50, rwidth=0.9)
        #plt.hist(x, bins='auto')

        # determine r-squared
        #ss_res = np.sum((hist - pdfs[:-1]    ) ** 2)    # residual sum of squares
        ss_res = np.sum((hist - pdfs    ) ** 2)    # residual sum of squares
        ss_tot = np.sum((hist - np.mean(hist)) ** 2)    # total sum of squares
        r2 = 1 - (ss_res / ss_tot)                      # r-squared

        labout.append("Goodness of Poisson Fit :  r²   = {:5.3f}".format(r2))
        labout.append("Chi-squared Poisson Test:  chi² = {:5.3f}, f= {:1d}, p= {:2.2f}%".format(chi2, fchi2, pchi2 * 100.))

        plt.plot(bins[:-1] + step/2, pdfs, linewidth=3, color='red', label ="r2  = {:0.3f}".format(r2))

        #######################################################################


    # find best place for legend
        #if avgx >= bins[-1]/2:
        if avgx >= (bins[0] + bins[-1]) / 2:
            loc = 'upper left'
        else:
            loc = 'upper right'
        plt.legend(loc=loc, fontsize=12, prop={"family":"monospace"})

    # Assemble Data set statistics
        labout.append("\nData Set:")
        labout.append("File     = {}"    .format(DataSrc))
        labout.append("Records  = {}"    .format(x.size))
        labout.append("Cycletime={:8.2f}".format(cycletime * 86400) + " sec (overall average)")
        labout.append("Average  ={:8.2f}".format(avgx))
        labout.append("Variance ={:8.2f}  same as Average if true Poisson Dist.".format(varx))
        labout.append("Std.Dev. ={:8.2f}".format(stdx))
        labout.append("Sqrt(Avg)={:8.2f}  same as Std.Dev. if true Poisson Dist.".format(np.sqrt(avgx)))
        labout.append("Std.Err. ={:8.2f}".format(stdx / np.sqrt(x.size)))
        labout.append("Skewness ={:8.2f}  0:Norm.Dist.; skewed to: +:right   -:left".format(scipy.stats.skew    (x) ))
        labout.append("Kurtosis ={:8.2f}  0:Norm.Dist.; shape is:  +:pointy: -:flat".format(scipy.stats.kurtosis(x) ))
        labout.append("")

    # show window
        fig2.canvas.draw_idle()
        d.exec_()
        #plt.close()
        #plt.ion() # activate interactive mode again, IMPORTANT


    def createSyntheticLog(self):
        """Create synthetic data and save in log format. All times in SECONDS"""

        fprint("createSyntheticLog presently inactive", error=True)
        return

        records     = 20000
        cycletime   = 60.0
        #mode        = "CPS"
        mode        = "CPM"

        mean        = 2800  # -> "CPM"=150, like in KCl case
        stddev      = np.sqrt(mean)

    # get time
        t = np.float64(np.array(list(range(0, records)))) * cycletime
        print("time: size: {}, Delta-t: {} sec".format(t.size, (t[1] - t[0])))
        print(np.int_(t))

        # convert time in sec to datetime strings
        strt0 = "2018-01-01 00:00:00"          # nominal default start datetime
        t0    = mpld.datestr2num(strt0)        # time zero
        td    = np.empty(records, dtype='U19') # holds strings of max length 19
        print("td, len:", td.size, td)
        for i in range(0, records):
            td[i] = mpld.num2date(t0 + t[i] / 86400.) #clipped after 19 chars

    # get data
        sigt, DataSrc     = self.getWhiteNoisePoisson(records, mean, cycletime, mode)     # White Noise from Poisson Distribution
        #sigt, DataSrc    = self.getWhiteNoiseNormal(records, mean=mean, stddev=stddev)    # White Noise from Normal Distribution
        #sigt, DataSrc    = self.getSinus(records, t)                                      # Sine (one or more)
        #sigt, DataSrc    = self.getWhiteNoiseSine(records, t)                             # White Noise with Sine
        #sigt, DataSrc    = self.getConstantData(records, t)                               # constant + breaks
        #sigt, DataSrc    = self.getAutocorr(records)                                      # Autocorr as time function
        #sigt, DataSrc    = self.getRectangle(records)                                     # Rectangle of 20 samples @ 3sec = 1min
        #sigt, DataSrc    = self.getWhiteNoisePoissonAutocorr(records, mean, cycletime)    # Autocorrelated Poisson Noise
        #sigt, DataSrc    = self.getRandomData(records, mean, stddev)                      # Radom Data

        # Mean=17, followed by mean=29
        #sigt1, DataSrc     = self.getWhiteNoisePoisson(20000, mean=17)                    # White Noise from Poisson Distribution
        #sigt2, DataSrc2    = self.getWhiteNoisePoisson(20000, mean=29)                    # White Noise from Poisson Distribution
        #sigt = np.concatenate((sigt1 , sigt2))
        #print "len(sigt):", len(sigt)
        #DataSrc = "WhiteNoisePoisson,mean=17&29CPM"

        print(DataSrc)

        if mode == "CPS":
            sigt *= 60              # save as CPM

        for i in range(0, 10): print("i: {:4d}, time(sec): {:5.2f}, sigt: {}".format(i, t[i] * 60., sigt[i]))
        print("...")
        for i in range(0, records, int(records/10.)): print("i: {:4d}, time(min): {:5.2f}, sigt: {}".format(i, t[i], sigt[i]))

    # write to log file
        path = gglobs.dataPath + "/" + DataSrc + ".log"
        writeFileW(path, "", linefeed = True)
        writeFileA(path, "#HEADER ," + strt0 + ", SYNTHETIC data: " + DataSrc)
        writeFileA(path, "#LOGGING," + strt0 + ", Start: cycle {} sec, mode '{}', device 'SYNTHETIC'".format(cycletime, mode))
        for i in range(records):
            writestring = " {:7d},{:19s}, {:}".format(i, td[i], sigt[i])
            writeFileA(path, writestring)


    def getWhiteNoisePoisson(self, records, mean, cycletime, mode):
        """White noise data drawn from Poisson distribution"""

        DataSrc = "WhiteNoisePoisson, mean={}, cycle={}, mode={}".format(mean, cycletime, mode)

        x = np.random.poisson(mean, size=records )
        print("x.size, x.mean, x.var, x.std. :", x.size, np.mean(x), np.var(x), np.std(x))
        print(x)

        return x, DataSrc


    def getWhiteNoisePoissonAutocorr(self, records, mean, cycletime):
        """White noise data drawn from Poisson distribution"""

        DataSrc = "Autocorrelated Poisson Noise, CPM={}, cycle={}sec".format(mean, cycletime)

        x    = np.random.poisson(mean / 60., size=records * 60 + 60 )
        print("x.size, x.mean, x.var, x.std. :", x.size, np.mean(x), np.var(x), np.std(x))
        print(x)

        x2   = np.zeros(records)
        print("all zeros: x2.size, x2.mean, x2.var, x2.std. :", x2.size, np.mean(x2), np.var(x2), np.std(x2))

        for i in range(0, records):
            j = i * cycletime
            x2[i] = np.sum(x[j : j + 60])

        print("x2.size, x2.mean, x2.var, x2.std. :", x2.size, np.mean(x2), np.var(x2), np.std(x2))

        return x2, DataSrc


    def getSinus(self, records, t):
        """
        sinus data
        All times in seconds
        """

        DataSrc = "Sinus"

        pi2 = 2.0 * np.pi

        x   = 10.0 + 5.0 * np.sin(t * pi2 / (100. * 60. +  0. )  ) # periode von 100   min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (400. * 60. +  0. )  ) # periode von 400   min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / ( 30. * 60. +  0. )  ) # periode von  50   min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (  3. * 60. +  4. )  ) # periode von   3.x min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (  3. * 60. +  9. )  ) # periode von   3.y min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (  3. * 60. + 13. )  ) # periode von   3.z min
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (  1.0            )  ) # periode von   1   sec
        x  +=  0.0 + 5.0 * np.sin(t * pi2 / (  0.5            )  ) # periode von   0.5 sec

        return x, DataSrc


    def getConstantData(self, records, t):
        """
        constant data
        All times in seconds
        """

        DataSrc = "Constant + Breaks"

        x  = np.ones(records) * 1000

        for i in range(0, records - 10, 20):
            x[i] = 500.
            x[i + 1] = -10.
            x[i + 2] = 1.

        return x, DataSrc


    def getWhiteNoiseNormal(self, records, mean=16, stddev=4):
        """
        White noise data
        All times in seconds
        """

        DataSrc = "WhiteNoiseNormal, mean={}, stddev={:3.2f}".format(mean, stddev)

        x = np.random.normal(mean, stddev, size=records)

        return x, DataSrc


    def getAutocorr(self, records):
        """
        The autocorrelation function as time series to use as input
        All times in seconds
        """

        DataSrc = "Autocorrelation as time series - 1st point=1"

        # a small random component
        mean = 0
        std  = 0.01
        x    = np.random.normal(mean, std, size=records)

        #for a 1 sec cycle time the first 60 records will show a linear down curve
        #for i in range (0, 20):
        #    x[i] = 1 - i * 1./20.

        x[0] = 1


        return x, DataSrc


    def getRectangle(self, records):
        """
        A rectangle 1 min long with 20 samples @ assumed 3sec cycle
        """

        DataSrc = "Rectangle_1min"

        x = np.zeros(records)
        #print x
        for i in range(20):
            x[i] = 1
        print("x:", len(x), x)

        return x, DataSrc



    def getWhiteNoiseSine(self, records, t):
        """
        White noise with Sine data
        All times in seconds
        """

        DataSrc = "WhiteNoiseNormal + Sine"

        pi2 = 2.0 * np.pi

        mean = 2500
        std  = np.sqrt(mean)
        x    = np.random.normal(mean, std, size=records)
        p1   = (100. * 60. + 1.4) / 60.  # 100,0333 min
        print("getWhiteNoiseSinusData: p1:", p1)
        x   +=  40. * std * (np.sin(t * pi2 / p1 ))
        x   +=  10. * std * (np.sin(t * pi2 / 11. ))

        return x, DataSrc


    def getRandomData(self, records, mean, stddev):
        """random data"""

        DataSrc = "Random Data, mean={}, Uniform 0...{}".format(mean, mean*2)

        x = mean * 2 * np.random.rand(records)
        print(DataSrc, x)

        return x, DataSrc

#**Begin Eval_plotFFT *********************************************************

    def Eval_plotFFT(self, type = 'plot'):
        """Plotting FFT and Autocorrelation
        t       = time
        sigt    = Signal in time domain, (CPM/CPS here)
        freq    = Signal in frequency domain

        Has extra function for rectangle and autocorr
        """
        #
        # must be reworked. e.g. 'gglobs.focus' is no longer in use !!!
        #
        fprint("Eval_plotFFT is inactive", error=True)
        return

        markersize = 0.5#1.0

        if type == 'plot':              # use only data shown in the plot
            #print "gglobs.logTimeDiffSlice:", len(gglobs.logTimeDiffSlice), "\n", gglobs.logTimeDiffSlice
            #print "gglobs.logCPMSlice:", len(gglobs.logCPMSlice), "\n", gglobs.logCPMSlice
            rawt    = gglobs.logTimeDiffSlice
            if gglobs.focus == "Left":
                rawsigt = gglobs.logCPMSlice
                yunit = "CPM"
            else:
                rawsigt = gglobs.logCPSSlice
                yunit = "CPS"
            winTitleLabel = " (Data from Plot Only)"
        else:                           # use all data of the file
            #print "gglobs.logTimeDiff", len(), "\n", gglobs.logTimeDiff
            #print "gglobs.logCPM", len(gglobs.logCPM), "\n", gglobs.logCPM
            rawt    = gglobs.logTimeDiff
            if gglobs.focus == "Left":
                rawsigt = gglobs.logCPM
                yunit = "CPM"
            else:
                rawsigt = gglobs.logCPS
                yunit = "CPS"

            winTitleLabel = " (Data from complete File )"

        if rawsigt is None:
            self.showStatusMessage("No file available")
            return

        if rawt.size < 20:
            self.showStatusMessage("Not enough data (need 20+)")
            return

        DataSrc = os.path.basename(gglobs.currentFilePath)

        t    = rawt.copy()
        sigt = rawsigt.copy()



# Window functions ############################################################
        # the only place to activate Window function is here
        use_window_functions = False

        if use_window_functions:
            hamm    = np.hamming (len(t))
            hann    = np.hanning (len(t))
            black   = np.blackman(len(t))
            # Kaiser:
            # "A beta value of 14 is probably a good starting point"
            # beta  Window shape
            # 0     Rectangular
            # 5     Similar to a Hamming
            # 6     Similar to a Hanning
            # 8.6   Similar to a Blackman
            beta    = 5
            kaiser  = np.kaiser(len(t), beta)

            # Select one
            #win     = hamm
            #win     = hann
            #win     = black
            win     = kaiser

            # When using window functions subtract the average in order to avoid
            # spurious low-frequency peaks!
            sigt   = sigt - np.mean(sigt)

            # Time domain signal with Window function applied
            sigt_win = sigt * win

# Prepare variables ###########################################################

        t               = t * 1440.0  # convert days to minutes
        timeunit        = "minutes"
        frequencyunit   = "1/minute"
        cycletime       = (t[-1] - t[0]) / (t.size -1)  # in minutes

        sigt_mean       = np.mean(sigt)
        sigt_var        = np.var(sigt)
        sigt_std        = np.std(sigt)
        sigt_var        = np.var(sigt)
        sigt_err        = sigt_std / np.sqrt(sigt.size)

        print("t:    size:"       , t.size        , "\n", t)
        print("sigt: size:"       , sigt.size     , "\n", sigt)
        #print "sigt_win: size:"  , sigt_win.size , "\n", sigt_win


# figure and canvas ###################################################
        fig3 = plt.figure(3, facecolor = "#C9F9F0") # blueish tint
        plt.clf()
        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        canvas3 = FigureCanvas(fig3)
        canvas3.setFixedSize(1800, 700)
        navtoolbar = NavigationToolbar(canvas3, self)

# Data vs Time ################################################################
        plt.subplot (2,4,2)
        plt.title   ("Time Counts", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(sigt.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Time ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Count Rate  " + yunit, fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.plot    (t, sigt        ,  linewidth=0.4, color='red'   , label ="Time Domain" , marker="o", markeredgecolor='red'   , markersize=markersize)

# Autocorrelation vs Lag #########################################################
    # calculations
        asigt = sigt - sigt_mean
        #print "np.mean(sigt) , np.var(sigt) :", np.mean(sigt),  np.var(sigt)
        #print "np.mean(asigt), np.var(asigt):", np.mean(asigt), np.var(asigt)

        asigtnorm = np.var(asigt) * asigt.size  # to normalize autocorrelation
        ac = np.correlate(asigt, asigt, mode='full') / asigtnorm
        #ac = ac[ac.size/2:]
        ac = ac[int(ac.size/2):]
        #print "ac: len:", ac.size
        #print "ac:", "\n", ac

    # autocorrelation plot
        aax1 =  plt.subplot(2,4, 5)

        plt.title   ("Autocorrelation (normalized) vs. Lag Period", fontsize=11, loc = 'left', y = 1.08)
        plt.xlabel  ("Lag Period ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Autocorrelation", fontsize=12)
        plt.grid    (True)
        #plt.ticklabel_format(useOffset=False)

        aax2 = aax1.twiny()

        # how many points to show enlarged?
        for i in range(t.size):
            if ac[i] < 0: break

        tindex = min(i, t.size * 0.01)
        tindex = max(25, tindex, 60./(cycletime * 60.))
        tindex = int(tindex)  # Warning: ./geigerlog:3483: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
                              # aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="o", markeredgecolor='blue'  , markersize=markersize*2)
                              # What is the reason ?????
        #print "tindex:", tindex

        tnew = t - t[0]
        aax1.plot(tnew,          ac         , linewidth= 1.0, color='red'  , label ="Full Lag Period - Bottom Scale" , marker="o", markeredgecolor='red'   , markersize=markersize * 2)
        #aax1.legend(loc='upper right', fontsize=12)

        aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="D", markeredgecolor='blue'  , markersize=markersize * 6)
        #print "ac:", ac[:10]

        #plt.legend(loc='upper right', fontsize=12)
        plt.legend(loc='upper right', fontsize=8)

        for a in aax1.get_xticklabels():
            #a.set_color("red")
            #a.set_weight("bold")
            pass

        for a in aax2.get_xticklabels():
            a.set_color("blue")
            a.set_weight("bold")

# FFT plots
    # calculations
        # using amplitude spectrum, not power spectrum; power would be freq^2
        freq                = np.abs(np.fft.rfft(sigt     ))
        #freq2              = np.abs(np.fft.rfft(sigt2    ))
        print("freq:"       , len(freq)     , "\n", freq)
        #for i in range(0,100):  print freq[i]

        if use_window_functions:
            freq_win        = np.abs(np.fft.rfft(sigt_win ))
            #print "freq_win:"   , len(freq_win) , "\n", freq_win
            #for i in range(0,100):  print freq_win[i]

        f = np.fft.rfftfreq(t.size, d = cycletime)
        #print "f:   len:", f.size, "\n", f

        p  = np.reciprocal(f[1:])  # skipping 1st value frequency = 0
        #print "Period: len:", p.size, "\n", p


    # Plot FFT vs Time #########################################################
        plt.subplot(2, 4, 1)
        plt.title("FFT Spectrum vs. Time Period", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(freq.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel("Time Period ({})".format(timeunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.loglog(p, freq[1:]        , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)

    # Plot FFT vs Frequency ####################################################
        plt.subplot(2, 4, 6)
        #plt.title("FFT Spectrum vs. Frequency", fontsize=12, loc = 'left')
        plt.title("FFT Counts", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(freq.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], freq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)


# convolution plots ####################################################

        # rect for convolution - nr values of 1, followed by zeros
        nr = int(60 * 0.2)  # nr = 12
        nr = 60

        rect = np.zeros(sigt.size)
        for i in range(nr):
            rect[i] = 1
        print("rect:", len(rect), rect)

        # time axis
        bf = t[:rect.size]

    # Plot Rectangle Signal vs time

        plt.subplot (2, 4, 3)
        plt.title   ("Time Rectangle", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(rect.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Time ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Signal Value", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)
        plt.plot (bf, rect     , linewidth= 1.0, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize*4)


    # FFT of Signal vs Frequency ####################################################

        cfreq = np.abs(np.fft.rfft(rect     ))
        print("cfreq:   len:", cfreq.size, "\n", cfreq)

        f = np.fft.rfftfreq(t.size, d = cycletime)
        print("f:   len:", f.size, "\n", f)

        p  = np.reciprocal(f[1:])  # skipping 1st value frequency = 0
        print("Period: len:", p.size, "\n", p)

        plt.subplot (2, 4, 7)
        plt.title   ("FFT Rectangle", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(cfreq.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel  ("FFT Amplitude", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], cfreq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)


# last columns
    # upper

        csigt = scipy.signal.convolve(rect, sigt ) * (60 / nr)
        csigt = csigt[nr:len(sigt) + nr]
        print("csigt:", len(csigt), csigt)

        plt.subplot (2, 4, 4)
        plt.title   ("Time (Counts CNV Rectangle)", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(csigt.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')

        plt.xlabel  ("Time ({})".format(timeunit), fontsize=12)
        plt.ylabel  ("Count Rate CPM", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.plot (t[:-nr], csigt[:-nr]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)

    # lower
        ccfreq = cfreq * freq

        plt.subplot (2, 4, 8)
        plt.title   ("FFT (Counts CNV Rectangle)", fontsize=12, loc = 'left')
        subTitle = "Recs:" + str(cfreq.size)
        plt.title   (subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel  ("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel  ("FFT Amplitude", fontsize=12)
        plt.grid    (True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], ccfreq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)



# arrange sub plots
        plt.subplots_adjust(hspace=0.4, wspace=0.3, left=.05, top=0.95, bottom=0.09, right=.97)

# textboxes ################################################################
        labout_left  = QtGui.QTextBrowser() # label to hold some data on left side
        labout_left.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout_left.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout_left.setMinimumHeight(150)

        #labout_left.append("{:22s}= {}"                             .format('File'               , os.path.basename(gglobs.currentFilePath)))
        labout_left.append("{:22s}= {}"                             .format('File'               , DataSrc))
        labout_left.append("{:22s}= {}"                             .format("No of Records"      , t.size))
        labout_left.append("{:22s}= {:4.2f}"                        .format("Count Rate Average" , sigt_mean))
        labout_left.append("{:22s}= {:4.2f} (Std.Dev:{:5.2f}, Std.Err:{:5.2f})"    .format("Count Rate Variance" , sigt_var, sigt_std, sigt_err))
        labout_left.append("{:22s}= {:4.2f} sec (overall average)"  .format("Cycle Time"         , cycletime * 60.)) # t is in minutes
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag=  0   sec)", ac[0]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[1] *60.), ac[1]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[2] *60.), ac[2]))
        #labout_left.append("{:22s}= {:4.2f} "                       .format("Autoc(lag={:5.1f} sec)".format(tnew[3] *60.), ac[3]))

        labout_right  = QtGui.QTextBrowser() # label to hold some data on right side
        labout_right.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout_right.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout_right.setMinimumHeight(120)

        fftmax      = np.max    (freq[1:])
        fftmaxindex = np.argmax (freq[1:]) + 1
        f_max       = f         [fftmaxindex ]

        labout_right.append("{:22s}= {:4.0f}"              .format("FFT(f=0)"         , freq[0]) )
        #labout_right.append("{:22s}= {:4.0f}"              .format("len(t)"         , len(t)) )
        labout_right.append("{:22s}= {:4.2f} (= FFT(f=0)/No of Records)".format("Count Rate Average", freq[0] / len(t)) )
        labout_right.append("{:22s}= {:4.2f}"              .format("Max FFT(f>0)"     , fftmax))
        labout_right.append("{:22s}= {}"                   .format("  @ Index"        , fftmaxindex))
        labout_right.append("{:22s}= {:4.4f}"              .format("  @ Frequency"    , f_max ))
        try:
            labout_right.append("{:22s}= {:4.4f}"              .format("  @ Period"       , p[fftmaxindex] ))
        except:
            labout_right.append("{:22s}= {:s}"              .format("  @ Period"       , "undefined" ))


# Pop Up  #################################################################
        d       = QtGui.QDialog()
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        d.setFont(self.fontstd)
        d.setWindowTitle("FFT & Autocorrelation" + winTitleLabel)
        #d.setMinimumHeight(gglobs.window_height)
        #d.setWindowModality(QtCore.Qt.ApplicationModal)
        #d.setWindowModality(QtCore.Qt.NonModal)
        d.setWindowModality(QtCore.Qt.WindowModal)

        bbox    = QtGui.QDialogButtonBox()
        bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutH   = QtGui.QHBoxLayout()
        layoutH.addWidget(labout_left)
        layoutH.addWidget(labout_right)


        layoutV   = QtGui.QVBoxLayout(d)
        layoutV.addWidget(navtoolbar)
        layoutV.addWidget(canvas3)
        layoutV.addLayout(layoutH)
        layoutV.addWidget(bbox)

        fig3.canvas.draw_idle()
        d.exec_()

#**End Eval_plotFFT ***********************************************************


    def plotFFT(self):
        """Plotting FFT and Autocorrelation
        t       = time
        sigt    = Signal in time domain, (CPM/CPS here)
        freq    = Signal in frequency domain
        """
        #print("plotFFT:", "Entry")

        #print("gglobs.logTimeDiffSlice, gglobs.logSliceMod:", gglobs.logTimeDiffSlice, gglobs.logSliceMod)
        if np.all(gglobs.logTimeDiffSlice) == None or np.all(gglobs.logSliceMod) == None: return

        vindex      = gglobs.ex.select.currentIndex()
        vname       = gglobs.varnames[vindex]
        vnameFull   = gglobs.vardict[vname]
        yunit       = vnameFull
        #print("plotFFT: vname, vnameFull: ", vname, vnameFull)

        try:
            rawt0    = gglobs.logTimeDiffSlice
        except Exception as e:
            srcinfo = "plotFFT: could not load time data"
            exceptPrint(e, sys.exc_info(), srcinfo)
            return

        try:
            rawsigt0 = gglobs.logSliceMod[vname]
        except Exception as e:
            srcinfo = "plotFFT: could not load value data"
            exceptPrint(e, sys.exc_info(), srcinfo)
            return

        if rawsigt0 is None:
            self.showStatusMessage("No file available")
            return

        if rawt0.size < 20:
            self.showStatusMessage("Not enough data (need 20+)")
            return

        #print("rawt0, rawsigt0: len:", len(rawt0), len(rawsigt0))
        rawt    = np.ndarray(0)
        rawsigt = np.ndarray(0)
        #print("rawt, rawsigt: len:", len(rawt), len(rawsigt))
        for i in range(0,len(rawt0)):
            if np.isnan(rawsigt0[i]):
                #print("i, x0[i]:", i, x0[i])
                continue
            else:
                #print("i, x[i]:", i, x0[i])
                rawt    = np.append(rawt,    rawt0[i])
                rawsigt = np.append(rawsigt, rawsigt0[i])
        #print("rawt, rawsigt: len:", len(rawt), len(rawsigt))

        markersize = 1.0
        #winTitleLabel = " (Data from Plot Only)"

        DataSrc = os.path.basename(gglobs.currentFilePath)

        t    = rawt.copy()
        sigt = rawsigt.copy()


        ####### Window functions ##############################################
        # the only place to activate Window function is this:
        use_window_functions = False

        if use_window_functions:
            hamm    = np.hamming (len(t))
            hann    = np.hanning (len(t))
            black   = np.blackman(len(t))
            # Kaiser:
            # "A beta value of 14 is probably a good starting point"
            # beta  Window shape
            # 0     Rectangular
            # 5     Similar to a Hamming
            # 6     Similar to a Hanning
            # 8.6   Similar to a Blackman
            beta    = 5
            kaiser  = np.kaiser(len(t), beta)

            # Select one
            #win     = hamm
            #win     = hann
            #win     = black
            win     = kaiser

            # When using window functions subtract the average in order to avoid
            # spurious low-frequency peaks!
            sigt   = sigt - np.mean(sigt)
            #sigt2  = sigt - np.mean(sigt)

            # Time domain signal with Window function applied
            sigt_win = sigt * win
        #######################################################################

        t               = t * 1440.0  # convert days to minutes
        timeunit        = "minutes"
        frequencyunit   = "1/minute"
        cycletime       = (t[-1] - t[0]) / (t.size -1)  # in minutes

        #sigt_mean       = np.mean(sigt)
        #sigt_var        = np.var(sigt)
        #sigt_std        = np.std(sigt)
        #sigt_var        = np.var(sigt)
        #sigt_err        = sigt_std / np.sqrt(sigt.size)

        sigt_mean       = np.nanmean    (sigt)
        sigt_var        = np.nanvar     (sigt)
        sigt_std        = np.nanstd     (sigt)
        sigt_var        = np.nanvar     (sigt)
        sigt_err        = sigt_std / np.sqrt(sigt.size)

        # FFT calculation #####################################################
        # using amplitude spectrum, not power spectrum; power would be freq^2
        freq         = np.abs(np.fft.rfft(sigt     ))
        #freq2        = np.abs(np.fft.rfft(sigt2    ))

        if use_window_functions:
            freq_win     = np.abs(np.fft.rfft(sigt_win ))

        #print "t:    len:"       , len(t)        , "\n", t
        #print "sigt: len:"       , len(sigt)     , "\n", sigt
        #print "sigt_win:"   , len(sigt_win) , "\n", sigt_win
        #print "freq:"       , len(freq)     , "\n", freq
        #for i in range(0,100):  print freq[i]
        #print "freq_win:"   , len(freq_win) , "\n", freq_win
        #for i in range(0,100):  print freq_win[i]

        f = np.fft.rfftfreq(t.size, d = cycletime)
        #print "f:   len:", f.size, "\n", f

        p  = np.reciprocal(f[1:])  # skipping 1st value frequency = 0
        #print "Period: len:", p.size, "\n", p

        asigt = sigt - sigt_mean
        #print "np.mean(sigt) , np.var(sigt) :", np.mean(sigt),  np.var(sigt)
        #print "np.mean(asigt), np.var(asigt):", np.mean(asigt), np.var(asigt)

        asigtnorm = np.var(asigt) * asigt.size  # to normalize autocorrelation
        ac = np.correlate(asigt, asigt, mode='full') / asigtnorm
        #print( "ac: len:", ac.size)
        ac = ac[int(ac.size/2):]
        #print( "ac: len:", ac.size)
        #print( "ac:", "\n", ac)


# figure and canvas ###################################################
        fig3 = plt.figure(3, facecolor = "#C9F9F0") # blueish tint
        plt.clf()
        # canvas - this is the Canvas Widget that displays the `figure`
        # it takes the `figure` instance as a parameter to __init__
        canvas3 = FigureCanvas(fig3)
        canvas3.setFixedSize(1000, 600)
        navtoolbar = NavigationToolbar(canvas3, self)

# Data vs Time ################################################################
        plt.subplot(2,2,1)
        plt.title("Time Course", fontsize=12, loc = 'left')
        #subTitle = "Recs:" + str(gglobs.sizePlotSlice)
        subTitle = "Recs:" + str(sigt.size)
        plt.title(subTitle, fontsize=10, fontweight='normal', loc = 'right')
        plt.xlabel("Time ({})".format(timeunit), fontsize=12)
        #plt.ylabel("Count Rate  " + yunit, fontsize=12)
        plt.ylabel("Variable  " + yunit, fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.plot(t, sigt        ,  linewidth=0.4, color='red'   , label ="Time Domain" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.plot(t, sigt_win    ,  linewidth=0.4, color='black' , label ="Time Domain" , marker="o", markeredgecolor='black' , markersize=markersize)

# Autocorrelation vs Lag #########################################################
        aax1 =  plt.subplot(2,2,3)

        plt.title("Autocorrelation (normalized) vs. Lag Period", fontsize=12, loc = 'left', y = 1.1)
        plt.xlabel("Lag Period ({})".format(timeunit), fontsize=12)
        plt.ylabel("Autocorrelation", fontsize=12)
        plt.grid(True)
        #plt.ticklabel_format(useOffset=False)

        aax2 = aax1.twiny()

        # how many points to show enlarged?
        for i in range(t.size):
            if ac[i] < 0: break

        tindex = min(i, t.size * 0.01)
        tindex = max(25, tindex, 60./(cycletime * 60.))
        tindex = int(tindex)  # Warning: ./geigerlog:3483: VisibleDeprecationWarning: using a non-integer number instead of an integer will result in an error in the future
                              # aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="o", markeredgecolor='blue'  , markersize=markersize*2)
                              # What is the reason ?????
        #print "tindex:", tindex
        #print "type(tindex):", type(tindex)

        tnew = t - t[0]
        aax1.plot(tnew,          ac         , linewidth= 0.4, color='red'  , label ="Full Lag Period - Bottom Scale" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #aax1.legend(loc='upper right', fontsize=12)

        aax2.plot(tnew[:tindex], ac[:tindex], linewidth= 2.0, color='blue' , label ="Expanded Lag Period - Top Scale" , marker="o", markeredgecolor='blue'  , markersize=markersize * 2)
        #print "ac:", ac[:10]

        #plt.legend(loc='upper right', fontsize=12)
        plt.legend(loc='upper right', fontsize=10)

        for a in aax1.get_xticklabels():
            #a.set_color("red")
            #a.set_weight("bold")
            pass

        for a in aax2.get_xticklabels():
            a.set_color("blue")
#            a.set_weight("bold")

# FFT vs Time #########################################################
        plt.subplot(2,2,2)
        plt.title("FFT Amplitude Spectrum vs. Time Period", fontsize=12, loc = 'left')
        plt.xlabel("Time Period ({})".format(timeunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.loglog(p, freq[1:]        , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.loglog(p, freq2[1:] -freq[1:]       , linewidth= 0.4, color='black'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.loglog(p, freq_win[1:]    , linewidth= 0.4, color='black' , label ="FFT" , marker="o", markeredgecolor='black' , markersize=markersize)

# FFT vs Frequency ####################################################
        plt.subplot(2,2,4)
        plt.title("FFT Amplitude Spectrum vs. Frequency", fontsize=12, loc = 'left')
        plt.xlabel("Frequency ({})".format(frequencyunit), fontsize=12)
        plt.ylabel("FFT Amplitude", fontsize=12)
        plt.grid(True)
        plt.ticklabel_format(useOffset=False)

        plt.semilogy (f[1:], freq[1:]     , linewidth= 0.4, color='red'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.semilogy (f[1:], freq2[1:] -freq[1:]     , linewidth= 0.4, color='black'   , label ="FFT" , marker="o", markeredgecolor='red'   , markersize=markersize)
        #plt.semilogy (f[1:], freq_win[1:] , linewidth= 0.4, color='black' , label ="FFT" , marker="o", markeredgecolor='black' , markersize=markersize)

        #plt.legend(loc='upper left', fontsize=12)

# arrange sub plots
        plt.subplots_adjust(hspace=0.5, wspace=0.2, left=.08, top=0.95, bottom=0.090, right=.98)

# textboxes ################################################################
        labout_left  = QtGui.QTextBrowser() # label to hold some data on left side
        labout_left.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout_left.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout_left.setMinimumHeight(150)

        labout_left.append("{:22s}= {}"                             .format('File'               , DataSrc))
        labout_left.append("{:22s}= {}"                             .format("No of Records"      , t.size))
        labout_left.append("{:22s}= {:4.2f}"                        .format("Count Rate Average" , sigt_mean))
        labout_left.append("{:22s}= {:4.2f} (Std.Dev:{:5.2f}, Std.Err:{:5.2f})"    .format("Count Rate Variance" , sigt_var, sigt_std, sigt_err))
        labout_left.append("{:22s}= {:4.2f} sec (overall average)"  .format("Cycle Time"         , cycletime * 60.)) # t is in minutes
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag=  0   sec)", ac[0]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[1] *60.), ac[1]))
        labout_left.append("{:22s}= {:4.2f} "                       .format("A.corr(lag={:5.1f} sec)".format(tnew[2] *60.), ac[2]))

        labout_right  = QtGui.QTextBrowser() # label to hold some data on right side
        labout_right.setLineWrapMode(QtGui.QTextEdit.NoWrap)
        labout_right.setTextInteractionFlags(QtCore.Qt.LinksAccessibleByMouse|QtCore.Qt.TextSelectableByMouse)
        labout_right.setMinimumHeight(120)

        fftmax      = np.max    (freq[1:])
        fftmaxindex = np.argmax (freq[1:]) + 1
        f_max       = f         [fftmaxindex ]

        labout_right.append("{:22s}= {:4.0f}"              .format("FFT(f=0)"         , freq[0]) )
        labout_right.append("{:22s}= {:4.2f} (= FFT(f=0)/No of Records)".format("Count Rate Average", freq[0] / len(t)) )
        labout_right.append("{:22s}= {:4.2f}"              .format("Max FFT(f>0)"     , fftmax))
        labout_right.append("{:22s}= {}"                   .format("  @ Index"        , fftmaxindex))
        labout_right.append("{:22s}= {:4.4f}"              .format("  @ Frequency"    , f_max ))
        labout_right.append("{:22s}= {:4.4f}"              .format("  @ Period"       , p[fftmaxindex] ))


# Pop Up  #################################################################
        d       = QtGui.QDialog()
        d.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        d.setFont(self.fontstd)
        #d.setWindowTitle("FFT & Autocorrelation" + winTitleLabel)
        d.setWindowTitle("FFT & Autocorrelation" )
        #d.setMinimumHeight(gglobs.window_height)
        #d.setWindowModality(QtCore.Qt.ApplicationModal)
        #d.setWindowModality(QtCore.Qt.NonModal)
        d.setWindowModality(QtCore.Qt.WindowModal)

        bbox    = QtGui.QDialogButtonBox()
        bbox.setStandardButtons(QtGui.QDialogButtonBox.Ok)
        bbox.accepted.connect(lambda: d.done(0))

        layoutH   = QtGui.QHBoxLayout()
        layoutH.addWidget(labout_left)
        layoutH.addWidget(labout_right)


        layoutV   = QtGui.QVBoxLayout(d)
        layoutV.addWidget(navtoolbar)
        layoutV.addWidget(canvas3)
        layoutV.addLayout(layoutH)
        layoutV.addWidget(bbox)

        fig3.canvas.draw_idle()
        d.exec_()



    def btnAlpha(self):
        """EvalFFT"""

        self.Eval_plotFFT()


    def btnBeta(self):
        """createSyn"""

        self.createSyntheticLog()


    def btnGamma(self):
        """PlotCCD"""

        fprint("Undefined", error=True)


    def btnDelta(self):
        """PushToWeb"""

        self.pushToWeb()


    def btnEpsilon(self):
        """PrintVars"""

        printVarsStatus(True, origin = "btnEpsilon")


    def btnZeta(self):
        """HelpOpt"""

        self.helpOptions()
        #fprint("Undefined", error=True)


    def btnEta(self):
        """ChngOpt"""

        self.changeOptions()


    def btnTheta(self):
        """SysInfo"""

        self.showSystemInfo()


    def btnIota(self):
        """popup"""

        self.popup()


    def pushToWeb(self):
        """Send countrate info to website"""

        """
        Info on GMCmap:
        from: http://www.gmcmap.com/AutomaticallySubmitData.asp

        Auto submit data URL format:
        http://www.GMCmap.com/log2.asp?AID=UserAccountID&GID=GeigerCounterID &CPM=nCPM&ACPM=nACPM&uSV=nuSV
        At lease one reading data has to be submitted.
            UserAccountID:   user account ID. This ID is assigned once a user registration is completed.
            GeigerCounterID: a global unique ID for each registered Geiger Counter.
            nCPM:  Count Per Minute reading from this Geiger Counter.
            nACPM: Average Count Per Minute reading from this Geiger Counter(optional).
            nuSv:  uSv/h reading from this Geiger Counter(optional).

        Followings are valid data submission examples:
            http://www.GMCmap.com/log2.asp?AID=0230111&GID=0034021&CPM=15&ACPM=13.2&uSV=0.075
            http://www.GMCmap.com/log2.asp?AID=0230111&GID=0034021&CPM=15&ACPM=0&uSV=0
            http://www.GMCmap.com/log2.asp?AID=0230111&GID=0034021&CPM=15&ACPM=0&uSV=0
            http://www.GMCmap.com/log2.asp?AID=0230111&GID=0034021&CPM=15
            http://www.GMCmap.com/log2.asp?AID=0230111&GID=0034021&CPM=15&ACPM=13.2

        The submition result will be returned immediately. Followings are the returned result examples:
            OK.
            Error! User is not found.ERR1.
            Error! Geiger Counter is not found.ERR2.
            Warning! The Geiger Counter location changed, please confirm the location.
         """

        cpmdata = gglobs.logSlice["CPM"]
        #print("cpmdata:", cpmdata)
        lendata = len(cpmdata)
        CPM     = np.mean(cpmdata)
        ACPM    = CPM
        uSV     = CPM * gglobs.calibration

        #Defintions valid only for GMCmap.com
        data         = {}
        data['AID']  = gglobs.GMCmap["UserID"]
        data['GID']  = gglobs.GMCmap["CounterID"]
        data['CPM']  = "{:3.1f}".format(CPM)
        data['ACPM'] = data['CPM']
        data['uSV']  = "{:3.2f}".format(uSV)
        gmcmapURL    = gglobs.GMCmap["Website"] + "/" + gglobs.GMCmap["URL"]  + '?' + urllib.parse.urlencode(data)

        strdata = ""
        mapform = "   {:11s}: {}\n"
        strdata += mapform.format("CPM",        data['CPM'])
        strdata += mapform.format("ACPM",       data['ACPM'])
        strdata += mapform.format("uSV",        data['uSV'])
        strdata += mapform.format("UserID",     data['AID'])
        strdata += mapform.format("CounterID",  data['GID'])
        strdata  = strdata[:-2] # remove last linefeed

        # Dialog Confirm Sending
        msg = QtGui.QMessageBox()
        msg.setWindowIcon(QtGui.QIcon(QtGui.QPixmap(os.path.join(gglobs.gresPath, 'icon_geigerlog.png'))))
        msg.setIcon(QtGui.QMessageBox.Information)
        msg.setFont(self.fontstd)
        msg.setWindowTitle("Updating Radiation World Maps")
        datatext = "Calling server: " + gglobs.GMCmap["Website"] + "/" + gglobs.GMCmap["URL"]
        datatext += "\nwith these data based on {} datapoints:                                          \n\n".format(lendata)
        datatext += strdata + "\n\nPlease confirm with OK, or Cancel"
        msg.setText(datatext)
        msg.setStandardButtons(QtGui.QMessageBox.Ok | QtGui.QMessageBox.Cancel)
        msg.setDefaultButton(QtGui.QMessageBox.Cancel)
        msg.setEscapeButton(QtGui.QMessageBox.Cancel)
        retval = msg.exec_()
        if retval != 1024:   return

        self.print2NotePad(header("Updating Radiation World Maps"))

        dprint(gglobs.debug, "Updating Radiation World Maps - " +  gmcmapURL)
        for a in ("AID", "GID", "CPM", "ACPM", "uSV"): # ordered print
            dprint(gglobs.debug, "{:5s}: {}".format(a, data[a]))

        try:
            with urllib.request.urlopen(gmcmapURL) as response:
                answer = response.read()
            dprint(gglobs.debug, "Server Response:", answer)
        except Exception as e:
            answer = b"Bad URL"
            srcinfo = "Bad URL: " + gmcmapURL
            exceptPrint(e, sys.exc_info(), srcinfo)

        # gmcmap server responses:
        # on wrong credentials:
        # b'\r\n<!--               sendmail.asp-->\r\n\r\nError! User not found.ERR1.'
        # on proper credentials:
        # b'\r\n<!--               sendmail.asp-->\r\n\r\nWarrning! Please update/confirm your location.<BR>OK.ERR0'
        # on proper userid but wrong counter id
        # b'\r\n<!--               sendmail.asp-->\r\n\r\nError! Geiger Counter not found.ERR2.'

        if   b"ERR1" in answer or b"ERR2" in answer :   # wrong userid  or wrong counterid
            self.print2NotePad("Failure updating Radiation World Maps. Website says:")
            self.errprint2NotePad(answer.decode('UTF-8'))

        elif b"ERR0" in answer:
            self.print2NotePad("Successfully updated Radiation World Maps with these data:")
            self.print2NotePad(strdata)
            self.print2NotePad("Website says:")
            self.errprint2NotePad(answer.decode('UTF-8'))

        elif b"Bad URL" in answer:
            self.print2NotePad("Failure updating Radiation World Maps. ERROR:")
            self.errprint2NotePad("Bad URL: " + gmcmapURL)

        else:
            self.print2NotePad("Unexpected response updating Radiation World Maps; Website says:")
            self.errprint2NotePad(answer.decode('UTF-8'))

######## class ggeiger ends ###################################################


def main():
    global app, styles

    # set directories and file names
    gglobs.progName         = getProgName()
    gglobs.progPath         = getProgPath()
    gglobs.gresPath         = getGresPath()
    gglobs.dataPath         = getDataPath()
    gglobs.proglogPath      = getProglogPath()
    gglobs.stdlogPath       = getStdlogPath()
    gglobs.configPath       = getConfigPath()
    gglobs.fileDialogDir    = gglobs.dataPath

    #
    # Make sure that data directory exists; create it if needed
    # exit if it cannot be made or is not writable
    #
    if os.access(gglobs.dataPath , os.F_OK):
        # dir exists, ok
        if not os.access(gglobs.dataPath , os.W_OK):
            # dir exists, but is not writable
            print("ERROR: main: Data directory '{}' exists, but is not writable".format(gglobs.dataDirectory))
            return 1
    else:
        # dir does not exist; make it
        try:
            os.mkdir(gglobs.dataPath )
        except:
            # dir cannot be made
            print("ERROR: main: Could not make data directory '{}'".format(gglobs.dataDirectory))
            return 1

    # Make sure the gres directory exists and is readable
    if os.access(gglobs.gresPath , os.F_OK):
        # dir exists, ok
        if not os.access(gglobs.dataPath , os.R_OK):
            # dir exists, but is not readable
            print("ERROR: main: GeigerLog resource directory {} is not readable. Please, correct".format(gglobs.gresPath))
            return 1
    else:
        print("ERROR: main: GeigerLog resource directory {} does not exist. You may have to reinstall GeigerLog".format(gglobs.gresPath))
        return 1

    #
    # parse command line options
    #
    # sys.argv[0] is progname
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hdvRVp:b:s:", ["help", "debug", "verbose", "Redirect", "Version", "port=", "baudrate=", "style="])
    except getopt.GetoptError as errmessage :
        # print info like "option -a not recognized", then continue
        dprint(True, "ERROR: '{}', use './geigerlog -h' for help".format(errmessage) )
        return 1

    # processing the options
    for opt, optval in opts:
        if opt in ("-h", "--help"):
            #print(usage)
            print (gglobs.helpOptions)
            return

        elif opt in ("-d", "--debug"):
            gglobs.debug = True

        elif opt in ("-v", "--verbose"):
            gglobs.verbose = True

        elif opt in ("-R", "--Redirect"):
            gglobs.redirect = True

        elif opt in ("-V", "--Version"):
            print("Version status:")
            for a in version_status():
                print("   {:13s}: {}".format(a[0], a[1]))
            return


    # processing the args
    for arg in args:
        if arg == "showstyles":
            print("Styles found on system: ")
            for a in list(QtGui.QStyleFactory.keys()): print("   " + a)
            #print("See configuration file geigerlog.cfg, section [Style] for details")
            return

        if arg == "keepFF":
            gglobs.keepFF   = True

        if arg == "devel":
            gglobs.devel    = True

        if arg == "devel1":
            gglobs.devel    = True
            gglobs.devel1   = True

        if arg == "devel2":
            gglobs.devel    = True
            gglobs.devel1    = True
            gglobs.devel2   = True

        if arg == "fullhist":
            gglobs.fullhist = True

        if arg == "testing":
            gglobs.testing = True

        if arg == "test1":
            gglobs.test1 = True

        if arg == "test2":
            gglobs.test2 = True

        if arg == "test3":
            gglobs.test3 = True

        if arg == "test4":
            gglobs.test4 = True

    clearProgramLogFile() #clear and initialize the program log file 'geigerlog.proglog'

    try:
        if gglobs.devel:
            subprocess.call(["tput", "rmam"]) # tput rmam: no line break on lines longer than screen
            dprint(True, "tput rmam was executed" )
        else:
            subprocess.call(["tput", "smam"]) # tput smam: do line break on lines longer than screen
            dprint(True, "tput smam was executed" )
    except:
        dprint(True, "WARNING: tput rmam / tput smam command failed" )

    # Signal handlers
    #dprint(gglobs.debug, "SIGINT handler before:    SIGINT: {}, getsignal(SIGINT): {}".format(signal.SIGINT, signal.getsignal(signal.SIGINT)))
    signal.signal(signal.SIGINT, signal.SIG_DFL) # to allow shut down with ctrl-c when IN THE TERMINAL
    dprint(gglobs.debug, "SIGINT handler activated: SIGINT: {}, getsignal(SIGINT): {}".format(signal.SIGINT, signal.getsignal(signal.SIGINT)))
    #
    # defining the own handler does not work properly
    # but using the default above does not shut down the threaded loop of RadMon MQQT
    # Signal handlers
    # CTRL-C : properly closes all files and devices and shuts down the program
    #dprint(gglobs.debug, "initRadMon: before: SIGINT: {}, getsignal(SIGINT): {}".format(signal.SIGINT, signal.getsignal(signal.SIGINT)))
    #   signal.signal(signal.SIGINT,  signal_handler)   # to handle CTRL-C
    #   signal.signal(signal.SIGTSTP, signal_handler)   # to handle CTRL-Z
    #dprint(gglobs.debug, "after:  SIGINT: {}, getsignal(SIGINT): {}".format(signal.SIGINT, signal.getsignal(signal.SIGINT)))
    #
    # test for what the signals are connected to
    #for i in range(0, 65): # fails with i>64
    #    try:
    #        print(": i: , signal.getsignal(i):", i, signal.getsignal(i))
    #        print(": i: {}, signal.getsignal(i): {}".format(i, signal.getsignal(i)))
    #    except:         print(": i: , signal.getsignal(i):", i, "Failed")

    # prints a list of all Python paths (but not PyQt4 paths)
    #for a in sys.path:
    #    print("sys.path:", a)

    dprint(gglobs.debug, "Command line: sys.argv: {}".format(sys.argv))
    dprint(gglobs.debug, "Recognized: options: {}, commands: {}".format(opts, args))

    dprint(gglobs.debug, "Operating System: {}".format(platform.platform()))
    dprint(gglobs.debug, "Machine: {}, {}".format(platform.machine(), platform.architecture()[0]))

    for a in sys.path:
        vprint(gglobs.verbose, "Python Path: {}".format(a))

    vs = ""
    for a in version_status(): vs += "{}: {},  ".format(a[0], a[1])
    dprint(True, "Version status: ", vs[:-3])

    # matplotlib backend info
    vprint(gglobs.verbose, "Version status: matplotlib backend: ", matplotlib.get_backend())

    vprint(gglobs.verbose, "progName:     " + gglobs.progName)
    vprint(gglobs.verbose, "progPath:     " + gglobs.progPath)
    vprint(gglobs.verbose, "dataPath:     " + gglobs.dataPath)
    vprint(gglobs.verbose, "gresPath:     " + gglobs.gresPath)
    vprint(gglobs.verbose, "proglogPath:  " + gglobs.proglogPath)
    vprint(gglobs.verbose, "configPath:   " + gglobs.configPath)

    # Start PyQt4
    app = QtGui.QApplication(sys.argv)
    app.setApplicationName("GeigerLog") # sets the name 'GeigerLog' as the application name
    #print "get Application Name:", app.applicationName()

    QtCore.QCoreApplication.addLibraryPath(gglobs.progPath + "/custom_libs/")

    dprint(gglobs.debug, "{:40s}".format("QCoreApplication.applicationDirPath():"),  QtCore.QCoreApplication.applicationDirPath())
    dprint(gglobs.debug, "{:40s}".format("QCoreApplication.applicationFilePath():"), QtCore.QCoreApplication.applicationFilePath())

    libPaths    = QtCore.QCoreApplication.libraryPaths()
    libPathStr  = "QCoreApplication.libraryPaths():"
    if len(libPaths) == 0:
        dprint(gglobs.debug, "{:40s}".format(libPathStr), "No Library Paths")
    else:
        for a in libPaths:
            dprint(gglobs.debug, "{:40s}".format(libPathStr), a)

    #
    # Styles:
    #
    # QStyleFactory::keys() returns a list of valid keys, typically including
    # "Windows", "Motif", "CDE", "MotifPlus", "Platinum", "SGI" and "Compact".
    # Depending on the platform, "WindowsXP", "Aqua" or "Macintosh" may be available.
    #
    # Returns here: Breeze, Windows, Motif, CDE, Plastique, GTK+, Cleanlooks
    # best is 1)Breeze, 2)Cleanlooks, 3) Plastique, ... 6)Windows, 7)GTK+
    #
    # app.style().metaObject().className() :  returns Style codings:
    #   Breeze            =Breeze::Style,
    #   Cleanlooks        =QCleanlooksStyle,
    #   Plastique         =QPlastiqueStyle
    #   CDE               =QCDEStyle,
    #   Motif             =QMotifStyle,
    #   Windows           =QWindowsStyle,
    #   GTK+              =QGtkStyle
    #
    # order of my preference; first is best
    styles_rank = ['Breeze', 'Cleanlooks', 'Plastique', 'Windows', 'CDE', 'Motif', 'GTK+' ]
    styles      = []
    for a in list(QtGui.QStyleFactory.keys()): styles.append(str(a))
    dprint(gglobs.debug, "Style: found on system: ", styles)

    # sets the style
    if gglobs.style != None:
        # either defined in config or on command line
        # if both then command line takes precedence
        #print "setting gglobs.style", gglobs.style
        #QtGui.QApplication.setStyle(gglobs.style)
        #app.setStyle(gglobs.style)
        pass
    else:
        for s in styles_rank:       # Default if neither command line nor config
            if s in styles:         # test on availability in order of preference
                #print s
                #QtGui.QApplication.setStyle(s)
                #app.setStyle(s)
                pass
                break

    gglobs.style = app.style().metaObject().className()
    dprint(gglobs.debug, "Style: active: ", gglobs.style)

    # allows copy&Paste also on Win, but makes all Messageboxes as HTML coding
    # cumbersome with using space and tabs for formatting
    #app.setStyleSheet("QMessageBox { messagebox-text-interaction-flags: 5; }")

    # Reads the configuration file
    # settings may override defaults in gglobs.py
    readGeigerConfig()

    #
    # Phonon
    #
    # sound file for messages
    if gglobs.phonon == "active":
        try:
            from PyQt4.phonon import Phonon # used only for an error sound
        except:
            playMedia(error=True)
            print("ERROR: the 'phonon' module could not be found!")
            print("You can either (re-)install the PyQt4 phonon module, or")
            print("edit the 'geigerlog.cfg' file in the 'Audio' section,")
            print("and set 'phonon = inactive'")
            sys.exit(1)

        # sound file for OK message
        gglobs.media = Phonon.MediaObject()
        audio        = Phonon.AudioOutput(Phonon.MusicCategory)
        Phonon.createPath(gglobs.media, audio)
        f            = os.path.join(gglobs.gresPath, "bell.oga")
        gglobs.media.setCurrentSource(Phonon.MediaSource(f))

        # sound file for Error message
        gglobs.mediaErr = Phonon.MediaObject()
        audioErr        = Phonon.AudioOutput(Phonon.MusicCategory) # needed a 2nd time
        Phonon.createPath(gglobs.mediaErr, audioErr)
        f               = os.path.join(gglobs.gresPath, "bell.ogg")
        gglobs.mediaErr.setCurrentSource(Phonon.MediaSource(f))


    # remaining command line options may override options in config file, so
    # must be processed AFTER reading the configuation file!
    for opt, optval in opts:
        if opt in ("-p", "--port"):
            gglobs.usbport = optval
            dprint(gglobs.debug, "Command line setting for: Port: '{}', overriding GeigerConfig".format(gglobs.usbport))

        elif opt in ("-b", "--baudrate"):
            gglobs.baudrate = optval
            dprint(gglobs.debug, "Command line setting for: Baudrate: '{}', overriding GeigerConfig".format(gglobs.baudrate))

        # '-style' is handled by QtGui.QApplication(sys.argv)
        #elif opt in ("-s", "--style"):
        #    gglobs.style = optval
        #    print("-----------------optval:", optval)
        #    dprint(gglobs.debug, "Command line setting for: Style: '{}', overriding GeigerConfig".format(gglobs.style))

    # starting the GUI
    dprint(gglobs.debug, "Starting the GUI " + "-" * 100)
    ex     = ggeiger()     # an instance of ggeiger; runs init and draws window
    status = app.exec_()   # run the GUI until closure
    dprint(gglobs.debug, "Exited GUI with status of: ", status)

    ## switching off the heartbeat function of the counter
    ## now deemed unnecessary
    #if gglobs.ser != None:
    #    rec = gcommands.turnHeartbeatOFF()
    #else:
    #    dprint(gglobs.debug, "Exiting - No serial connection available")

    if gglobs.devel:        subprocess.call(["tput", "smam"]) # tput smam

    sys.exit(status)


if __name__ == '__main__':
    main()
